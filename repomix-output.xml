This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitattributes
.github/workflows/ci.yml
.gitignore
app/components/ErrorMessage.tsx
app/components/ResponseContent.tsx
app/middlewares/csrfMiddleware.ts
app/middlewares/dbInitializeMiddleware.tsx
app/middlewares/jwtCookieMiddleware.tsx
app/routes/_404.tsx
app/routes/_middleware.tsx
app/routes/_renderer.tsx
app/routes/admin/_middleware.tsx
app/routes/admin/index.tsx
app/routes/admin/password.tsx
app/routes/index.tsx
app/routes/login/admin.tsx
app/routes/senbura/dat/[iddat].tsx
app/routes/senbura/head.txt.tsx
app/routes/senbura/SETTINGS.TXT.tsx
app/routes/senbura/subject.txt.tsx
app/routes/subback.html.tsx
app/routes/test/bbs.cgi.tsx
app/routes/threads/[id]/[query].tsx
app/routes/threads/[id]/index.tsx
app/routes/threads/[id]/responses.tsx
app/routes/threads/index.tsx
app/server.ts
app/style.css
app/utils/convertShiftJis.ts
app/utils/getConnInfoRuntimeSwitch.ts
app/utils/getIpAddress.ts
db/migrations/20240629000000_create_tables.sql
db/schema.sql
docker-compose.dev.yml
docker-compose.prod.yml
Dockerfile.app
eslint.config.ts
LICENSE
package.json
public/favicon.svg
README.md
src/config/domain/read/ReadBoardConfig.ts
src/config/domain/read/ReadBoardName.ts
src/config/domain/read/ReadDefaultAuthorName.ts
src/config/domain/read/ReadLocalRule.ts
src/config/domain/read/ReadMaxContentLength.ts
src/config/domain/read/ReadNormalConfig.ts
src/config/domain/read/ReadPasswordHash.ts
src/config/domain/write/WriteBoardName.test.ts
src/config/domain/write/WriteBoardName.ts
src/config/domain/write/WriteDefaultAuthorName.test.ts
src/config/domain/write/WriteDefaultAuthorName.ts
src/config/domain/write/WriteLocalRule.test.ts
src/config/domain/write/WriteLocalRule.ts
src/config/domain/write/WriteMaxContentLength.test.ts
src/config/domain/write/WriteMaxContentLength.ts
src/config/domain/write/WriteNormalConfig.test.ts
src/config/domain/write/WriteNormalConfig.ts
src/config/domain/write/WritePassword.test.ts
src/config/domain/write/WritePassword.ts
src/config/domain/write/WritePasswordHash.test.ts
src/config/domain/write/WritePasswordHash.ts
src/config/repositories/getBoardConfigRepository.ts
src/config/repositories/getDefaultAuthorNameRepository.ts
src/config/repositories/getMaxContentLengthRepository.ts
src/config/repositories/getNormalConfigRepository.ts
src/config/repositories/getPasswordHashRepository.ts
src/config/repositories/updateNormalConfigRepository.ts
src/config/repositories/updatePasswordHashRepository.ts
src/config/usecases/getBoardConfigUsecase.ts
src/config/usecases/getNormalConfigUsecase.ts
src/config/usecases/updateNormalConfigUsecase.ts
src/config/usecases/updatePasswordUsecase.ts
src/config/usecases/verifyAdminPasswordUsecase.ts
src/conversation/domain/read/ReadAuthorName.ts
src/conversation/domain/read/ReadHashId.ts
src/conversation/domain/read/ReadMail.ts
src/conversation/domain/read/ReadPostedAt.ts
src/conversation/domain/read/ReadResponse.ts
src/conversation/domain/read/ReadResponseContent.ts
src/conversation/domain/read/ReadResponseId.ts
src/conversation/domain/read/ReadResponseNumber.ts
src/conversation/domain/read/ReadThread.ts
src/conversation/domain/read/ReadThreadEpochId.ts
src/conversation/domain/read/ReadThreadId.ts
src/conversation/domain/read/ReadThreadTitle.ts
src/conversation/domain/read/ReadThreadWithEpochId.ts
src/conversation/domain/read/ReadThreadWithResponses.ts
src/conversation/domain/write/WriteAuthorName.test.ts
src/conversation/domain/write/WriteAuthorName.ts
src/conversation/domain/write/WriteHashId.test.ts
src/conversation/domain/write/WriteHashId.ts
src/conversation/domain/write/WriteMail.test.ts
src/conversation/domain/write/WriteMail.ts
src/conversation/domain/write/WritePostedAt.test.ts
src/conversation/domain/write/WritePostedAt.ts
src/conversation/domain/write/WriteResponse.test.ts
src/conversation/domain/write/WriteResponse.ts
src/conversation/domain/write/WriteResponseContent.test.ts
src/conversation/domain/write/WriteResponseContent.ts
src/conversation/domain/write/WriteResponseId.test.ts
src/conversation/domain/write/WriteResponseId.ts
src/conversation/domain/write/WriteResponseNumber.test.ts
src/conversation/domain/write/WriteResponseNumber.ts
src/conversation/domain/write/WriteThread.test.ts
src/conversation/domain/write/WriteThread.ts
src/conversation/domain/write/WriteThreadEpochId.test.ts
src/conversation/domain/write/WriteThreadEpochId.ts
src/conversation/domain/write/WriteThreadId.test.ts
src/conversation/domain/write/WriteThreadId.ts
src/conversation/domain/write/WriteThreadTitle.test.ts
src/conversation/domain/write/WriteThreadTitle.ts
src/conversation/repositories/createResponseByThreadIdRepository.ts
src/conversation/repositories/createThreadRepository.ts
src/conversation/repositories/getAllResponsesByThreadEpochIdRepository.ts
src/conversation/repositories/getAllResponsesByThreadIdRepository.ts
src/conversation/repositories/getAllThreadsRepository.ts
src/conversation/repositories/getAllThreadsWithEpochIdRepository.ts
src/conversation/repositories/getLatest10ThreadsWithResposesRepository.ts
src/conversation/repositories/getLatest30ThreadsRepository.ts
src/conversation/repositories/getLatestResponsesByThreadIdAndCountRepository.ts
src/conversation/repositories/getResponseByThreadIdAndResNumRangeRepository.ts
src/conversation/repositories/getResponseByThreadIdAndResNumRepository.ts
src/conversation/repositories/getThreadIdByThreadEpochIdRepository.ts
src/conversation/repositories/updateThreadUpdatedAtRepository.ts
src/conversation/usecases/getAllResponsesByThreadEpochIdUsecase.ts
src/conversation/usecases/getAllResponsesByThreadIdUsecase.ts
src/conversation/usecases/getAllThreadsPageUsecase.ts
src/conversation/usecases/getAllThreadsWithEpochIdUsecase.ts
src/conversation/usecases/getLatestResponsesByThreadIdAndCountUsecase.ts
src/conversation/usecases/getResponseByThreadIdAndResNumRangeUsecase.ts
src/conversation/usecases/getResponseByThreadIdAndResNumUsecase.ts
src/conversation/usecases/getTopPageUsecase.ts
src/conversation/usecases/postResponseByThreadEpochIdUsecase.ts
src/conversation/usecases/postResponseByThreadIdUsecase.ts
src/conversation/usecases/postThreadUsecase.ts
src/shared/types/Error.ts
src/shared/types/Nominal.ts
src/shared/types/VakContext.ts
src/shared/utils/createTrip.ts
src/shared/utils/formatDate.ts
src/shared/utils/validateUUIDv7.ts
src/vite-env.d.ts
tsconfig.json
vite.config.ts
wrangler.jsonc
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
node_modules
dist
.wrangler
.dev.vars
.hono
</file>

<file path="app/components/ErrorMessage.tsx">
// eslint-disable-next-line @typescript-eslint/naming-convention
export const ErrorMessage = ({ error }: { error: Error }) => {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <p className="text-red-500 text-lg font-bold">エラーが発生しました</p>
      <p className="text-gray-700">{error.message}</p>
      <a
        href="javascript:history.back()"
        className="text-blue-500 hover:underline mt-4"
      >
        戻る
      </a>
    </div>
  );
};
</file>

<file path="app/routes/_404.tsx">
import type { NotFoundHandler } from "hono";

const handler: NotFoundHandler = (c) => {
  return c.render(
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-purple-500 text-lg font-bold">404 Not Found</h1>
      <p className="text-gray-700">存在しないページのようです。</p>
      <p className="text-gray-700">URLを確認してください。</p>
      <a
        href="javascript:history.back()"
        className="text-blue-500 hover:underline mt-4"
      >
        戻る
      </a>
    </div>
  );
};

export default handler;
</file>

<file path="app/server.ts">
import { showRoutes } from "hono/dev";
import { createApp } from "honox/server";

const app = createApp();

showRoutes(app);

export default app;
</file>

<file path="app/utils/convertShiftJis.ts">
import iconv from "iconv-lite";

export const convertShiftJis = (text: string) => {
  const buffer = iconv.encode(text, "Shift_JIS");
  return new Response(buffer, {
    headers: { "Content-Type": "text/plain; charset=Shift_JIS" },
  });
};
</file>

<file path="app/utils/getIpAddress.ts">
import { env } from "hono/adapter";

import { getConnInfowithRuntimeSwitch } from "./getConnInfoRuntimeSwitch";

import type { Context } from "hono";

export const getIpAddress = (c: Context): string => {
  // ヘッダからプロキシの識別子とヘッダを取得
  const customProxyId = c.req.header("X-Custom-ProxyID") || "";
  const xForwardedFor = c.req.header("X-Forwarded-For");

  // 信頼できるプロキシ識別子を取得
  const trustedProxyId = env<{ TRUSTED_PROXY_ID: string }>(c).TRUSTED_PROXY_ID;

  // もし一致していれば
  if (customProxyId === trustedProxyId && xForwardedFor) {
    // プロキシの識別子を取得
    return xForwardedFor;
  }

  // X-Forwarded-For ヘッダが使えない場合はgetConnInfoで試す

  const getConnInfoFunc = getConnInfowithRuntimeSwitch(c);
  const ipAddressRaw = getConnInfoFunc();

  if (ipAddressRaw.isOk()) {
    return ipAddressRaw.value;
  }

  // どちらも取得できない場合は空文字を返す
  return "";
};
</file>

<file path="db/migrations/20240629000000_create_tables.sql">
--migrate:up
-- スレッドテーブル
CREATE TABLE threads(
    id UUID PRIMARY KEY,
    title TEXT NOT NULL,
    posted_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL,
    -- 妥協としての非正規化。本来はposted_atから導出すべき。
    epoch_id BIGINT NOT NULL UNIQUE
)
;
-- epoch_idにインデックス
CREATE INDEX idx_threads_epoch_id ON threads(epoch_id);
-- updated_atにインデックス
CREATE INDEX idx_threads_updated_at ON threads(updated_at DESC);

-- レスポンス(レス)のテーブル
CREATE TABLE responses(
    id UUID PRIMARY KEY,
    -- 無理に外部キー制約を張る必要はないので、外部キー制約は付けない
    thread_id UUID NOT NULL,
    response_number INT NOT NULL,
    author_name TEXT NOT NULL,
    mail TEXT NOT NULL,
    posted_at TIMESTAMP WITH TIME ZONE NOT NULL,
    response_content TEXT NOT NULL,
    hash_id TEXT NOT NULL,
    trip TEXT,
    UNIQUE(thread_id, response_number)
)
;
-- thread_idにインデックス
CREATE INDEX idx_responses_thread_id ON responses(thread_id);
-- thread_idとresponse_numberに複合インデックス
CREATE INDEX idx_responses_thread_id_response_number ON responses(thread_id, response_number);

-- ダミーのスレッドを追加
INSERT INTO threads(
    id,
    title,
    posted_at,
    updated_at,
    epoch_id
)
VALUES(
    '01953082-1ea4-7a71-8ac2-395cedbd9ecb',
    'ようこそ！',
    '2025-01-01 00:00:00',
    '2025-01-01 00:00:00',
    1735657200
)
;
INSERT INTO responses(
    id,
    thread_id,
    response_number,
    author_name,
    mail,
    posted_at,
    response_content,
    hash_id,
    trip
)
VALUES(
    '01953082-8ae5-7df7-8446-e02b6b9189e7',
    '01953082-1ea4-7a71-8ac2-395cedbd9ecb',
    1,
    'VakKarma',
    'dummy@example.com',
    '2025-01-01 00:00:00',
    'VakKarma Boardへようこそ！',
    'welcome.',
    'UNhY4JhezH9g'
)
;
-- 板の設定を保存するテーブル
-- とりあえず現時点では1つの板のみをサポート
CREATE TABLE config(
    board_name TEXT PRIMARY KEY,
    local_rule TEXT NOT NULL,
    nanashi_name TEXT NOT NULL,
    max_content_length INT NOT NULL,
    admin_password TEXT NOT NULL
)
;
INSERT INTO config(
    board_name,
    local_rule,
    nanashi_name,
    max_content_length,
    admin_password
)
VALUES(
    'VakKarma Board',
    'ローカルルールはここに記述',
    '名無しさん',
    1000,
    -- password
    '$2b$10$9gxLQMYSDoBdbz/1znmieu1vjhZ2VGzKd21azF112uG45DvQNn0E6'
)
;
--migrate:down
-- 関連するテーブルを削除
DROP TABLE IF EXISTS responses CASCADE
;
DROP TABLE IF EXISTS threads CASCADE
;
DROP TABLE IF EXISTS config CASCADE
;
</file>

<file path="docker-compose.dev.yml">
version: "3.8"

services:
  db:
    image: postgres:17.4
    environment:
      - POSTGRES_USER=${VITE_POSTGRES_USER}
      - POSTGRES_PASSWORD=${VITE_POSTGRES_PASSWORD}
      - POSTGRES_DB=${VITE_POSTGRES_DB}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data_dev:/var/lib/postgresql/data
    networks:
      - all_network
    restart: unless-stopped
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${VITE_POSTGRES_USER} -d ${VITE_POSTGRES_DB}",
        ]
      interval: 5s
      timeout: 5s
      retries: 5

  migration:
    image: amacneil/dbmate:latest
    environment:
      - DATABASE_URL=postgres://${VITE_POSTGRES_USER}:${VITE_POSTGRES_PASSWORD}@db:5432/${VITE_POSTGRES_DB}?sslmode=disable
    volumes:
      - ./db/migrations:/db/migrations
    command: --migrations-dir /db/migrations up
    networks:
      - all_network
    depends_on:
      db:
        condition: service_healthy

networks:
  all_network:

volumes:
  postgres_data_dev:
</file>

<file path="docker-compose.prod.yml">
version: "3.8"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.app
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      - TRUSTED_PROXY_ID=${TRUSTED_PROXY_ID}
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
    networks:
      - all_network
    depends_on:
      - db
    restart: unless-stopped
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app.rule=PathPrefix(`/`)"
      - "traefik.http.routers.app.entrypoints=web"
      - "traefik.http.services.app.loadbalancer.server.port=3000"
      - "traefik.http.routers.app.middlewares=custom-proxy-id"
      # プロキシの識別子をカスタムヘッダーに設定するミドルウェア
      - "traefik.http.middlewares.custom-proxy-id.headers.customrequestheaders.X-Custom-ProxyID=${TRUSTED_PROXY_ID}"

  proxy:
    image: traefik:3.3.4
    ports:
      - "80:80"
      - "8080:8080"
    command:
      - "--global.checkNewVersion=true"
      - "--global.sendAnonymousUsage=false"
      - "--log.level=INFO"
      - "--entryPoints.web.address=:80"
      - "--providers.docker.endpoint=unix:///var/run/docker.sock"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.watch=true"
      # 信頼できる IP アドレスの設定
      - "--entrypoints.web.forwardedHeaders.trustedIPs=172.16.0.0/12"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - all_network
    labels:
      - "traefik.enable=true"

  db:
    image: postgres:17.4
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
    networks:
      - all_network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5

  migration:
    image: amacneil/dbmate:latest
    environment:
      - DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}?sslmode=disable
    volumes:
      - ./db/migrations:/db/migrations
    command: --migrations-dir /db/migrations up
    networks:
      - all_network
    depends_on:
      db:
        condition: service_healthy # db のヘルスチェックが成功するのを待つ

networks:
  frontend:
  backend:
  migration:
  all_network:

volumes:
  postgres_data_prod:
</file>

<file path="Dockerfile.app">
# reference: https://pnpm.io/ja/docker
FROM node:lts AS base
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
COPY . /app
WORKDIR /app

FROM base AS prod-deps
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --prod --frozen-lockfile

FROM base AS build
RUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --frozen-lockfile
RUN pnpm run build:bun

# 実行ステージ
FROM oven/bun:1.2.4

WORKDIR /dist

# ビルドステージから必要なファイルだけコピー
COPY --from=build /app/dist /dist

# アプリケーションの実行
CMD ["./index.js"]
</file>

<file path="eslint.config.ts">
import safeql from "@ts-safeql/eslint-plugin/config";
import dotenv from "dotenv"; // dotenv をインポート
import importPlugin from "eslint-plugin-import-x";
import unusedImports from "eslint-plugin-unused-imports"; // eslint-plugin-unused-imports をインポート
import tseslint from "typescript-eslint";

dotenv.config(); // dotenv を読み込む
const enableSafeQL = process.env.DISABLE_SAFEQL !== "true";
const databaseUrl = `postgresql://${process.env.VITE_POSTGRES_USER}:${process.env.VITE_POSTGRES_PASSWORD}@localhost:5432/${process.env.VITE_POSTGRES_DB}?sslmode=disable`;

export default tseslint.config(
  ...tseslint.configs.recommended,
  {
    ignores: [
      "dist/",
      "build/",
      "out/",
      "coverage/",
      "*.min.js",
      "generated/",
      "*.generated.ts",
      "webpack.config.js",
      "babel.config.js",
      "*.test.js",
      "*.spec.js",
      "__tests__/",
      "src/legacy-code.js",
      "config/*",
      "!config/important.js",
      "*.d.ts",
    ],
    plugins: {
      import: importPlugin,
      "unused-imports": unusedImports, // unused-imports プラグインを追加
    },
    rules: {
      // 変数は小文字キャメルケース、構造体は大文字キャメルケース
      "@typescript-eslint/naming-convention": [
        "error",
        {
          selector: "variable",
          format: ["camelCase"],
        },
        {
          selector: "typeLike",
          format: ["PascalCase"],
        },
      ],

      // 型のimportであればtype importをつける
      "@typescript-eslint/consistent-type-imports": [
        "error",
        {
          prefer: "type-imports",
          disallowTypeAnnotations: false,
        },
      ],

      // importの並び替え
      "import/order": [
        "error",
        {
          groups: [
            "builtin",
            "external",
            "internal",
            "parent",
            "sibling",
            "index",
            "object",
            "type",
          ],
          "newlines-between": "always",
          alphabetize: {
            order: "asc",
            caseInsensitive: true,
          },
        },
      ],
      // 不要なimportの禁止
      // "import/no-unresolved": "error",
      "import/named": "error",
      "import/namespace": "error",
      "import/default": "error",

      // eslint-plugin-unused-imports の設定
      "no-unused-vars": "off", // 既存の no-unused-vars をオフにする
      "@typescript-eslint/no-unused-vars": "off", // TypeScript ESLint の no-unused-vars もオフにする
      "unused-imports/no-unused-imports": "error", // 未使用のインポートをエラーにする
      "unused-imports/no-unused-vars": [
        "warn", // 未使用の変数を警告にする
        {
          vars: "all", // すべての変数をチェック
          varsIgnorePattern: "^_", // _ で始まる変数は無視
          args: "after-used", // 使用された引数以降の引数をチェック
          argsIgnorePattern: "^_", // _ で始まる引数は無視
        },
      ],
    },
    settings: {
      "import/resolver": {
        typescript: {
          project: "tsconfig.json",
        },
      },
      "import/parsers": {
        "@typescript-eslint/parser": [".ts", ".tsx"],
      },
    },
  },
  // SafeQL 設定を環境変数で制御するように追加
  ...(enableSafeQL
    ? [
        safeql.configs.connections({
          databaseUrl: databaseUrl,
          targets: [{ tag: "sql", transform: "{type}[]" }],
        }),
      ]
    : [])
);
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 ryu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="public/favicon.svg">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   version="1.0"
   width="365.80438pt"
   height="143.10474pt"
   viewBox="0 0 365.80438 143.10474"
   preserveAspectRatio="xMidYMid"
   id="svg4"
   sodipodi:docname="favicon.svg"
   inkscape:version="1.4 (e7c3feb100, 2024-10-09)"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg">
  <sodipodi:namedview
     id="namedview1"
     pagecolor="#ffffff"
     bordercolor="#000000"
     borderopacity="0.25"
     inkscape:showpageshadow="2"
     inkscape:pageopacity="0.0"
     inkscape:pagecheckerboard="0"
     inkscape:deskcolor="#d1d1d1"
     inkscape:document-units="pt"
     inkscape:zoom="2.9749507"
     inkscape:cx="243.86959"
     inkscape:cy="95.463767"
     inkscape:window-width="1620"
     inkscape:window-height="1018"
     inkscape:window-x="60"
     inkscape:window-y="0"
     inkscape:window-maximized="1"
     inkscape:current-layer="svg4" />
  <defs
     id="defs4" />
  <metadata
     id="metadata1">
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata>
  <g
     transform="matrix(0.1,0,0,-0.1,-522.99999,445)"
     fill="#000000"
     stroke="none"
     id="g4">
    <path
       d="m 5230,4442 c 0,-5 157,-327 350,-715 350,-707 350,-707 393,-707 44,0 44,0 287,498 134,273 290,591 347,705 57,115 103,213 103,218 0,5 -65,9 -151,9 -150,0 -150,0 -204,-112 -29,-62 -121,-257 -204,-432 -83,-176 -154,-330 -157,-343 -9,-34 -31,-28 -44,13 -7,20 -95,208 -197,418 -101,209 -192,397 -201,416 -17,35 -17,35 -170,38 -83,1 -152,-1 -152,-6 z"
       id="path1"
       style="fill:#999999" />
    <path
       d="m 6867,4394 c -28,-56 -28,-56 139,-412 92,-197 174,-367 182,-380 8,-12 12,-25 9,-28 -3,-4 -60,-6 -126,-5 -119,2 -119,2 -165,-95 -76,-160 -96,-143 174,-146 232,-3 232,-3 303,-155 72,-153 72,-153 224,-153 84,0 153,3 153,8 0,4 -152,324 -338,712 -337,705 -337,705 -432,708 -96,3 -96,3 -123,-54 z"
       id="path2"
       style="fill:#999999" />
    <path
       d="m 7587,4443 c -4,-3 -7,-156 -7,-338 0,-332 0,-332 138,-611 137,-279 137,-279 140,-156 3,124 3,124 79,198 42,41 79,73 83,72 3,-2 57,-61 120,-133 440,-500 382,-455 577,-455 107,0 173,4 171,10 -3,8 -371,427 -595,677 -83,91 -83,91 120,290 111,109 257,252 325,318 67,65 122,123 122,127 0,4 -76,8 -170,8 -169,0 -169,0 -493,-320 -179,-176 -327,-320 -331,-320 -3,0 -6,144 -6,320 0,320 0,320 -133,320 -74,0 -137,-3 -140,-7 z"
       id="path3"
       style="fill:#999999" />
    <path
       d="m 6706,4048 c -18,-40 -135,-283 -260,-540 -124,-257 -226,-472 -226,-478 0,-7 49,-10 151,-8 150,3 150,3 334,398 102,217 185,403 185,413 0,26 -127,287 -140,287 -6,0 -26,-33 -44,-72 z"
       id="path4"
       style="fill:#999999" />
  </g>
</svg>
</file>

<file path="src/config/domain/read/ReadBoardConfig.ts">
import { ok } from "neverthrow";

import type { ReadBoardName } from "./ReadBoardName";
import type { ReadLocalRule } from "./ReadLocalRule";
import type { Result } from "neverthrow";

export type ReadBoardConfig = {
  readonly _type: "ReadBoardConfig";
  readonly boardName: ReadBoardName;
  readonly localRule: ReadLocalRule;
};

export const createReadBoardConfig = ({
  boardName,
  localRule,
}: {
  boardName: ReadBoardName;
  localRule: ReadLocalRule;
}): Result<ReadBoardConfig, Error> => {
  return ok({
    _type: "ReadBoardConfig",
    boardName,
    localRule,
  });
};
</file>

<file path="src/config/domain/read/ReadBoardName.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadBoardName = {
  readonly _type: "ReadBoardName";
  readonly val: string;
};

export const createReadBoardName = (
  boardName: string
): Result<ReadBoardName, Error> => {
  return ok({
    _type: "ReadBoardName",
    val: boardName,
  });
};
</file>

<file path="src/config/domain/read/ReadDefaultAuthorName.ts">
import { ok, type Result } from "neverthrow";

export type ReadDefaultAuthorName = {
  readonly _type: "ReadDefaultAuthorName";
  readonly val: string;
};

export const createReadDefaultAuthorName = (
  defaultAuthorName: string
): Result<ReadDefaultAuthorName, Error> => {
  return ok({
    _type: "ReadDefaultAuthorName",
    val: defaultAuthorName,
  });
};
</file>

<file path="src/config/domain/read/ReadLocalRule.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadLocalRule = {
  readonly _type: "ReadLocalRule";
  readonly val: string;
};

export const createReadLocalRule = (
  localRule: string
): Result<ReadLocalRule, Error> => {
  return ok({
    _type: "ReadLocalRule",
    val: localRule,
  });
};
</file>

<file path="src/config/domain/read/ReadMaxContentLength.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadMaxContentLength = {
  readonly _type: "ReadMaxContentLength";
  readonly val: number;
};

export const createReadMaxContentLength = (
  maxContentLength: number
): Result<ReadMaxContentLength, Error> => {
  return ok({
    _type: "ReadMaxContentLength",
    val: maxContentLength,
  });
};
</file>

<file path="src/config/domain/read/ReadNormalConfig.ts">
import { ok } from "neverthrow";

import type { ReadBoardName } from "./ReadBoardName";
import type { ReadDefaultAuthorName } from "./ReadDefaultAuthorName";
import type { ReadLocalRule } from "./ReadLocalRule";
import type { ReadMaxContentLength } from "./ReadMaxContentLength";
import type { Result } from "neverthrow";

export type ReadNormalConfig = {
  readonly _type: "ReadNormalConfig";
  readonly boardName: ReadBoardName;
  readonly localRule: ReadLocalRule;
  readonly defaultAuthorName: ReadDefaultAuthorName;
  readonly maxContentLength: ReadMaxContentLength;
};

export const createReadNormalConfig = ({
  boardName,
  localRule,
  defaultAuthorName,
  maxContentLength,
}: {
  boardName: ReadBoardName;
  localRule: ReadLocalRule;
  defaultAuthorName: ReadDefaultAuthorName;
  maxContentLength: ReadMaxContentLength;
}): Result<ReadNormalConfig, Error> => {
  return ok({
    _type: "ReadNormalConfig",
    boardName,
    localRule,
    defaultAuthorName,
    maxContentLength,
  });
};
</file>

<file path="src/config/domain/read/ReadPasswordHash.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadPasswordHash = {
  readonly _type: "ReadPasswordHash";
  readonly val: string;
};

export const createReadPasswordHash = (
  passwordHash: string
): Result<ReadPasswordHash, Error> => {
  return ok({
    _type: "ReadPasswordHash",
    val: passwordHash,
  });
};
</file>

<file path="src/conversation/domain/read/ReadHashId.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadHashId = {
  readonly _type: "ReadHashId";
  readonly val: string;
};

export const createReadHashId = (hashId: string): Result<ReadHashId, Error> => {
  return ok({
    _type: "ReadHashId",
    val: hashId,
  });
};
</file>

<file path="src/conversation/domain/read/ReadMail.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadMail = {
  readonly _type: "ReadMail";
  readonly val: string;
};
export const createReadMail = (mail: string): Result<ReadMail, Error> => {
  return ok({
    _type: "ReadMail",
    val: mail,
  });
};
</file>

<file path="src/conversation/domain/read/ReadPostedAt.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadPostedAt = {
  readonly _type: "ReadPostedAt";
  readonly val: Date;
};

export const createReadPostedAt = (
  postedAt: Date
): Result<ReadPostedAt, Error> => {
  return ok({
    _type: "ReadPostedAt",
    val: postedAt,
  });
};
</file>

<file path="src/conversation/domain/read/ReadResponse.ts">
import { ok } from "neverthrow";

import type { ReadAuthorName } from "./ReadAuthorName";
import type { ReadHashId } from "./ReadHashId";
import type { ReadMail } from "./ReadMail";
import type { ReadPostedAt } from "./ReadPostedAt";
import type { ReadResponseContent } from "./ReadResponseContent";
import type { ReadResponseId } from "./ReadResponseId";
import type { ReadResponseNumber } from "./ReadResponseNumber";
import type { ReadThreadId } from "./ReadThreadId";
import type { Result } from "neverthrow";

export type ReadResponse = {
  readonly _type: "ReadResponse";
  readonly responseId: ReadResponseId;
  readonly threadId: ReadThreadId;
  readonly responseNumber: ReadResponseNumber;
  readonly authorName: ReadAuthorName;
  readonly mail: ReadMail;
  readonly postedAt: ReadPostedAt;
  readonly responseContent: ReadResponseContent;
  readonly hashId: ReadHashId;
};

export const createReadResponse = ({
  responseId,
  threadId,
  responseNumber,
  authorName,
  mail,
  postedAt,
  responseContent,
  hashId,
}: {
  responseId: ReadResponseId;
  threadId: ReadThreadId;
  responseNumber: ReadResponseNumber;
  authorName: ReadAuthorName;
  mail: ReadMail;
  postedAt: ReadPostedAt;
  responseContent: ReadResponseContent;
  hashId: ReadHashId;
}): Result<ReadResponse, Error> => {
  return ok({
    _type: "ReadResponse",
    responseId,
    threadId,
    responseNumber,
    authorName,
    mail,
    postedAt,
    responseContent,
    hashId,
  });
};
</file>

<file path="src/conversation/domain/read/ReadResponseId.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadResponseId = {
  readonly _type: "ReadResponseId";
  readonly val: string;
};

export const createReadResponseId = (
  value: string
): Result<ReadResponseId, Error> => {
  return ok({
    _type: "ReadResponseId",
    val: value,
  });
};
</file>

<file path="src/conversation/domain/read/ReadResponseNumber.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadResponseNumber = {
  readonly _type: "ReadResponseNumber";
  readonly val: number;
};

export const createReadResponseNumber = (
  value: number
): Result<ReadResponseNumber, Error> => {
  return ok({
    _type: "ReadResponseNumber",
    val: value,
  });
};
</file>

<file path="src/conversation/domain/read/ReadThread.ts">
import { ok } from "neverthrow";

import type { ReadPostedAt } from "./ReadPostedAt";
import type { ReadThreadId } from "./ReadThreadId";
import type { ReadThreadTitle } from "./ReadThreadTitle";
import type { Result } from "neverthrow";

export type ReadThread = {
  readonly _type: "ReadThread";
  readonly id: ReadThreadId;
  readonly title: ReadThreadTitle;
  readonly postedAt: ReadPostedAt;
  readonly updatedAt: ReadPostedAt;
  // ここはスレッドのレス数なので妥協
  readonly countResponse: number;
};

export const createReadThread = ({
  id,
  title,
  postedAt,
  updatedAt,
  countResponse,
}: {
  id: ReadThreadId;
  title: ReadThreadTitle;
  postedAt: ReadPostedAt;
  updatedAt: ReadPostedAt;
  countResponse: number;
}): Result<ReadThread, Error> => {
  return ok({
    _type: "ReadThread",
    id,
    title,
    postedAt,
    updatedAt,
    countResponse,
  });
};
</file>

<file path="src/conversation/domain/read/ReadThreadId.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadThreadId = {
  readonly _type: "ReadThreadId";
  readonly val: string;
};

export const createReadThreadId = (
  value: string
): Result<ReadThreadId, Error> => {
  return ok({
    _type: "ReadThreadId",
    val: value,
  });
};
</file>

<file path="src/conversation/domain/read/ReadThreadTitle.ts">
import { ok } from "neverthrow";

import type { Result } from "neverthrow";

export type ReadThreadTitle = {
  readonly _type: "ReadThreadTitle";
  readonly val: string;
};

export const createReadThreadTitle = (
  value: string
): Result<ReadThreadTitle, Error> => {
  return ok({
    _type: "ReadThreadTitle",
    val: value,
  });
};
</file>

<file path="src/conversation/domain/read/ReadThreadWithEpochId.ts">
import { ok } from "neverthrow";

import type { ReadPostedAt } from "./ReadPostedAt";
import type { ReadThreadEpochId } from "./ReadThreadEpochId";
import type { ReadThreadId } from "./ReadThreadId";
import type { ReadThreadTitle } from "./ReadThreadTitle";
import type { Result } from "neverthrow";

export type ReadThreadWithEpochId = {
  readonly _type: "ReadThreadWithEpochId";
  readonly id: ReadThreadId;
  readonly title: ReadThreadTitle;
  readonly postedAt: ReadPostedAt;
  readonly updatedAt: ReadPostedAt;
  // ここはスレッドのレス数なので妥協
  readonly countResponse: number;
  readonly threadEpochId: ReadThreadEpochId;
};

export const createReadThreadWithEpochId = ({
  id,
  title,
  postedAt,
  updatedAt,
  countResponse,
  threadEpochId,
}: {
  id: ReadThreadId;
  title: ReadThreadTitle;
  postedAt: ReadPostedAt;
  updatedAt: ReadPostedAt;
  countResponse: number;
  threadEpochId: ReadThreadEpochId;
}): Result<ReadThreadWithEpochId, Error> => {
  return ok({
    _type: "ReadThreadWithEpochId",
    id,
    title,
    postedAt,
    updatedAt,
    countResponse,
    threadEpochId,
  });
};
</file>

<file path="src/conversation/domain/read/ReadThreadWithResponses.ts">
import { ok } from "neverthrow";

import type { ReadResponse } from "./ReadResponse";
import type { ReadThreadId } from "./ReadThreadId";
import type { ReadThreadTitle } from "./ReadThreadTitle";
import type { Result } from "neverthrow";

export type ReadThreadWithResponses = {
  _type: "ReadThreadWithResponses";
  thread: { threadId: ReadThreadId; threadTitle: ReadThreadTitle };
  responses: ReadResponse[];
};

export const createReadThreadWithResponses = (
  threadId: ReadThreadId,
  threadTitle: ReadThreadTitle,
  responses: ReadResponse[]
): Result<ReadThreadWithResponses, never> => {
  return ok({
    _type: "ReadThreadWithResponses",
    thread: { threadId, threadTitle },
    responses,
  });
};
</file>

<file path="src/conversation/domain/write/WriteResponse.ts">
import { err, ok } from "neverthrow";

import { generateResponseId } from "./WriteResponseId";
import { createWriteThreadId, type WriteThreadId } from "./WriteThreadId";

import type { WriteAuthorName } from "./WriteAuthorName";
import type { WriteHashId } from "./WriteHashId";
import type { WriteMail } from "./WriteMail";
import type { WritePostedAt } from "./WritePostedAt";
import type { WriteResponseContent } from "./WriteResponseContent";
import type { WriteResponseId } from "./WriteResponseId";
import type { Result } from "neverthrow";

export type WriteResponse = {
  readonly _type: "WriteResponse";
  readonly id: WriteResponseId;
  readonly authorName: WriteAuthorName;
  readonly mail: WriteMail;
  readonly postedAt: WritePostedAt;
  readonly responseContent: WriteResponseContent;
  readonly hashId: WriteHashId;
  readonly threadId: WriteThreadId;
};

export const createWriteResponse = async ({
  authorName,
  mail,
  responseContent,
  hashId,
  postedAt,
  getThreadId,
}: {
  authorName: WriteAuthorName;
  mail: WriteMail;
  responseContent: WriteResponseContent;
  hashId: WriteHashId;
  postedAt: WritePostedAt;
  getThreadId: () => Promise<Result<string, Error>>;
}): Promise<Result<WriteResponse, Error>> => {
  // スレッドのIDを取得
  const getThreadIdResult = await getThreadId();
  if (getThreadIdResult.isErr()) {
    return err(getThreadIdResult.error);
  }

  // 詰め替えが必要
  const createThreadIdResult = createWriteThreadId(getThreadIdResult.value);
  if (createThreadIdResult.isErr()) {
    return err(createThreadIdResult.error);
  }

  const id = generateResponseId();
  return ok({
    _type: "WriteResponse",
    id,
    authorName,
    threadId: createThreadIdResult.value,
    mail,
    postedAt,
    responseContent,
    hashId,
  });
};
</file>

<file path="src/conversation/domain/write/WriteThread.ts">
import { err, ok } from "neverthrow";

import { generateWriteThreadEpochId } from "./WriteThreadEpochId";
import { generateWriteThreadId } from "./WriteThreadId";

import type { WritePostedAt } from "./WritePostedAt";
import type { WriteThreadEpochId } from "./WriteThreadEpochId";
import type { WriteThreadId } from "./WriteThreadId";
import type { WriteThreadTitle } from "./WriteThreadTitle";
import type { Result } from "neverthrow";

export type WriteThread = {
  readonly _type: "WriteThread";
  readonly id: WriteThreadId;
  readonly title: WriteThreadTitle;
  readonly postedAt: WritePostedAt;
  readonly epochId: WriteThreadEpochId;
  // 返信時、updatedAtも更新される
  // このときの動作は専用のリポジトリを実装してしまうことにする
  // (少しお行儀が悪いかも)
  readonly updatedAt: WritePostedAt;
};

// スレッドのファクトリ関数
// 外部からpostedAtを受け取るように変更。レスの方と一貫性を取るため。ユースケースで生成する
export const createWriteThread = ({
  title,
  postedAt,
}: {
  title: WriteThreadTitle;
  postedAt: WritePostedAt;
}): Result<WriteThread, Error> => {
  const id = generateWriteThreadId();

  const threadEpochIdResult = generateWriteThreadEpochId(postedAt);
  if (threadEpochIdResult.isErr()) {
    return err(threadEpochIdResult.error);
  }
  // 同じ値を利用
  const updatedAt = postedAt;

  return ok({
    _type: "WriteThread",
    id,
    title,
    postedAt,
    updatedAt,
    epochId: threadEpochIdResult.value,
  });
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_POSTGRES_USER: string;
  readonly VITE_POSTGRES_PASSWORD: string;
  readonly VITE_POSTGRES_DB: string;
  readonly VITE_JWT_SECRET_KEY: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "lib": ["ESNext", "DOM"],
    "types": ["@cloudflare/workers-types"],
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx",
    "skipLibCheck": true
  },
  "include": ["src/**/*", "app/**/*", "eslint.config.ts", "vite.config.ts"]
}
</file>

<file path="wrangler.jsonc">
{
  "$schema": "node_modules/wrangler/config-schema.json",
  "name": "vakkarma-main",
  "main": "./dist/index.js",
  "compatibility_date": "2025-03-21",
  "compatibility_flags": ["nodejs_compat"],
  "assets": {
    "directory": "./dist"
  },
  "observability": {
    "enabled": true
  }
}
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches:
      - main
  pull_request:
    types:
      - opened
      - synchronize
  workflow_dispatch: null

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true # PRの場合、最新のコミットのみを実行する方が効率的 (mainへのpushではfalseが良い場合も)

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Node.jsとpnpmのセットアップを削除し、Bunの公式セットアップアクションを使用
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        # with:
        #   bun-version: latest # 特定のバージョンが必要な場合は指定 (例: '1.1.8')
        # oven-sh/setup-bun は自動でBunのキャッシュを設定します

      - name: Install dependencies
        run: bun install

      - name: Typecheck
        run: bun run typecheck

      - name: Lint
        run: bun run lint

      - name: Test
        run: bun test

      - name: Build Bun
        run: bun run build:bun

      - name: Build Workers
        run: bun run build:workers
</file>

<file path="app/middlewares/csrfMiddleware.ts">
/**
 * @module
 * CSRF Protection Middleware for Hono.
 */

import { HTTPException } from "hono/http-exception";

// import type { Context } from "../../context";
// import type { MiddlewareHandler } from "../../types";

import type { MiddlewareHandler, Context } from "hono";

type IsAllowedOriginHandler = (origin: string, context: Context) => boolean;
interface CSRFOptions {
  origin?: string | string[] | IsAllowedOriginHandler;
}

const isSafeMethodRe = /^(GET|HEAD)$/;
const isRequestedByFormElementRe =
  /^\b(application\/x-www-form-urlencoded|multipart\/form-data|text\/plain)\b/i;

/**
 * CSRF Protection Middleware for Hono.
 *
 * @see {@link https://hono.dev/docs/middleware/builtin/csrf}
 *
 * @param {CSRFOptions} [options] - The options for the CSRF protection middleware.
 * @param {string|string[]|(origin: string, context: Context) => boolean} [options.origin] - Specify origins.
 * @returns {MiddlewareHandler} The middleware handler function.
 *
 * @example
 * ```ts
 * const app = new Hono()
 *
 * app.use(csrf())
 *
 * // Specifying origins with using `origin` option
 * // string
 * app.use(csrf({ origin: 'myapp.example.com' }))
 *
 * // string[]
 * app.use(
 *   csrf({
 *     origin: ['myapp.example.com', 'development.myapp.example.com'],
 *   })
 * )
 *
 * // Function
 * // It is strongly recommended that the protocol be verified to ensure a match to `$`.
 * // You should *never* do a forward match.
 * app.use(
 *   '*',
 *   csrf({
 *     origin: (origin) => /https:\/\/(\w+\.)?myapp\.example\.com$/.test(origin),
 *   })
 * )
 * ```
 */
export const csrf = (options?: CSRFOptions): MiddlewareHandler => {
  const handler: IsAllowedOriginHandler = ((optsOrigin) => {
    if (!optsOrigin) {
      return (origin, c) => origin === new URL(c.req.url).origin;
    } else if (typeof optsOrigin === "string") {
      return (origin) => origin === optsOrigin;
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin);
    }
  })(options?.origin);
  const isAllowedOrigin = (origin: string | undefined, c: Context) => {
    if (origin === undefined) {
      // Chmate等専用ブラウザからのリクエストはoriginが空になるので
      // User-Agentに"2chMate"が含まれている場合は許可する
      if (c.req.header("user-agent")?.includes("2chMate")) {
        return true;
      }
      return false;
    }
    return handler(origin, c);
  };

  return async function csrf(c, next) {
    if (
      !isSafeMethodRe.test(c.req.method) &&
      isRequestedByFormElementRe.test(
        c.req.header("content-type") || "text/plain"
      ) &&
      !isAllowedOrigin(c.req.header("origin"), c)
    ) {
      const res = new Response("Forbidden", {
        status: 403,
      });
      throw new HTTPException(403, { res });
    }

    await next();
  };
};
</file>

<file path="app/middlewares/jwtCookieMiddleware.tsx">
import { env } from "hono/adapter";
import { getCookie } from "hono/cookie";
import { createMiddleware } from "hono/factory";
import { verify } from "hono/jwt";

import { ErrorMessage } from "../components/ErrorMessage";

export const jwtAuthMiddleware = () => {
  return createMiddleware(async (c, next) => {
    const secret =
      env<{ JWT_SECRET_KEY: string | undefined }>(c).JWT_SECRET_KEY ||
      import.meta.env.VITE_JWT_SECRET_KEY;

    if (!secret) {
      return c.render(
        <ErrorMessage
          error={new Error("JWT_SECRET_KEYが設定されていません。")}
        />
      );
    }

    const token = getCookie(c, "jwt");

    if (!token) {
      return c.redirect("/login/admin", 302);
    }

    try {
      await verify(token, secret); // JWTを検証
      // payload を context に保存するなど、後続の処理で利用できるようにする
      // 必要ないのでコメントアウト
      // c.set("jwtPayload", payload);
      await next();
    } catch {
      return c.redirect("/login/admin", 302);
    }
  });
};
</file>

<file path="app/routes/admin/_middleware.tsx">
import { createRoute } from "honox/factory";

import { jwtAuthMiddleware } from "../../middlewares/jwtCookieMiddleware";

export default createRoute(jwtAuthMiddleware());
</file>

<file path="app/routes/subback.html.tsx">
import { createRoute } from "honox/factory";

import { getAllThreadsPageUsecase } from "../../src/conversation/usecases/getAllThreadsPageUsecase";
import { ErrorMessage } from "../components/ErrorMessage";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "subback/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Rendering thread list page",
  });

  logger.debug({
    operation: "subback/GET",
    message: "Calling getAllThreadsPageUsecase to retrieve all threads",
  });

  const usecaseResult = await getAllThreadsPageUsecase({
    sql,
    logger,
  });

  if (usecaseResult.isErr()) {
    logger.error({
      operation: "subback/GET",
      error: usecaseResult.error,
      message: "Failed to retrieve all threads",
    });
    return c.render(<ErrorMessage error={usecaseResult.error} />);
  }

  const threads = usecaseResult.value;

  logger.debug({
    operation: "subback/GET",
    threadCount: threads.length,
    message: "Successfully retrieved all threads, rendering page",
  });

  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6 mb-8">
        <h1 className="text-2xl font-bold mb-4">スレッド一覧</h1>

        <p className="mb-4">全部で{threads.length}のスレッドがあります</p>

        <ul className="flex flex-col gap-2">
          {threads.map((thread, index) => (
            <li key={thread.id.val}>
              <a
                className="text-purple-600 hover:underline"
                href={`/threads/${thread.id.val}/l50`}
              >
                {index + 1}: {thread.title.val} ({thread.countResponse})
              </a>
            </li>
          ))}
        </ul>

        <div className="mt-6">
          <a href="/" className="text-blue-600 hover:underline">
            掲示板に戻る
          </a>
        </div>
      </section>
    </main>
  );
});
</file>

<file path="app/utils/getConnInfoRuntimeSwitch.ts">
import { getConnInfo as getConnInfoOnNode } from "@hono/node-server/conninfo";
import { getRuntimeKey } from "hono/adapter";
import { getConnInfo as getConnInfoOnWorkers } from "hono/cloudflare-workers";
import { err, ok } from "neverthrow";

import { IpAddressNotFoundError } from "../../src/shared/types/Error";

import type { Context } from "hono";
import type { GetConnInfo } from "hono/conninfo";
import type { Result } from "neverthrow";

export const getConnInfowithRuntimeSwitch = (
  c: Context
): (() => Result<string, Error>) => {
  const runtime = getRuntimeKey();
  switch (runtime) {
    case "workerd":
      return (): Result<string, Error> => {
        try {
          const connInfo = getConnInfoOnWorkers(c);
          if (!connInfo || !connInfo.remote || !connInfo.remote.address) {
            return err(new IpAddressNotFoundError("IP address not found"));
          }
          return ok(connInfo.remote.address);
        } catch (e) {
          const message = e instanceof Error ? e.message : "Unknown error";
          return err(new IpAddressNotFoundError(message));
        }
      };
    case "bun":
      return (): Result<string, Error> => {
        try {
          const connInfo = getConnInfoOnBun(c);
          if (!connInfo || !connInfo.remote || !connInfo.remote.address) {
            return err(new IpAddressNotFoundError("IP address not found"));
          }
          return ok(connInfo.remote.address);
        } catch (e) {
          const message = e instanceof Error ? e.message : "Unknown error";
          return err(new IpAddressNotFoundError(message));
        }
      };
    case "node":
      return (): Result<string, Error> => {
        try {
          const connInfo = getConnInfoOnNode(c);
          if (!connInfo || !connInfo.remote || !connInfo.remote.address) {
            return err(new IpAddressNotFoundError("IP address not found"));
          }
          return ok(connInfo.remote.address);
        } catch (e) {
          const message = e instanceof Error ? e.message : "Unknown error";
          return err(new IpAddressNotFoundError(message));
        }
      };
    case "deno":
      return (): Result<string, Error> => {
        try {
          const connInfo = getConnInfoDeno(c);
          if (!connInfo || !connInfo.remote || !connInfo.remote.address) {
            return err(new IpAddressNotFoundError("IP address not found"));
          }
          return ok(connInfo.remote.address);
        } catch (e) {
          const message = e instanceof Error ? e.message : "Unknown error";
          return err(new IpAddressNotFoundError(message));
        }
      };
    default:
      // 例外なのでthrowでよい
      throw new Error(`Unknown runtime: ${runtime}`);
  }
};

/**
 * Get conninfo with Deno
 * @param c Context
 * @returns ConnInfo
 */
export const getConnInfoDeno: GetConnInfo = (c) => {
  const { remoteAddr } = c.env;
  return {
    remote: {
      address: remoteAddr.hostname,
      port: remoteAddr.port,
      transport: remoteAddr.transport,
    },
  };
};

export interface BunServer {
  requestIP?: (req: Request) => {
    address: string;
    family: string;
    port: number;
  };
  upgrade<T>(
    req: Request,
    options?: {
      data: T;
    }
  ): boolean;
}

/**
 * そのままimportすると動作しなかったのでコピペ
 * Get Bun Server Object from Context
 * @param c Context
 * @returns Bun Server
 */
export const getBunServer = (c: Context): BunServer | undefined =>
  ("server" in c.env ? c.env.server : c.env) as BunServer | undefined;

export const getConnInfoOnBun: GetConnInfo = (c: Context) => {
  const server = getBunServer(c);

  if (!server) {
    throw new TypeError("env has to include the 2nd argument of fetch.");
  }
  if (typeof server.requestIP !== "function") {
    throw new TypeError("server.requestIP is not a function.");
  }
  const info = server.requestIP(c.req.raw);

  return {
    remote: {
      address: info.address,
      addressType:
        info.family === "IPv6" || info.family === "IPv4"
          ? info.family
          : undefined,
      port: info.port,
    },
  };
};
</file>

<file path="src/config/domain/write/WriteDefaultAuthorName.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteDefaultAuthorName } from "./WriteDefaultAuthorName";

describe("WriteDefaultAuthorName", () => {
  it("正常な値で作成できること", () => {
    const result = createWriteDefaultAuthorName("名無しさん");
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteDefaultAuthorName");
      expect(result.value.val).toBe("名無しさん");
    }
  });

  it("空文字列の場合はエラーになること", () => {
    const result = createWriteDefaultAuthorName("");
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "デフォルトのユーザ名を入力してください"
      );
    }
  });

  it("20文字を超える場合はエラーになること", () => {
    const result = createWriteDefaultAuthorName(
      "あいうえおかきくけこさしすせそたちつてとな"
    ); // 21文字
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "デフォルトのユーザ名は20文字以内で入力してください"
      );
    }
  });

  it("ちょうど20文字の場合は作成できること", () => {
    const result = createWriteDefaultAuthorName(
      "あいうえおかきくけこさしすせそたちつてと"
    ); // 20文字
    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/config/domain/write/WriteDefaultAuthorName.ts">
import { ok, err } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { Result } from "neverthrow";

export type WriteDefaultAuthorName = {
  readonly _type: "WriteDefaultAuthorName";
  readonly val: string;
};

export const createWriteDefaultAuthorName = (
  value: string
): Result<WriteDefaultAuthorName, ValidationError> => {
  if (value.length === 0) {
    return err(new ValidationError("デフォルトのユーザ名を入力してください"));
  }

  if (value.length > 20) {
    return err(
      new ValidationError("デフォルトのユーザ名は20文字以内で入力してください")
    );
  }
  return ok({ _type: "WriteDefaultAuthorName", val: value });
};
</file>

<file path="src/config/domain/write/WriteLocalRule.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteLocalRule } from "./WriteLocalRule";

describe("WriteLocalRule", () => {
  it("正常な値で作成できること", () => {
    const result = createWriteLocalRule(
      "このボードではマナーを守って投稿してください"
    );
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteLocalRule");
      expect(result.value.val).toBe(
        "このボードではマナーを守って投稿してください"
      );
    }
  });

  it("空文字列の場合はエラーになること", () => {
    const result = createWriteLocalRule("");
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("ローカルルールを入力してください");
    }
  });

  it("100文字を超える場合はエラーになること", () => {
    const longText = "あ".repeat(101); // 101文字
    const result = createWriteLocalRule(longText);
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "ローカルルールは100文字以内で入力してください"
      );
    }
  });

  it("ちょうど100文字の場合は作成できること", () => {
    const text100 = "あ".repeat(100); // 100文字
    const result = createWriteLocalRule(text100);
    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/config/domain/write/WriteLocalRule.ts">
import { err, ok } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { Result } from "neverthrow";

export type WriteLocalRule = {
  readonly _type: "WriteLocalRule";
  readonly val: string;
};

export const createWriteLocalRule = (
  value: string
): Result<WriteLocalRule, ValidationError> => {
  if (value.length === 0) {
    return err(new ValidationError("ローカルルールを入力してください"));
  }

  if (value.length > 100) {
    return err(
      new ValidationError("ローカルルールは100文字以内で入力してください")
    );
  }
  return ok({ _type: "WriteLocalRule", val: value });
};
</file>

<file path="src/config/domain/write/WriteMaxContentLength.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteMaxContentLength } from "./WriteMaxContentLength";

describe("WriteMaxContentLength", () => {
  it("正常な値で作成できること", () => {
    const result = createWriteMaxContentLength(1000);
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMaxContentLength");
      expect(result.value.val).toBe(1000);
    }
  });

  it("0以下の値の場合はエラーになること", () => {
    const result = createWriteMaxContentLength(0);
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "コンテンツの最大長は0より大きい必要があります"
      );
    }
  });

  it("負の値の場合はエラーになること", () => {
    const result = createWriteMaxContentLength(-10);
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "コンテンツの最大長は0より大きい必要があります"
      );
    }
  });

  it("1の場合は作成できること", () => {
    const result = createWriteMaxContentLength(1);
    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/config/domain/write/WriteMaxContentLength.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

export type WriteMaxContentLength = {
  readonly _type: "WriteMaxContentLength";
  readonly val: number;
};

export const createWriteMaxContentLength = (
  value: number
): Result<WriteMaxContentLength, ValidationError> => {
  if (value <= 0) {
    return err(
      new ValidationError("コンテンツの最大長は0より大きい必要があります")
    );
  }
  return ok({ _type: "WriteMaxContentLength", val: value });
};
</file>

<file path="src/config/domain/write/WriteNormalConfig.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteBoardName } from "./WriteBoardName";
import { createWriteDefaultAuthorName } from "./WriteDefaultAuthorName";
import { createWriteLocalRule } from "./WriteLocalRule";
import { createWriteMaxContentLength } from "./WriteMaxContentLength";
import { createWriteNormalConfig } from "./WriteNormalConfig";

describe("WriteNormalConfig", () => {
  it("正常な値で作成できること", () => {
    const boardNameResult = createWriteBoardName("テスト掲示板");
    const localRuleResult = createWriteLocalRule("テストのルールです");
    const defaultAuthorNameResult = createWriteDefaultAuthorName("名無しさん");
    const maxContentLengthResult = createWriteMaxContentLength(1000);

    // すべての値が正常に作成されていることを確認
    expect(boardNameResult.isOk()).toBe(true);
    expect(localRuleResult.isOk()).toBe(true);
    expect(defaultAuthorNameResult.isOk()).toBe(true);
    expect(maxContentLengthResult.isOk()).toBe(true);

    if (
      boardNameResult.isOk() &&
      localRuleResult.isOk() &&
      defaultAuthorNameResult.isOk() &&
      maxContentLengthResult.isOk()
    ) {
      const result = createWriteNormalConfig({
        boardName: boardNameResult.value,
        localRule: localRuleResult.value,
        defaultAuthorName: defaultAuthorNameResult.value,
        maxContentLength: maxContentLengthResult.value,
      });

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteNormalConfig");
        expect(result.value.boardName).toBe(boardNameResult.value);
        expect(result.value.localRule).toBe(localRuleResult.value);
        expect(result.value.defaultAuthorName).toBe(
          defaultAuthorNameResult.value
        );
        expect(result.value.maxContentLength).toBe(
          maxContentLengthResult.value
        );
      }
    }
  });
});
</file>

<file path="src/config/domain/write/WriteNormalConfig.ts">
import { ok } from "neverthrow";

import type { WriteBoardName } from "./WriteBoardName";
import type { WriteDefaultAuthorName } from "./WriteDefaultAuthorName";
import type { WriteLocalRule } from "./WriteLocalRule";
import type { WriteMaxContentLength } from "./WriteMaxContentLength";
import type { ValidationError } from "../../../shared/types/Error";
import type { Result } from "neverthrow";

export type WriteNormalConfig = {
  readonly _type: "WriteNormalConfig";
  readonly boardName: WriteBoardName;
  readonly localRule: WriteLocalRule;
  readonly defaultAuthorName: WriteDefaultAuthorName;
  readonly maxContentLength: WriteMaxContentLength;
};
export const createWriteNormalConfig = ({
  boardName,
  localRule,
  defaultAuthorName,
  maxContentLength,
}: {
  boardName: WriteBoardName;
  localRule: WriteLocalRule;
  defaultAuthorName: WriteDefaultAuthorName;
  maxContentLength: WriteMaxContentLength;
}): Result<WriteNormalConfig, ValidationError> => {
  return ok({
    _type: "WriteNormalConfig",
    boardName,
    localRule,
    defaultAuthorName,
    maxContentLength,
  });
};
</file>

<file path="src/config/domain/write/WritePassword.test.ts">
import { describe, it, expect } from "vitest";

import { createWritePassword } from "./WritePassword";

describe("WritePassword", () => {
  it("正常な値で作成できること", async () => {
    const result = await createWritePassword("password123");
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WritePassword");
      expect(result.value.val).toBe("password123");
    }
  });

  it("空文字列の場合はエラーになること", async () => {
    const result = await createWritePassword("");
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("パスワードを入力してください");
    }
  });
});
</file>

<file path="src/config/domain/write/WritePassword.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

// パスワード
export type WritePassword = {
  readonly _type: "WritePassword";
  readonly val: string;
};

// Minimum 8 characters, one uppercase, one lowercase, one digit, one special character.
// const passwordRegex =
//   /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]).{8,}$/;

export const createWritePassword = async (
  value: string
  //   getIsPasswordStrength: () => Promise<Result<boolean, Error>>
): Promise<Result<WritePassword, ValidationError>> => {
  if (value.length === 0) {
    return err(new ValidationError("パスワードを入力してください"));
  }

  //   const isPasswordStrengthResult = await getIsPasswordStrength();
  //   if (isPasswordStrengthResult.isErr()) {
  //     return err(isPasswordStrengthResult.error);
  //   }

  //   if (!isPasswordStrengthResult.value || !passwordRegex.test(value)) {
  //     return err(new ValidationError("パスワードの強度が不足しています"));
  //   }
  return ok({ _type: "WritePassword", val: value });
};
</file>

<file path="src/config/domain/write/WritePasswordHash.test.ts">
import { describe, it, expect } from "vitest";

import { generateWritePasswordHash } from "./WritePasswordHash";

// WritePasswordのモック作成
const createMockWritePassword = (value: string) => {
  return { _type: "WritePassword" as const, val: value };
};

describe("WritePasswordHash", () => {
  it("パスワードが正常にハッシュ化されること", async () => {
    const password = createMockWritePassword("test123");
    const result = await generateWritePasswordHash(password);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WritePasswordHash");
      expect(result.value.val).toBeTruthy();
      // ハッシュ化されたパスワードは元のパスワードと異なるはずです
      expect(result.value.val).not.toBe(password.val);
      // bcryptのハッシュは通常$で始まります
      expect(result.value.val.startsWith("$")).toBe(true);
    }
  });

  it("空のパスワードでもハッシュ化できること", async () => {
    const password = createMockWritePassword("");
    const result = await generateWritePasswordHash(password);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WritePasswordHash");
      expect(result.value.val).toBeTruthy();
    }
  });
});
</file>

<file path="src/config/domain/write/WritePasswordHash.ts">
import { hash } from "bcrypt-ts";
import { ok, err } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { WritePassword } from "./WritePassword";
import type { Result } from "neverthrow";

export type WritePasswordHash = {
  readonly _type: "WritePasswordHash";
  readonly val: string;
};

export const generateWritePasswordHash = async (
  password: WritePassword
): Promise<Result<WritePasswordHash, ValidationError>> => {
  try {
    const hashedPassword = await hash(password.val, 10);
    return ok({ _type: "WritePasswordHash", val: hashedPassword });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return err(
      new ValidationError(`パスワードのハッシュ化に失敗しました: ${message}`)
    );
  }
};
</file>

<file path="src/config/usecases/getNormalConfigUsecase.ts">
import { err, ok } from "neverthrow";

import { getNormalConfigRepository } from "../repositories/getNormalConfigRepository";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadNormalConfig } from "../domain/read/ReadNormalConfig";
import type { Result } from "neverthrow";

export const getNormalConfigUsecase = async (
  vakContext: VakContext
): Promise<Result<ReadNormalConfig, Error>> => {
  const { logger } = vakContext;

  logger.info({
    operation: "getConfig",
    message: "Starting configuration retrieval",
  });

  logger.debug({
    operation: "getConfig",
    message: "Fetching configuration from repository",
  });

  const config = await getNormalConfigRepository(vakContext);
  if (config.isErr()) {
    logger.error({
      operation: "getConfig",
      error: config.error,
      message: "Failed to fetch configuration",
    });
    return err(config.error);
  }

  logger.info({
    operation: "getConfig",
    boardName: config.value.boardName.val,
    message: "Configuration retrieved successfully",
  });

  return ok(config.value);
};
</file>

<file path="src/config/usecases/updateNormalConfigUsecase.ts">
import { err, ok } from "neverthrow";
import { Result } from "neverthrow";

import { createWriteBoardName } from "../domain/write/WriteBoardName";
import { createWriteDefaultAuthorName } from "../domain/write/WriteDefaultAuthorName";
import { createWriteLocalRule } from "../domain/write/WriteLocalRule";
import { createWriteMaxContentLength } from "../domain/write/WriteMaxContentLength";
import { createWriteNormalConfig } from "../domain/write/WriteNormalConfig";
import { updateNormalConfigRepository } from "../repositories/updateNormalConfigRepository";

import type { VakContext } from "../../shared/types/VakContext";

export const updateNormalConfigUsecase = async (
  vakContext: VakContext,
  {
    boardNameRaw,
    localRuleRaw,
    defaultAuthorNameRaw,
    maxContentLengthRaw,
  }: {
    boardNameRaw: string;
    localRuleRaw: string;
    defaultAuthorNameRaw: string;
    maxContentLengthRaw: number;
  }
): Promise<Result<undefined, Error>> => {
  const { logger } = vakContext;

  logger.info({
    operation: "updateConfig",
    boardName: boardNameRaw,
    defaultAuthorName: defaultAuthorNameRaw,
    maxContentLength: maxContentLengthRaw,
    message: "Starting configuration update",
  });

  logger.debug({
    operation: "updateConfig",
    message: "Validating configuration values",
  });

  const combinedResult = Result.combine([
    createWriteBoardName(boardNameRaw),
    createWriteLocalRule(localRuleRaw),
    createWriteDefaultAuthorName(defaultAuthorNameRaw),
    createWriteMaxContentLength(maxContentLengthRaw),
  ]);

  if (combinedResult.isErr()) {
    logger.error({
      operation: "updateConfig",
      error: combinedResult.error,
      message: "Configuration validation failed",
    });
    return err(combinedResult.error);
  }

  const [boardName, localRule, defaultAuthorName, maxContentLength] =
    combinedResult.value;

  logger.debug({
    operation: "updateConfig",
    message: "Creating configuration object",
  });

  // 今回は値オブジェクトはないので、そのまま
  const config = await createWriteNormalConfig({
    boardName,
    localRule,
    defaultAuthorName,
    maxContentLength,
  });

  if (config.isErr()) {
    logger.error({
      operation: "updateConfig",
      error: config.error,
      message: "Failed to create configuration object",
    });
    return err(config.error);
  }

  logger.debug({
    operation: "updateConfig",
    message: "Updating configuration in database",
  });

  const result = await updateNormalConfigRepository(vakContext, config.value);
  if (result.isErr()) {
    logger.error({
      operation: "updateConfig",
      error: result.error,
      message: "Failed to update configuration in database",
    });
    return err(result.error);
  }

  logger.info({
    operation: "updateConfig",
    boardName: boardNameRaw,
    defaultAuthorName: defaultAuthorNameRaw,
    message: "Configuration updated successfully",
  });

  return ok(undefined);
};
</file>

<file path="src/conversation/domain/read/ReadAuthorName.ts">
import { ok, type Result } from "neverthrow";

import type { ValidationError } from "../../../shared/types/Error";

type SomeReadAuthorName = {
  readonly _type: "some";
  readonly authorName: string;
  readonly trip: string;
};

type NoneReadAuthorName = {
  readonly _type: "none";
  readonly authorName: string;
};

// 投稿者名
export type ReadAuthorName = {
  readonly _type: "ReadAuthorName";
  // readonly val: string;
  // some/noneパターン
  readonly val: SomeReadAuthorName | NoneReadAuthorName;
};

export const createReadAuthorName = (
  authorName: string,
  trip: string | null
): Result<ReadAuthorName, ValidationError> => {
  if (trip === null || trip === "") {
    return ok({
      _type: "ReadAuthorName",
      val: {
        _type: "none",
        authorName,
      },
    });
  }

  return ok({
    _type: "ReadAuthorName",
    val: {
      _type: "some",
      authorName,
      trip,
    },
  });
};

export const formatReadAuthorName = (authorName: ReadAuthorName): string => {
  if (authorName.val._type === "none") {
    return authorName.val.authorName;
  }

  return `${authorName.val.authorName}◆${authorName.val.trip}`;
};
</file>

<file path="src/conversation/domain/read/ReadResponseContent.ts">
import { ok, type Result } from "neverthrow";

import type { ValidationError } from "../../../shared/types/Error";

// 本文
export type ReadResponseContent = {
  readonly _type: "ReadResponseContent";
  readonly val: string;
};
export const createReadResponseContent = (
  value: string
): Result<ReadResponseContent, ValidationError> => {
  return ok({ _type: "ReadResponseContent", val: value });
};
</file>

<file path="src/conversation/domain/read/ReadThreadEpochId.ts">
import { err, ok } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { Result } from "neverthrow";

export type ReadThreadEpochId = {
  readonly _type: "ReadThreadEpochId";
  readonly val: number;
};

export const createReadThreadEpochId = (
  value: string
): Result<ReadThreadEpochId, Error> => {
  // BIGINTを扱うため、数値に変換
  const epochId = Number(value);
  if (isNaN(epochId)) {
    return err(new ValidationError("ThreadEpochIdは数値である必要があります"));
  }
  return ok({
    _type: "ReadThreadEpochId",
    val: epochId,
  });
};
</file>

<file path="src/conversation/domain/write/WriteAuthorName.test.ts">
import { ok } from "neverthrow";
import { describe, it, expect } from "vitest";

import { createWriteAuthorName } from "./WriteAuthorName";

describe("WriteAuthorName", () => {
  // デフォルトの投稿者名を返すモック関数
  const mockGetDefaultAuthorName = async () => {
    return ok("名無しさん");
  };

  it("通常の投稿者名で作成できること", async () => {
    const result = await createWriteAuthorName(
      "テスト太郎",
      mockGetDefaultAuthorName
    );

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteAuthorName");
      expect(result.value.val._type).toBe("none");
      expect(result.value.val.authorName).toBe("テスト太郎");
    }
  });

  it("投稿者名がnullの場合はデフォルト名が使用されること", async () => {
    const result = await createWriteAuthorName(null, mockGetDefaultAuthorName);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteAuthorName");
      expect(result.value.val._type).toBe("none");
      expect(result.value.val.authorName).toBe("名無しさん");
    }
  });

  it("トリップ付きの名前で作成できること", async () => {
    const result = await createWriteAuthorName(
      "テスト#test123",
      mockGetDefaultAuthorName
    );

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteAuthorName");
      expect(result.value.val._type).toBe("some");
      expect(result.value.val.authorName).toBe("テスト");
      if (result.value.val._type === "some") {
        expect(result.value.val.trip).toBeTruthy(); // トリップが生成されていること
      }
    }
  });

  it("100文字を超える名前はエラーになること", async () => {
    const longName = "あ".repeat(101); // 101文字
    const result = await createWriteAuthorName(
      longName,
      mockGetDefaultAuthorName
    );

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("名前は100文字以内です");
    }
  });

  it("ちょうど100文字の名前で作成できること", async () => {
    const name100 = "あ".repeat(100); // 100文字
    const result = await createWriteAuthorName(
      name100,
      mockGetDefaultAuthorName
    );

    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/conversation/domain/write/WriteHashId.test.ts">
import { describe, it, expect } from "vitest";

import { generateWriteHashId, createWriteHashId } from "./WriteHashId";

describe("WriteHashId", () => {
  describe("generateWriteHashId", () => {
    it("IPアドレスと日付から有効なハッシュIDを生成できること", () => {
      const ipAddress = "192.168.1.1";
      const date = new Date("2025-04-07");
      const result = generateWriteHashId(ipAddress, date);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteHashId");
        expect(result.value.val.length).toBe(8); // ハッシュIDは8文字
      }
    });

    it("同じIPと日付からは同じハッシュIDが生成されること", () => {
      const ipAddress = "192.168.1.1";
      const date = new Date("2025-04-07");

      const result1 = generateWriteHashId(ipAddress, date);
      const result2 = generateWriteHashId(ipAddress, date);

      expect(result1.isOk() && result2.isOk()).toBe(true);
      if (result1.isOk() && result2.isOk()) {
        expect(result1.value.val).toBe(result2.value.val);
      }
    });

    it("異なるIPからは異なるハッシュIDが生成されること", () => {
      const date = new Date("2025-04-07");

      const result1 = generateWriteHashId("192.168.1.1", date);
      const result2 = generateWriteHashId("192.168.1.2", date);

      expect(result1.isOk() && result2.isOk()).toBe(true);
      if (result1.isOk() && result2.isOk()) {
        expect(result1.value.val).not.toBe(result2.value.val);
      }
    });

    it("異なる日付からは異なるハッシュIDが生成されること", () => {
      const ipAddress = "192.168.1.1";

      const result1 = generateWriteHashId(ipAddress, new Date("2025-04-07"));
      const result2 = generateWriteHashId(ipAddress, new Date("2025-04-08"));

      expect(result1.isOk() && result2.isOk()).toBe(true);
      if (result1.isOk() && result2.isOk()) {
        expect(result1.value.val).not.toBe(result2.value.val);
      }
    });
  });

  describe("createWriteHashId", () => {
    it("8文字の文字列から有効なハッシュIDを作成できること", () => {
      const result = createWriteHashId("12345678");

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteHashId");
        expect(result.value.val).toBe("12345678");
      }
    });

    it("8文字未満の文字列ではエラーになること", () => {
      const result = createWriteHashId("1234567");

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe("ハッシュIDは8文字です");
      }
    });

    it("8文字を超える文字列ではエラーになること", () => {
      const result = createWriteHashId("123456789");

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe("ハッシュIDは8文字です");
      }
    });
  });
});
</file>

<file path="src/conversation/domain/write/WriteHashId.ts">
import crypto from "crypto";

import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

// ハッシュID
export type WriteHashId = {
  readonly _type: "WriteHashId";
  readonly val: string;
};

// ipAddressが文字列なのは妥協
export const generateWriteHashId = (
  // そんなに必要な値という訳ではないので値オブジェクトを使わずにstringで
  ipAddress: string,
  date: Date
): Result<WriteHashId, ValidationError> => {
  try {
    const hash = crypto
      .createHash("md5")
      .update(ipAddress)
      .update(date.toDateString())
      .digest("base64");
    return ok({ _type: "WriteHashId", val: hash.substring(0, 8) });
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : "Unknown error";
    return err(
      new ValidationError(`ハッシュIDの生成に失敗しました: ${message}`)
    );
  }
};

export const createWriteHashId = (
  value: string
): Result<WriteHashId, ValidationError> => {
  if (value.length !== 8) {
    return err(new ValidationError("ハッシュIDは8文字です"));
  }
  return ok({ _type: "WriteHashId", val: value });
};
</file>

<file path="src/conversation/domain/write/WritePostedAt.test.ts">
import { describe, it, expect } from "vitest";

import { createWritePostedAt, generateCurrentPostedAt } from "./WritePostedAt";

describe("WritePostedAt", () => {
  it("指定した日時で作成できること", () => {
    const testDate = new Date("2025-04-07T12:00:00Z");
    const result = createWritePostedAt(testDate);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WritePostedAt");
      expect(result.value.val).toEqual(testDate);
    }
  });

  it("generateCurrentPostedAtで現在時刻の値オブジェクトを生成できること", () => {
    const before = new Date();
    const postedAt = generateCurrentPostedAt();
    const after = new Date();

    expect(postedAt._type).toBe("WritePostedAt");

    // 現在時刻で生成されたことを確認（生成時刻の前後に位置する）
    expect(postedAt.val.getTime()).toBeGreaterThanOrEqual(before.getTime());
    expect(postedAt.val.getTime()).toBeLessThanOrEqual(after.getTime());
  });
});
</file>

<file path="src/conversation/domain/write/WritePostedAt.ts">
import { ok, type Result } from "neverthrow";

import type { ValidationError } from "../../../shared/types/Error";

// 投稿日時
export type WritePostedAt = {
  readonly _type: "WritePostedAt";
  readonly val: Date;
};

export const createWritePostedAt = (
  value: Date
): Result<WritePostedAt, ValidationError> => {
  return ok({ _type: "WritePostedAt", val: value });
};

// 現在の日時で初期化する場合
// エラーは出ないものと推測
export const generateCurrentPostedAt = (): WritePostedAt => {
  return createWritePostedAt(new Date())._unsafeUnwrap();
};
</file>

<file path="src/conversation/domain/write/WriteResponse.test.ts">
import { err, ok } from "neverthrow";
import { describe, it, expect } from "vitest";

import { createWriteResponse } from "./WriteResponse";

describe("WriteResponse", () => {
  it("正常なパラメータでレスポンスを作成できること", async () => {
    // 必要な値オブジェクトのモック
    const mockAuthorName = {
      _type: "WriteAuthorName" as const,
      val: { _type: "none" as const, authorName: "テスト太郎" },
    };
    const mockMail = { _type: "WriteMail" as const, val: "test@example.com" };
    const mockResponseContent = {
      _type: "WriteResponseContent" as const,
      val: "これはテスト投稿です",
    };
    const mockHashId = { _type: "WriteHashId" as const, val: "abcd1234" };
    const mockPostedAt = {
      _type: "WritePostedAt" as const,
      val: new Date("2025-04-07T12:00:00Z"),
    };

    // ThreadId取得モック関数
    const mockGetThreadId = async () => {
      return ok("01890c08-4754-7d1c-89aa-beee49bf4ffe");
    };

    const result = await createWriteResponse({
      authorName: mockAuthorName,
      mail: mockMail,
      responseContent: mockResponseContent,
      hashId: mockHashId,
      postedAt: mockPostedAt,
      getThreadId: mockGetThreadId,
    });

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      const response = result.value;
      expect(response._type).toBe("WriteResponse");
      expect(response.authorName).toBe(mockAuthorName);
      expect(response.mail).toBe(mockMail);
      expect(response.responseContent).toBe(mockResponseContent);
      expect(response.hashId).toBe(mockHashId);
      expect(response.postedAt).toBe(mockPostedAt);

      // 自動生成されるIDフィールドの検証
      expect(response.id._type).toBe("WriteResponseId");
      expect(response.id.val).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      ); // UUIDv7形式

      // スレッドIDの検証
      expect(response.threadId._type).toBe("WriteThreadId");
      expect(response.threadId.val).toBe(
        "01890c08-4754-7d1c-89aa-beee49bf4ffe"
      );
    }
  });

  it("スレッドID取得でエラーが発生した場合、エラーを返すこと", async () => {
    // 必要な値オブジェクトのモック
    const mockAuthorName = {
      _type: "WriteAuthorName" as const,
      val: { _type: "none" as const, authorName: "テスト太郎" },
    };
    const mockMail = { _type: "WriteMail" as const, val: "test@example.com" };
    const mockResponseContent = {
      _type: "WriteResponseContent" as const,
      val: "これはテスト投稿です",
    };
    const mockHashId = { _type: "WriteHashId" as const, val: "abcd1234" };
    const mockPostedAt = {
      _type: "WritePostedAt" as const,
      val: new Date("2025-04-07T12:00:00Z"),
    };

    // エラーを返すスレッドID取得モック
    const mockGetThreadIdWithError = async () => {
      return err(new Error("スレッドIDの取得に失敗しました"));
    };

    const result = await createWriteResponse({
      authorName: mockAuthorName,
      mail: mockMail,
      responseContent: mockResponseContent,
      hashId: mockHashId,
      postedAt: mockPostedAt,
      getThreadId: mockGetThreadIdWithError,
    });

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("スレッドIDの取得に失敗しました");
    }
  });

  it("無効なスレッドIDの場合、エラーを返すこと", async () => {
    // 必要な値オブジェクトのモック
    const mockAuthorName = {
      _type: "WriteAuthorName" as const,
      val: { _type: "none" as const, authorName: "テスト太郎" },
    };
    const mockMail = { _type: "WriteMail" as const, val: "test@example.com" };
    const mockResponseContent = {
      _type: "WriteResponseContent" as const,
      val: "これはテスト投稿です",
    };
    const mockHashId = { _type: "WriteHashId" as const, val: "abcd1234" };
    const mockPostedAt = {
      _type: "WritePostedAt" as const,
      val: new Date("2025-04-07T12:00:00Z"),
    };

    // 無効なスレッドIDを返すモック
    const mockGetInvalidThreadId = async () => {
      return ok("invalid-uuid");
    };

    const result = await createWriteResponse({
      authorName: mockAuthorName,
      mail: mockMail,
      responseContent: mockResponseContent,
      hashId: mockHashId,
      postedAt: mockPostedAt,
      getThreadId: mockGetInvalidThreadId,
    });

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("不正なスレッドIDです");
    }
  });
});
</file>

<file path="src/conversation/domain/write/WriteResponseContent.test.ts">
import { ok } from "neverthrow";
import { describe, it, expect } from "vitest";

import { createWriteResponseContent } from "./WriteResponseContent";

describe("WriteResponseContent", () => {
  // 最大コンテンツ長を返すモック関数
  const mockGetMaxContentLength = async () => {
    return ok(1000);
  };

  it("正常な値で作成できること", async () => {
    const result = await createWriteResponseContent(
      "これはテスト投稿です",
      mockGetMaxContentLength
    );

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteResponseContent");
      expect(result.value.val).toBe("これはテスト投稿です");
    }
  });

  it("空文字列の場合はエラーになること", async () => {
    const result = await createWriteResponseContent(
      "",
      mockGetMaxContentLength
    );

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("本文は必須です");
    }
  });

  it("最大文字数を超える場合はエラーになること", async () => {
    // 文字数制限を10に設定するモック
    const mockGetMaxContentLength10 = async () => {
      return ok(10);
    };

    const result = await createWriteResponseContent(
      "これは長すぎるテスト投稿です",
      mockGetMaxContentLength10
    );

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("本文は10文字以内で入力してください");
    }
  });

  it("ちょうど最大文字数の場合は作成できること", async () => {
    // 文字数制限を10に設定するモック
    const mockGetMaxContentLength10 = async () => {
      return ok(10);
    };

    const result = await createWriteResponseContent(
      "ちょうど10文字",
      mockGetMaxContentLength10
    );

    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/conversation/domain/write/WriteResponseContent.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

// 本文
export type WriteResponseContent = {
  readonly _type: "WriteResponseContent";
  readonly val: string;
};
export const createWriteResponseContent = async (
  value: string,
  getMaxContentLength: () => Promise<Result<number, Error>>
): Promise<Result<WriteResponseContent, ValidationError>> => {
  if (value.length === 0) {
    return err(new ValidationError("本文は必須です"));
  }

  const maxLen = await getMaxContentLength();
  if (maxLen.isErr()) {
    return err(maxLen.error);
  }

  if (value.length > maxLen.value) {
    return err(
      new ValidationError(`本文は${maxLen.value}文字以内で入力してください`)
    );
  }
  return ok({ _type: "WriteResponseContent", val: value });
};
</file>

<file path="src/conversation/domain/write/WriteResponseId.test.ts">
import { describe, it, expect } from "vitest";

import { generateResponseId, createResponseId } from "./WriteResponseId";

describe("WriteResponseId", () => {
  describe("generateResponseId", () => {
    it("有効なUUIDv7を生成すること", () => {
      const responseId = generateResponseId();

      expect(responseId._type).toBe("WriteResponseId");
      // UUIDv7の形式チェック（36文字でハイフンを含む）
      expect(responseId.val).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      );
    });

    it("生成されるUUIDv7は一意であること", () => {
      const responseId1 = generateResponseId();
      const responseId2 = generateResponseId();

      expect(responseId1.val).not.toBe(responseId2.val);
    });
  });

  describe("createResponseId", () => {
    it("有効なUUIDv7文字列で作成できること", () => {
      // テスト用の有効なUUIDv7
      const validUuid = "01890c08-4754-7d1c-89aa-beee49bf4ffe";
      const result = createResponseId(validUuid);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteResponseId");
        expect(result.value.val).toBe(validUuid);
      }
    });

    it("無効なUUID形式ではエラーになること", () => {
      const invalidUuids = [
        "invalid-uuid",
        "123456",
        "01890c08-4754-8d1c-89aa-beee49bf4ffe", // バージョン8（無効）
        "01890c08-4754-6d1c-89aa-beee49bf4ffe", // バージョン6（無効）
        "01890c08475489aabeee49bf4ffe", // ハイフンなし
      ];

      invalidUuids.forEach((uuid) => {
        const result = createResponseId(uuid);
        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.message).toBe("不正なレスIDです");
        }
      });
    });
  });
});
</file>

<file path="src/conversation/domain/write/WriteResponseId.ts">
import { ok, err, type Result } from "neverthrow";
import { uuidv7 } from "uuidv7";

import { ValidationError } from "../../../shared/types/Error";
import { validateUUIDv7 } from "../../../shared/utils/validateUUIDv7";

// レスポンスのメインID。uuidv7
export type WriteResponseId = {
  readonly _type: "WriteResponseId";
  readonly val: string;
};
export const generateResponseId = (): WriteResponseId => {
  const value = uuidv7();
  return { _type: "WriteResponseId", val: value };
};

export const createResponseId = (
  value: string
): Result<WriteResponseId, ValidationError> => {
  // UUIDv7のバリデーション
  if (!validateUUIDv7(value)) {
    return err(new ValidationError("不正なレスIDです"));
  }
  return ok({ _type: "WriteResponseId", val: value });
};
</file>

<file path="src/conversation/domain/write/WriteResponseNumber.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteResponseNumber } from "./WriteResponseNumber";

describe("WriteResponseNumber", () => {
  it("正常な値（1以上）で作成できること", () => {
    const result = createWriteResponseNumber(1);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteResponseNumber");
      expect(result.value.val).toBe(1);
    }
  });

  it("大きな数値でも作成できること", () => {
    const result = createWriteResponseNumber(1000);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteResponseNumber");
      expect(result.value.val).toBe(1000);
    }
  });

  it("0の場合はエラーになること", () => {
    const result = createWriteResponseNumber(0);

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("レス番号は1以上です");
    }
  });

  it("負の数の場合はエラーになること", () => {
    const result = createWriteResponseNumber(-5);

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("レス番号は1以上です");
    }
  });
});
</file>

<file path="src/conversation/domain/write/WriteResponseNumber.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

export type WriteResponseNumber = {
  readonly _type: "WriteResponseNumber";
  readonly val: number;
};
export const createWriteResponseNumber = (
  value: number
): Result<WriteResponseNumber, ValidationError> => {
  if (value < 1) {
    return err(new ValidationError("レス番号は1以上です"));
  }

  return ok({ _type: "WriteResponseNumber", val: value });
};
</file>

<file path="src/conversation/domain/write/WriteThread.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteThread } from "./WriteThread";

describe("WriteThread", () => {
  it("正常なパラメータでスレッドを作成できること", () => {
    // 必要な値オブジェクトのモック
    const mockThreadTitle = {
      _type: "WriteThreadTitle" as const,
      val: "テストスレッド",
    };
    const mockPostedAt = {
      _type: "WritePostedAt" as const,
      val: new Date("2025-04-07T12:00:00Z"),
    };

    const result = createWriteThread({
      title: mockThreadTitle,
      postedAt: mockPostedAt,
    });

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      const thread = result.value;
      expect(thread._type).toBe("WriteThread");
      expect(thread.title).toBe(mockThreadTitle);
      expect(thread.postedAt).toBe(mockPostedAt);
      expect(thread.updatedAt).toBe(mockPostedAt); // postedAtと同じ値が設定される

      // 自動生成されるIDフィールドの検証
      expect(thread.id._type).toBe("WriteThreadId");
      expect(thread.id.val).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      ); // UUIDv7形式

      // epochIdの検証
      expect(thread.epochId._type).toBe("WriteThreadEpochId");
      expect(thread.epochId.val).toBe(
        Math.floor(mockPostedAt.val.getTime() / 1000)
      ); // 秒単位のタイムスタンプ
    }
  });
});
</file>

<file path="src/conversation/domain/write/WriteThreadId.test.ts">
import { describe, it, expect } from "vitest";

import { generateWriteThreadId, createWriteThreadId } from "./WriteThreadId";

describe("WriteThreadId", () => {
  describe("generateWriteThreadId", () => {
    it("有効なUUIDv7を生成すること", () => {
      const threadId = generateWriteThreadId();

      expect(threadId._type).toBe("WriteThreadId");
      // UUIDv7の形式チェック（36文字でハイフンを含む）
      expect(threadId.val).toMatch(
        /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i
      );
    });

    it("生成されるUUIDv7は一意であること", () => {
      const threadId1 = generateWriteThreadId();
      const threadId2 = generateWriteThreadId();

      expect(threadId1.val).not.toBe(threadId2.val);
    });
  });

  describe("createWriteThreadId", () => {
    it("有効なUUIDv7文字列で作成できること", () => {
      // テスト用の有効なUUIDv7
      const validUuid = "01890c08-4754-7d1c-89aa-beee49bf4ffe";
      const result = createWriteThreadId(validUuid);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteThreadId");
        expect(result.value.val).toBe(validUuid);
      }
    });

    it("無効なUUID形式ではエラーになること", () => {
      const invalidUuids = [
        "invalid-uuid",
        "123456",
        "01890c08-4754-8d1c-89aa-beee49bf4ffe", // バージョン8（無効）
        "01890c08-4754-6d1c-89aa-beee49bf4ffe", // バージョン6（無効）
        "01890c08475489aabeee49bf4ffe", // ハイフンなし
      ];

      invalidUuids.forEach((uuid) => {
        const result = createWriteThreadId(uuid);
        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.message).toBe("不正なスレッドIDです");
        }
      });
    });
  });
});
</file>

<file path="src/conversation/domain/write/WriteThreadId.ts">
import { ok, err, type Result } from "neverthrow";
import { uuidv7 } from "uuidv7";

import { ValidationError } from "../../../shared/types/Error";
import { validateUUIDv7 } from "../../../shared/utils/validateUUIDv7";

// スレッドのメインID。uuidv7
export type WriteThreadId = {
  readonly _type: "WriteThreadId";
  readonly val: string;
};
export const generateWriteThreadId = (): WriteThreadId => {
  const value = uuidv7();
  return { _type: "WriteThreadId", val: value };
};

export const createWriteThreadId = (
  value: string
): Result<WriteThreadId, ValidationError> => {
  // UUIDv7のバリデーション
  if (!validateUUIDv7(value)) {
    return err(new ValidationError("不正なスレッドIDです"));
  }
  return ok({ _type: "WriteThreadId", val: value });
};
</file>

<file path="src/conversation/domain/write/WriteThreadTitle.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteThreadTitle } from "./WriteThreadTitle";

describe("WriteThreadTitle", () => {
  it("正常な値で作成できること", () => {
    const result = createWriteThreadTitle("テストスレッド");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteThreadTitle");
      expect(result.value.val).toBe("テストスレッド");
    }
  });

  it("空文字列の場合はエラーになること", () => {
    const result = createWriteThreadTitle("");

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("スレッドタイトルは必須です");
    }
  });

  it("100文字を超える場合はエラーになること", () => {
    const longTitle = "あ".repeat(101); // 101文字
    const result = createWriteThreadTitle(longTitle);

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("スレッドタイトルは100文字以内です");
    }
  });

  it("ちょうど100文字の場合は作成できること", () => {
    const title100 = "あ".repeat(100); // 100文字
    const result = createWriteThreadTitle(title100);

    expect(result.isOk()).toBe(true);
  });

  it("使えない文字（<>）が含まれる場合はエラーになること", () => {
    const invalidTitles = [
      '<script>alert("XSS")</script>',
      "タイトル<b>太字</b>",
      "不正な>文字",
    ];

    invalidTitles.forEach((title) => {
      const result = createWriteThreadTitle(title);
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe(
          "スレッドタイトルに使えない文字が含まれています"
        );
      }
    });
  });
});
</file>

<file path="src/conversation/domain/write/WriteThreadTitle.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

// スレッドタイトル
export type WriteThreadTitle = {
  readonly _type: "WriteThreadTitle";
  readonly val: string;
};

const titleRegex = /^[^<>]+$/;

export const createWriteThreadTitle = (
  value: string
): Result<WriteThreadTitle, ValidationError> => {
  if (value.length === 0) {
    return err(new ValidationError("スレッドタイトルは必須です"));
  }
  if (value.length > 100) {
    return err(new ValidationError("スレッドタイトルは100文字以内です"));
  }
  // 使えない文字が含まれていないかチェック
  if (!titleRegex.test(value)) {
    return err(
      new ValidationError("スレッドタイトルに使えない文字が含まれています")
    );
  }
  return ok({ _type: "WriteThreadTitle", val: value });
};
</file>

<file path="src/conversation/usecases/getLatestResponsesByThreadIdAndCountUsecase.ts">
import { err, ok } from "neverthrow";

import { createWriteResponseNumber } from "../domain/write/WriteResponseNumber";
import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { getLatestResponsesByThreadIdAndCountRepository } from "../repositories/getLatestResponsesByThreadIdAndCountRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドについている最新のレスを指定件数取得するユースケース
export const getLatestResponsesByThreadIdAndCountUsecase = async (
  vakContext: VakContext,
  { threadIdRaw, countRaw }: { threadIdRaw: string; countRaw: number }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getLatestResponseByThreadIdAndCount",
    threadId: threadIdRaw,
    count: countRaw,
    message: "Starting latest thread responses retrieval",
  });

  // ThreadIdを生成
  logger.debug({
    operation: "getLatestResponseByThreadIdAndCount",
    threadId: threadIdRaw,
    message: "Validating thread ID",
  });

  const threadIdResult = createWriteThreadId(threadIdRaw);
  if (threadIdResult.isErr()) {
    logger.error({
      operation: "getLatestResponseByThreadIdAndCount",
      error: threadIdResult.error,
      threadId: threadIdRaw,
      message: "Invalid thread ID format",
    });
    return err(threadIdResult.error);
  }

  // Countを検証
  logger.debug({
    operation: "getLatestResponseByThreadIdAndCount",
    count: countRaw,
    message: "Validating response count",
  });

  const countResult = createWriteResponseNumber(countRaw);
  if (countResult.isErr()) {
    logger.error({
      operation: "getLatestResponseByThreadIdAndCount",
      error: countResult.error,
      count: countRaw,
      message: "Invalid response count value",
    });
    return err(countResult.error);
  }

  // 最新のレスを指定件数取得
  logger.debug({
    operation: "getLatestResponseByThreadIdAndCount",
    threadId: threadIdRaw,
    count: countRaw,
    message: "Fetching latest thread responses from repository",
  });

  const responsesWithThreadResult =
    await getLatestResponsesByThreadIdAndCountRepository(vakContext, {
      threadId: threadIdResult.value,
      count: countResult.value,
    });
  if (responsesWithThreadResult.isErr()) {
    logger.error({
      operation: "getLatestResponseByThreadIdAndCount",
      error: responsesWithThreadResult.error,
      threadId: threadIdRaw,
      count: countRaw,
      message: "Failed to fetch latest thread responses",
    });
    return err(responsesWithThreadResult.error);
  }

  logger.info({
    operation: "getLatestResponseByThreadIdAndCount",
    threadId: threadIdRaw,
    threadTitle: responsesWithThreadResult.value.thread.threadTitle.val,
    count: countRaw,
    responseCount: responsesWithThreadResult.value.responses.length,
    message: "Successfully retrieved latest thread responses",
  });

  return ok(responsesWithThreadResult.value);
};
</file>

<file path="src/conversation/usecases/getResponseByThreadIdAndResNumRangeUsecase.ts">
import { err, ok } from "neverthrow";

import { createWriteResponseNumber } from "../domain/write/WriteResponseNumber";
import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { getResponseByThreadIdAndResNumRangeRepository } from "../repositories/getResponseByThreadIdAndResNumRangeRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドについている指定範囲のレスを取得するユースケース
export const getResponseByThreadIdAndResNumRangeUsecase = async (
  vakContext: VakContext,
  {
    threadIdRaw,
    startResponseNumberRaw,
    endResponseNumberRaw,
  }: {
    threadIdRaw: string;
    startResponseNumberRaw: number | null;
    endResponseNumberRaw: number | null;
  }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getResponseByThreadIdAndResNumRange",
    threadId: threadIdRaw,
    startResponseNumber: startResponseNumberRaw,
    endResponseNumber: endResponseNumberRaw,
    message: "Starting thread responses range retrieval",
  });

  // ThreadIdを生成
  logger.debug({
    operation: "getResponseByThreadIdAndResNumRange",
    threadId: threadIdRaw,
    message: "Validating thread ID",
  });

  const threadIdResult = createWriteThreadId(threadIdRaw);
  if (threadIdResult.isErr()) {
    logger.error({
      operation: "getResponseByThreadIdAndResNumRange",
      error: threadIdResult.error,
      threadId: threadIdRaw,
      message: "Invalid thread ID format",
    });
    return err(threadIdResult.error);
  }

  // StartResponseNumberを検証
  let startResponseNumber = null;
  if (startResponseNumberRaw !== null) {
    logger.debug({
      operation: "getResponseByThreadIdAndResNumRange",
      startResponseNumber: startResponseNumberRaw,
      message: "Validating start response number",
    });

    const startResponseNumberResult = createWriteResponseNumber(
      startResponseNumberRaw
    );
    if (startResponseNumberResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNumRange",
        error: startResponseNumberResult.error,
        startResponseNumber: startResponseNumberRaw,
        message: "Invalid start response number value",
      });
      return err(startResponseNumberResult.error);
    }
    startResponseNumber = startResponseNumberResult.value;
  }

  // EndResponseNumberを検証
  let endResponseNumber = null;
  if (endResponseNumberRaw !== null) {
    logger.debug({
      operation: "getResponseByThreadIdAndResNumRange",
      endResponseNumber: endResponseNumberRaw,
      message: "Validating end response number",
    });

    const endResponseNumberResult =
      createWriteResponseNumber(endResponseNumberRaw);
    if (endResponseNumberResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNumRange",
        error: endResponseNumberResult.error,
        endResponseNumber: endResponseNumberRaw,
        message: "Invalid end response number value",
      });
      return err(endResponseNumberResult.error);
    }
    endResponseNumber = endResponseNumberResult.value;
  }

  // 指定範囲のレスを取得
  logger.debug({
    operation: "getResponseByThreadIdAndResNumRange",
    threadId: threadIdRaw,
    startResponseNumber: startResponseNumberRaw,
    endResponseNumber: endResponseNumberRaw,
    message: "Fetching thread responses in range from repository",
  });

  const responsesWithThreadResult =
    await getResponseByThreadIdAndResNumRangeRepository(vakContext, {
      threadId: threadIdResult.value,
      startResponseNumber,
      endResponseNumber,
    });
  if (responsesWithThreadResult.isErr()) {
    logger.error({
      operation: "getResponseByThreadIdAndResNumRange",
      error: responsesWithThreadResult.error,
      threadId: threadIdRaw,
      startResponseNumber: startResponseNumberRaw,
      endResponseNumber: endResponseNumberRaw,
      message: "Failed to fetch thread responses in range",
    });
    return err(responsesWithThreadResult.error);
  }

  logger.info({
    operation: "getResponseByThreadIdAndResNumRange",
    threadId: threadIdRaw,
    threadTitle: responsesWithThreadResult.value.thread.threadTitle.val,
    responseCount: responsesWithThreadResult.value.responses.length,
    startResponseNumber: startResponseNumberRaw,
    endResponseNumber: endResponseNumberRaw,
    message: "Successfully retrieved thread responses in range",
  });

  return ok(responsesWithThreadResult.value);
};
</file>

<file path="src/conversation/usecases/getResponseByThreadIdAndResNumUsecase.ts">
import { err, ok } from "neverthrow";

import { createWriteResponseNumber } from "../domain/write/WriteResponseNumber";
import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { getResponseByThreadIdAndResNumRepository } from "../repositories/getResponseByThreadIdAndResNumRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドの特定のレス番号のレスポンスを取得するユースケース
export const getResponseByThreadIdAndResNumUsecase = async (
  vakContext: VakContext,
  {
    threadIdRaw,
    responseNumberRaw,
  }: { threadIdRaw: string; responseNumberRaw: number }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getResponseByThreadIdAndResNum",
    threadId: threadIdRaw,
    responseNumber: responseNumberRaw,
    message: "Starting response retrieval by thread ID and response number",
  });

  // ThreadIdを生成
  logger.debug({
    operation: "getResponseByThreadIdAndResNum",
    threadId: threadIdRaw,
    message: "Validating thread ID",
  });

  const threadIdResult = createWriteThreadId(threadIdRaw);
  if (threadIdResult.isErr()) {
    logger.error({
      operation: "getResponseByThreadIdAndResNum",
      error: threadIdResult.error,
      threadId: threadIdRaw,
      message: "Invalid thread ID format",
    });
    return err(threadIdResult.error);
  }

  // レスポンス番号を生成
  logger.debug({
    operation: "getResponseByThreadIdAndResNum",
    responseNumber: responseNumberRaw,
    message: "Validating response number",
  });

  const responseNumberResult = createWriteResponseNumber(responseNumberRaw);
  if (responseNumberResult.isErr()) {
    logger.error({
      operation: "getResponseByThreadIdAndResNum",
      error: responseNumberResult.error,
      responseNumber: responseNumberRaw,
      message: "Invalid response number format",
    });
    return err(responseNumberResult.error);
  }

  // 特定のレスポンスを取得
  logger.debug({
    operation: "getResponseByThreadIdAndResNum",
    threadId: threadIdRaw,
    responseNumber: responseNumberRaw,
    message: "Fetching specific response from repository",
  });

  const responseResult = await getResponseByThreadIdAndResNumRepository(
    vakContext,
    {
      threadId: threadIdResult.value,
      responseNumber: responseNumberResult.value,
    }
  );
  if (responseResult.isErr()) {
    logger.error({
      operation: "getResponseByThreadIdAndResNum",
      error: responseResult.error,
      threadId: threadIdRaw,
      responseNumber: responseNumberRaw,
      message: "Failed to fetch response",
    });
    return err(responseResult.error);
  }

  logger.info({
    operation: "getResponseByThreadIdAndResNum",
    threadId: threadIdRaw,
    responseNumber: responseNumberRaw,
    threadTitle: responseResult.value.thread.threadTitle.val,
    responseCount: responseResult.value.responses.length,
    message: "Successfully retrieved response by thread ID and response number",
  });

  return ok(responseResult.value);
};
</file>

<file path="src/shared/types/Error.ts">
export class DatabaseError extends Error {
  constructor(message: string, public readonly cause?: unknown) {
    super(message);
    this.name = "DatabaseError";
  }
}

export class DataNotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "DataNotFoundError";
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class IpAddressNotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "IpAddressNotFoundError";
  }
}

export class PasswordDoesNotMatchError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PasswordDoesNotMatchError";
  }
}
</file>

<file path="src/shared/types/Nominal.ts">
// Nominal type helper
export type Nominal<T, Name extends string> = T & { readonly _type: Name };
</file>

<file path="src/shared/types/VakContext.ts">
import type { PinoLogger } from "hono-pino";
import type { Sql } from "postgres";

export type VakContext = {
  sql: Sql;
  logger: PinoLogger;
};
</file>

<file path="src/shared/utils/createTrip.ts">
import crypto from "crypto";

export const createTrip = (tripKey: string): string => {
  const crypted = crypto
    .createHash("sha256")
    .update(tripKey)
    .digest("base64")
    .slice(0, 12);
  const trip = crypted.replace(/\+/g, ".").replace(/\//g, "$");

  return trip;
};
</file>

<file path="src/shared/utils/formatDate.ts">
const padZero = (num: number, len: number = 2): string => {
  return String(num).padStart(len, "0");
};

// 日時の形式を整えて文字列にする関数
export function formatDate(date: Date): string {
  // 2025/02/23(日) 08:41:28.90 など
  const year = date.getFullYear();
  const month = padZero(date.getMonth() + 1); // 2桁表示
  const day = padZero(date.getDate()); // 2桁表示
  const hour = padZero(date.getHours()); // 2桁表示
  const minute = padZero(date.getMinutes()); // 2桁表示
  const second = padZero(date.getSeconds()); // 2桁表示
  const millisecond = padZero(date.getMilliseconds(), 3); //3桁
  const getWeekday = (date: Date) => {
    const weekdays = ["日", "月", "火", "水", "木", "金", "土"];
    return weekdays[date.getDay()];
  };
  return `${year}/${month}/${day}(${getWeekday(
    date
  )}) ${hour}:${minute}:${second}.${millisecond.substring(0, 2)}`; //ミリ秒も最初から二桁で表示
}
</file>

<file path="src/shared/utils/validateUUIDv7.ts">
const regexUuidV7 =
  /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;

export const validateUUIDv7 = (value: string): boolean => {
  return regexUuidV7.test(value);
};
</file>

<file path="vite.config.ts">
import buildBun from "@hono/vite-build/bun";
import buildWorkers from "@hono/vite-build/cloudflare-workers";
import adapter from "@hono/vite-dev-server/cloudflare";
import tailwindcss from "@tailwindcss/vite";
import honox from "honox/vite";
import { defineConfig } from "vite";

export default defineConfig(({ mode }) => {
  if (mode === "client") {
    return {
      build: {
        manifest: true,
        rollupOptions: {
          input: ["./app/style.css"],
        },
      },
      plugins: [tailwindcss()],
    };
  }

  const build = mode === "workers" ? buildWorkers : buildBun;

  return {
    ssr: {
      external: ["iconv-lite", "encoding-japanese", "postgres", "pino"],
    },
    server: {
      port: 80,
      // 一般公開
      host: true,
    },
    plugins: [
      honox({
        client: {
          input: ["/app/style.css"],
        },
        devServer: { adapter },
      }),
      build(),
      tailwindcss(),
    ],
  };
});
</file>

<file path="app/middlewares/dbInitializeMiddleware.tsx">
import { env, getRuntimeKey } from "hono/adapter"; // 環境判定と環境変数取得
import postgres from "postgres"; // postgres.js ライブラリ

import type { MiddlewareHandler } from "hono";
import type { Context, Env as HonoEnv } from "hono";

/**
 * postgres.js の Sql クライアントインスタンスの型エイリアス
 */
export type DbClient = postgres.Sql;

/**
 * ミドルウェアが Hono の Context に追加する変数の型定義 (デフォルトキー 'db')
 */
export type Env = {
  Variables: {
    db: DbClient;
  };
};

/**
 * カスタムコンテキストキーを使用する場合の型定義
 */
export type DbEnv<DbKey extends string = "db"> = {
  Variables: {
    [key in DbKey]: DbClient;
  };
};

/**
 * データベースクライアントミドルウェアのオプション
 */
export interface DbMiddlewareOptions<ContextKey extends string = "db"> {
  /**
   * HonoのContextにクライアントを設定する際のキー名 (リテラル文字列推奨)
   * @default "db"
   */
  contextKey?: ContextKey;

  /**
   * データベース接続文字列が格納されている環境変数名
   * @default "DATABASE_URL"
   */
  envKey?: string;

  /**
   * `postgres.js` に渡す追加オプション
   * 環境に応じて `max` オプションなどが内部で調整される可能性があります。
   * @default {}
   */
  postgresOptions?: postgres.Options<Record<string, postgres.PostgresType>>;
}

// --- グローバル変数 (非Workers環境でのインスタンス保持用) ---
// この変数は、Node.jsなどの環境でのみ、初期化後にインスタンスを保持するために使用されます。
let sharedDbClientInstance: DbClient | null = null;
// 非Workers環境での初期化重複を防ぐための簡易的なフラグ（ロック）
let isInitializingSharedDb = false;

/**
 * データベースクライアントを初期化する内部関数
 * エラーが発生した場合は null を返し、ログを出力します。
 *
 * @param c Hono Context (環境変数取得のため)
 * @param options 設定オプションと環境情報
 * @returns 初期化されたクライアントインスタンス、または失敗時 null
 */
const initializeDbClientInternal = (
  c: Context,
  options: {
    envKey: string;
    postgresOptions: postgres.Options<Record<string, postgres.PostgresType>>;
    contextKey: string;
    isCloudflareWorkers: boolean; // 現在の環境がWorkersかどうか
  }
): DbClient | null => {
  const { envKey, postgresOptions, contextKey, isCloudflareWorkers } = options;
  try {
    // 環境変数を取得 (Honoのアダプタを使用)
    const databaseUrl =
      // 本番環境の場合
      env<{ [key: string]: string }>(c)[envKey] ||
      // 開発環境の場合
      // prettier-ignore
      `postgresql://${import.meta.env.VITE_POSTGRES_USER}:${import.meta.env.VITE_POSTGRES_PASSWORD}@localhost:5432/${import.meta.env.VITE_POSTGRES_DB}?sslmode=disable`;

    if (!databaseUrl) {
      // 接続文字列が見つからない場合はエラーログを出力し、nullを返す
      console.error(
        `[${contextKey}] Error: Database connection string environment variable '${envKey}' not found.`
      );
      return null;
    }

    // postgres.js に渡す最終的なオプションを準備
    const finalOptions: postgres.Options<
      Record<string, postgres.PostgresType>
    > = {
      // 提供されたオプションをベースにする
      ...postgresOptions,
      // 環境に応じた調整 (例: Workersではデフォルトの最大接続数を調整)
      // 注意: Hyperdriveを使用する場合、maxはHyperdrive側で管理されるため、ここでの指定の影響は限定的です。
      //       Hyperdriveを使わない直接接続の場合、Workersでは少ない値(例: 1)が推奨されることがあります。
      max: isCloudflareWorkers
        ? postgresOptions?.max ?? 1
        : postgresOptions?.max, // Workers環境ではデフォルト1、それ以外は指定値 or デフォルト
      // --- その他の推奨オプション例 ---
      // idle_timeout: postgresOptions?.idle_timeout ?? 20, // アイドル接続のタイムアウト(秒)
      // connect_timeout: postgresOptions?.connect_timeout ?? 10, // 接続試行のタイムアウト(秒)
      // transform: { // 例: snake_case -> camelCase 変換
      //   column: postgres.toCamel,
      //   ...postgresOptions.transform,
      // },
      // ---------------------------------
    };

    // postgres クライアントを初期化
    const client = postgres(databaseUrl, finalOptions);

    // 成功ログ（環境と戦略を明記）
    console.log(
      `[${contextKey}] Database client initialized successfully. (Environment: ${
        isCloudflareWorkers ? "Cloudflare Workers" : "Other"
      }, Strategy: ${isCloudflareWorkers ? "Per-request" : "Shared Instance"})`
    );
    return client;
  } catch (error) {
    // エラーログを出力し、nullを返す
    console.error(
      `[${contextKey}] Failed to initialize database client:`,
      error
    );
    return null;
  }
};

/**
 * Honoミドルウェア: 環境に応じてデータベースクライアントを初期化/再利用し、Contextに設定します。
 *
 * - **Cloudflare Workers環境**: リクエストごとに新しいクライアントインスタンスを初期化します。
 *   これにより `Cannot perform I/O...` エラーを回避しますが、接続オーバーヘッドが発生する可能性があります。
 *   **Cloudflare Hyperdrive の利用を強く推奨します。** Hyperdriveが接続プーリングを管理するため、
 *   Worker側で毎回初期化しても効率的に動作します。
 *
 * - **その他の環境 (Node.jsなど)**: 初回リクエスト時にクライアントを初期化し、以降は
 *   グローバルに保持された同じインスタンスを効率的に再利用します。
 *
 * @param options ミドルウェアの設定オプション
 * @returns Honoミドルウェアハンドラ
 */
export const dbClientMiddlewareConditional = <ContextKey extends string = "db">(
  options?: DbMiddlewareOptions<ContextKey>
): MiddlewareHandler<DbEnv<ContextKey> & HonoEnv> => {
  const contextKey = options?.contextKey ?? ("db" as ContextKey);
  const envKey = options?.envKey ?? "DATABASE_URL";
  const postgresOptions = options?.postgresOptions ?? {};

  // この関数がリクエストごとに呼び出されます
  return async (c, next) => {
    // Honoのアダプタを使って現在のランタイム環境を取得
    const runtime = getRuntimeKey();
    const isCloudflareWorkers = runtime === "workerd";

    let clientToUse: DbClient | null = null; // このリクエストで使用するクライアントインスタンス

    if (isCloudflareWorkers) {
      // --- Cloudflare Workers環境: 毎回新しいインスタンスを初期化 ---
      // console.log(`[${contextKey}] Initializing DB client for Worker request...`);
      clientToUse = initializeDbClientInternal(c, {
        envKey,
        postgresOptions,
        contextKey,
        isCloudflareWorkers,
      });
      // 注意: Hyperdriveを使わない場合、毎回接続コストがかかります。
    } else {
      // --- 非Workers環境: 初回初期化 & 以降は共有インスタンスを再利用 ---
      if (sharedDbClientInstance === null) {
        // グローバルインスタンスがまだ存在しない場合 (初回リクエスト or 初期化失敗後)
        if (!isInitializingSharedDb) {
          // 他のリクエストが初期化中でなければ、初期化処理を開始
          isInitializingSharedDb = true; // 簡易ロックを取得
          try {
            console.log(
              `[${contextKey}] Initializing shared database client (non-worker)...`
            );
            // グローバル変数に初期化結果を格納
            sharedDbClientInstance = initializeDbClientInternal(c, {
              envKey,
              postgresOptions,
              contextKey,
              isCloudflareWorkers,
            });
            clientToUse = sharedDbClientInstance; // 初期化したインスタンスを使用
          } finally {
            isInitializingSharedDb = false; // 処理完了後、ロックを解除
          }
        } else {
          // 他のリクエストが初期化中の場合 -> 待機（簡易ポーリング）
          console.log(
            `[${contextKey}] Waiting for shared database client initialization (non-worker)...`
          );
          let waitCount = 0;
          const maxWaitCount = 100; // 約5秒待機 (50ms * 100)
          while (isInitializingSharedDb && waitCount < maxWaitCount) {
            await new Promise((resolve) => setTimeout(resolve, 50)); // 短時間待機
            waitCount++;
          }
          if (isInitializingSharedDb) {
            // 待機しても初期化が終わらない場合 (タイムアウト)
            console.error(
              `[${contextKey}] Shared database client initialization timed out (non-worker).`
            );
            clientToUse = null; // 利用可能なクライアントなし
          } else {
            // 初期化が終わったはずなので、グローバル変数から取得
            clientToUse = sharedDbClientInstance;
            if (clientToUse) {
              console.log(
                `[${contextKey}] Obtained shared database client after waiting (non-worker).`
              );
            } else {
              // 初期化が終わったのにnull -> 初期化に失敗した可能性
              console.error(
                `[${contextKey}] Shared database client is null after initialization finished (non-worker).`
              );
            }
          }
        }
      } else {
        // 既に初期化済みの場合は、グローバルインスタンスを再利用
        // console.log(`[${contextKey}] Reusing shared database client (non-worker).`);
        clientToUse = sharedDbClientInstance;
      }
    }

    // --- Contextへの設定 ---
    if (clientToUse) {
      // Hono v4以降推奨の c.set() を使用
      // @ts-expect-error Honoでは動的キーの型推論が難しい場合があるためエラーを抑制
      c.set(contextKey, clientToUse);
    } else {
      // 初期化に失敗した場合など、クライアントが利用不可
      console.error(
        `[${contextKey}] Database client is not available for this request.`
      );
      // 必要に応じてここでエラーレスポンスを返し、処理を中断することも可能
      // 例: return c.text('Database service unavailable', 503);
    }

    // 次のミドルウェアまたはルートハンドラを実行
    await next();

    // --- リクエスト後処理 ---
    // Workers環境で毎回初期化した場合、リソースリークを防ぐために `client.end()` を呼ぶべきか検討。
    // postgres.js は比較的自動で管理するが、明示的な終了が安全な場合もある。
    // Hyperdrive利用時は通常不要。ドキュメントや負荷テストで確認推奨。
    // if (isCloudflareWorkers && clientToUse && typeof clientToUse.end === 'function') {
    //   // console.log(`[${contextKey}] Attempting to end per-request DB client (Worker)...`);
    //   // 非同期だが、レスポンス返却をブロックしないように await しない方が良い場合も
    //   clientToUse.end({ timeout: 2000 }) // 短いタイムアウトを設定
    //     .then(() => /* console.log(`[${contextKey}] Per-request DB client ended.`) */)
    //     .catch(err => console.error(`[${contextKey}] Error ending per-request DB client:`, err));
    // }
  };
};
</file>

<file path="app/routes/admin/password.tsx">
import { createRoute } from "honox/factory";

import { updatePasswordUsecase } from "../../../src/config/usecases/updatePasswordUsecase";
import { ErrorMessage } from "../../components/ErrorMessage";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;
  // Check DB connection
  if (!sql) {
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }
  // Parse and validate form fields
  const body = await c.req.parseBody();
  const oldPassword = body.oldPassword;
  const newPassword = body.newPassword;
  const confirmNewPassword = body.confirmNewPassword;
  if (
    typeof oldPassword !== "string" ||
    typeof newPassword !== "string" ||
    typeof confirmNewPassword !== "string"
  ) {
    return c.render(
      <ErrorMessage error={new Error("すべての項目を入力してください")} />
    );
  }
  const updateResult = await updatePasswordUsecase(
    { sql, logger },
    { oldPassword, newPassword, confirmNewPassword }
  );
  if (updateResult.isErr()) {
    return c.render(<ErrorMessage error={updateResult.error} />);
  }
  return c.redirect("/admin", 303);
});

export default createRoute(async (c) => {
  // Render password change form
  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6">
        <h1 className="text-2xl font-bold text-gray-800 mb-6">
          パスワード変更
        </h1>
        <form method="post" action="/admin/password" className="w-full">
          <div className="flex flex-col gap-4">
            <div className="flex flex-col">
              <label
                htmlFor="oldPassword"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                現在のパスワード
              </label>
              <input
                type="password"
                id="oldPassword"
                name="oldPassword"
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
            <div className="flex flex-col">
              <label
                htmlFor="newPassword"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                新しいパスワード
              </label>
              <input
                type="password"
                id="newPassword"
                name="newPassword"
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
            <div className="flex flex-col">
              <label
                htmlFor="confirmNewPassword"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                新しいパスワード（確認）
              </label>
              <input
                type="password"
                id="confirmNewPassword"
                name="confirmNewPassword"
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
          </div>
          <div className="mt-6">
            <button
              type="submit"
              className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            >
              変更
            </button>
          </div>
        </form>
      </section>
    </main>
  );
});
</file>

<file path="app/routes/senbura/SETTINGS.TXT.tsx">
import { createRoute } from "honox/factory";

import { getBoardConfigUsecase } from "../../../src/config/usecases/getBoardConfigUsecase";
import { convertShiftJis } from "../../utils/convertShiftJis";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return convertShiftJis("DBに接続できませんでした");
  }
  const config = await getBoardConfigUsecase({ sql, logger });
  if (config.isErr()) {
    return convertShiftJis(`エラーが発生しました: ${config.error.message}`);
  }

  const boardName = config.value.boardName;
  const responseText = `掲示板設定情報: ${boardName}`;
  return convertShiftJis(responseText);
});
</file>

<file path="app/routes/senbura/subject.txt.tsx">
import { createRoute } from "honox/factory";

import { getAllThreadsWithEpochIdUsecase } from "../../../src/conversation/usecases/getAllThreadsWithEpochIdUsecase";
import { convertShiftJis } from "../../utils/convertShiftJis";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return convertShiftJis("DBに接続できませんでした");
  }
  const threads = await getAllThreadsWithEpochIdUsecase({ sql, logger });
  if (threads.isErr()) {
    return convertShiftJis(`エラーが発生しました: ${threads.error.message}`);
  }

  let text = "";
  for (const thread of threads.value) {
    text += `${thread.threadEpochId.val}.dat<>${thread.title.val} (${thread.countResponse})\r\n`;
  }
  return convertShiftJis(text);
});
</file>

<file path="app/routes/test/bbs.cgi.tsx">
import Encoding from "encoding-japanese";
import { createRoute } from "honox/factory";
import iconv from "iconv-lite";

import { postResponseByThreadEpochIdUsecase } from "../../../src/conversation/usecases/postResponseByThreadEpochIdUsecase";
import { postThreadUsecase } from "../../../src/conversation/usecases/postThreadUsecase";
import { convertShiftJis } from "../../utils/convertShiftJis";
import { getIpAddress } from "../../utils/getIpAddress";

const responseBody = `
<!DOCTYPE html>
<html lang="ja">
  <head>
    <title>書きこみました。</title>
    <meta charset="Shift_JIS">
  </head>
  <body>
    書きこみが終りました。
  </body>
</html>`;

const responseBodyShiftJis = iconv.encode(responseBody, "Shift_JIS");

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return convertShiftJis("DBに接続できませんでした");
  }

  // Shift_JIS でエンコードされたフォームデータを受け取る
  const rawBody = await c.req.arrayBuffer();
  // 文字列にする
  const decodedBody = iconv.decode(Buffer.from(rawBody), "Shift_JIS");
  // &で区切り、=で分割して連想配列にする
  const paramsMap = new Map();

  for (const pair of decodedBody.split("&")) {
    const [key, value] = pair.split("=");
    paramsMap.set(key, value);
  }

  // shift_jisでデコード
  const paramsDecodedMap = new Map();
  for (const [key, value] of paramsMap) {
    // urlデコード
    const decodedValue = Encoding.urlDecode(value);
    const utf8Value = iconv.decode(Buffer.from(decodedValue), "Shift_JIS");
    paramsDecodedMap.set(key, utf8Value);
  }

  // 妥協のas string
  const name =
    typeof paramsDecodedMap.get("FROM") === "string"
      ? (paramsDecodedMap.get("FROM") as string)
      : null;
  const mail =
    typeof paramsDecodedMap.get("mail") === "string"
      ? (paramsDecodedMap.get("mail") as string)
      : null;
  const content = paramsDecodedMap.get("MESSAGE");
  const subject = paramsDecodedMap.get("subject"); // 新しいスレッド作成の場合
  const key = paramsDecodedMap.get("key"); // 既存スレッドにリプする場合

  if (!content) {
    return convertShiftJis("名前と本文は必須です。");
  }

  // subjectもkeyもない場合は不正なアクセス
  if (!subject && !key) {
    return convertShiftJis("不正なアクセスです");
  }

  const ipAddressRaw = getIpAddress(c);

  // subjectがある場合→新規スレッド作成
  if (subject) {
    const result = await postThreadUsecase(
      { sql, logger },
      {
        threadTitleRaw: subject,
        authorNameRaw: name,
        mailRaw: mail,
        responseContentRaw: content,
        ipAddressRaw,
      }
    );
    if (result.isErr()) {
      return convertShiftJis(`エラーが発生しました: ${result.error.message}`);
    }

    // 成功した場合は書き込み完了画面を表示
    return new Response(responseBodyShiftJis, {
      headers: { "Content-Type": "text/html; charset=Shift_JIS" },
    });
    // keyがある場合→レスポンス追加
  } else if (key) {
    const result = await postResponseByThreadEpochIdUsecase(
      { sql, logger },
      {
        threadEpochIdRaw: key,
        authorNameRaw: name,
        mailRaw: mail,
        responseContentRaw: content,
        ipAddressRaw,
      }
    );
    if (result.isErr()) {
      return convertShiftJis(`エラーが発生しました: ${result.error.message}`);
    }

    return new Response(responseBodyShiftJis, {
      headers: { "Content-Type": "text/html; charset=Shift_JIS" },
    });
  }
});

export default createRoute((_) => {
  return convertShiftJis("不正なアクセスです");
});
</file>

<file path="app/routes/threads/[id]/[query].tsx">
import { createRoute } from "honox/factory";

import { formatReadAuthorName } from "../../../../src/conversation/domain/read/ReadAuthorName";
import { isSage } from "../../../../src/conversation/domain/write/WriteMail";
import { getAllResponsesByThreadIdUsecase } from "../../../../src/conversation/usecases/getAllResponsesByThreadIdUsecase";
import { getLatestResponsesByThreadIdAndCountUsecase } from "../../../../src/conversation/usecases/getLatestResponsesByThreadIdAndCountUsecase";
import { getResponseByThreadIdAndResNumRangeUsecase } from "../../../../src/conversation/usecases/getResponseByThreadIdAndResNumRangeUsecase";
import { getResponseByThreadIdAndResNumUsecase } from "../../../../src/conversation/usecases/getResponseByThreadIdAndResNumUsecase";
import { formatDate } from "../../../../src/shared/utils/formatDate";
import { ErrorMessage } from "../../../components/ErrorMessage";
import { ResponseContentComponent } from "../../../components/ResponseContent";

import type { ReadThreadWithResponses } from "../../../../src/conversation/domain/read/ReadThreadWithResponses";
import type { Result } from "neverthrow";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "threads/[id]/[query]/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Thread query page requested",
  });

  if (!sql) {
    logger.error({
      operation: "threads/[id]/[query]/GET",
      message: "Database connection not available",
    });
    c.status(500);
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }

  const id = c.req.param("id");
  const queryString = c.req.param("query");

  logger.debug({
    operation: "threads/[id]/[query]/GET",
    threadId: id,
    query: queryString,
    message: "Parsing query string and fetching responses",
  });

  let responsesResult: Result<ReadThreadWithResponses, Error>;

  // パターン別の処理
  // 1. l50 - 最新50件
  if (queryString.startsWith("l") && /^l\d+$/.test(queryString)) {
    const count = parseInt(queryString.substring(1), 10);
    logger.debug({
      operation: "threads/[id]/[query]/GET",
      threadId: id,
      query: queryString,
      count,
      message: "Fetching latest responses",
    });

    responsesResult = await getLatestResponsesByThreadIdAndCountUsecase(
      { sql, logger },
      { threadIdRaw: id, countRaw: count }
    );
  }
  // 2. 数値のみ - 特定のレス番号を取得
  else if (/^\d+$/.test(queryString)) {
    const resNum = parseInt(queryString, 10);
    logger.debug({
      operation: "threads/[id]/[query]/GET",
      threadId: id,
      query: queryString,
      responseNumber: resNum,
      message: "Fetching specific response",
    });

    responsesResult = await getResponseByThreadIdAndResNumUsecase(
      { sql, logger },
      { threadIdRaw: id, responseNumberRaw: resNum }
    );
  }
  // 3. 範囲指定 (XX-, -YY, XX-YY)
  else if (/^\d*-\d*$/.test(queryString)) {
    const [startStr, endStr] = queryString.split("-");
    const start = startStr ? parseInt(startStr, 10) : null;
    const end = endStr ? parseInt(endStr, 10) : null;

    logger.debug({
      operation: "threads/[id]/[query]/GET",
      threadId: id,
      query: queryString,
      startResponse: start,
      endResponse: end,
      message: "Fetching response range",
    });

    responsesResult = await getResponseByThreadIdAndResNumRangeUsecase(
      { sql, logger },
      {
        threadIdRaw: id,
        startResponseNumberRaw: start,
        endResponseNumberRaw: end,
      }
    );
  }
  // 4. 空文字列またはその他 - 全レスを取得
  else {
    logger.debug({
      operation: "threads/[id]/[query]/GET",
      threadId: id,
      query: queryString,
      message: "Query format not recognized or empty, fetching all responses",
    });

    responsesResult = await getAllResponsesByThreadIdUsecase(
      { sql, logger },
      { threadIdRaw: id }
    );
  }

  if (responsesResult.isErr()) {
    logger.error({
      operation: "threads/[id]/[query]/GET",
      error: responsesResult.error,
      threadId: id,
      query: queryString,
      message: "Failed to fetch thread responses",
    });
    c.status(404);
    return c.render(<ErrorMessage error={responsesResult.error} />);
  }

  // 最新のレス番号を取得
  const latestResponseNumber =
    responsesResult.value.responses[responsesResult.value.responses.length - 1]
      .responseNumber.val;

  logger.debug({
    operation: "threads/[id]/[query]/GET",
    threadId: id,
    query: queryString,
    threadTitle: responsesResult.value.thread.threadTitle.val,
    responseCount: responsesResult.value.responses.length,
    message: "Successfully fetched thread responses, rendering page",
  });

  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6 mb-8">
        <div>
          <h3 className="text-purple-600 font-bold text-xl mb-4">
            {responsesResult.value.thread.threadTitle.val} (
            {responsesResult.value.responses.length})
          </h3>
          {responsesResult.value.responses.map((resp) => {
            return (
              <div
                key={resp.responseNumber.val}
                id={`${resp.threadId.val}-${resp.responseNumber.val}`}
                className="bg-gray-50 p-4 rounded-md mb-2"
              >
                <div className="flex flex-wrap items-center gap-2 mb-2">
                  <span className="font-bold">{resp.responseNumber.val}</span>
                  <span
                    className={`text-gray-700 ${
                      isSage(resp.mail) ? "text-violet-600" : ""
                    }`}
                  >
                    {formatReadAuthorName(resp.authorName)}
                  </span>
                  <span className="text-gray-500 text-sm">
                    {formatDate(resp.postedAt.val)}
                  </span>
                  <span className="text-gray-500 text-sm">
                    ID: {resp.hashId.val}
                  </span>
                </div>
                <div className="text-gray-800 max-h-80 overflow-y-auto whitespace-pre-wrap">
                  <ResponseContentComponent
                    threadId={resp.threadId}
                    responseContent={resp.responseContent}
                  />
                </div>
              </div>
            );
          })}
        </div>
        <div className="flex gap-4 mt-2">
          <a
            href={`/threads/${responsesResult.value.thread.threadId.val}`}
            className="text-blue-600 hover:underline"
          >
            全部読む
          </a>
          <a
            href={`/threads/${responsesResult.value.thread.threadId.val}/l50`}
            className="text-blue-600 hover:underline"
          >
            最新50件
          </a>
          <a
            href={`/threads/${responsesResult.value.thread.threadId.val}/1-100`}
            className="text-blue-600 hover:underline"
          >
            1-100
          </a>
          <a
            href={`/threads/${responsesResult.value.thread.threadId.val}/${latestResponseNumber}-`}
            className="text-blue-600 hover:underline"
          >
            新着レスの表示
          </a>
        </div>
      </section>

      <section className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-2xl font-semibold mb-4">返信する</h2>
        <form
          method="post"
          action={`/threads/${id}/responses`}
          className="flex flex-col gap-4"
        >
          <div className="flex flex-col md:flex-row gap-4">
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              名前:
              <input
                type="text"
                name="name"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              メールアドレス:
              <input
                name="mail"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
          </div>
          <div>
            <label className="block text-gray-700 text-sm font-bold mb-2">
              本文:
              <textarea
                name="content"
                required
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline h-32"
              ></textarea>
            </label>
          </div>
          <button
            type="submit"
            className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
          >
            書き込む
          </button>
        </form>
      </section>
    </main>
  );
});
</file>

<file path="app/style.css">
@import "tailwindcss" source("../app");

@font-face {
  font-family: "aahub-light4";
  src: url("../fonts/aahub_light4.woff2") format("woff2"),
    url("../fonts/aahub_light4.woff") format("woff"),
    url("../fonts/aahub_light4.ttf") format("ttf");
  font-display: swap;
}

@layer utilities {
  .font-aahub-light4 {
    font-family: "aahub-light4";
    line-height: 18px;
  }
}
</file>

<file path="src/config/domain/write/WriteBoardName.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteBoardName } from "./WriteBoardName";

describe("WriteBoardName", () => {
  it("正常な値で作成できること", () => {
    const result = createWriteBoardName("テスト掲示板");
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteBoardName");
      expect(result.value.val).toBe("テスト掲示板");
    }
  });

  it("空文字列の場合はエラーになること", () => {
    const result = createWriteBoardName("");
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("ボード名は必須です");
    }
  });

  it("50文字を超える場合はエラーになること", () => {
    const result = createWriteBoardName(
      "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす。。。。"
    ); // 51文字
    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe(
        "ボード名は50文字以内で入力してください"
      );
    }
  });

  it("ちょうど20文字の場合は作成できること", () => {
    const result = createWriteBoardName(
      "あいうえおかきくけこさしすせそたちつてと"
    ); // 20文字
    expect(result.isOk()).toBe(true);
  });
});
</file>

<file path="src/config/domain/write/WriteBoardName.ts">
import { err, ok } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { Result } from "neverthrow";

export type WriteBoardName = {
  readonly _type: "WriteBoardName";
  readonly val: string;
};

export const createWriteBoardName = (
  value: string
): Result<WriteBoardName, ValidationError> => {
  if (value.length === 0) {
    return err(new ValidationError("ボード名は必須です"));
  }

  if (value.length > 50) {
    return err(new ValidationError("ボード名は50文字以内で入力してください"));
  }
  return ok({ _type: "WriteBoardName", val: value });
};
</file>

<file path="src/conversation/domain/write/WriteAuthorName.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";
import { createTrip } from "../../../shared/utils/createTrip";

type SomeWriteAuthorName = {
  readonly _type: "some";
  readonly authorName: string;
  readonly trip: string;
};

type NoneWriteAuthorName = {
  readonly _type: "none";
  readonly authorName: string;
};

// 投稿者名
export type WriteAuthorName = {
  readonly _type: "WriteAuthorName";
  // readonly val: string;
  // some/noneパターン
  readonly val: SomeWriteAuthorName | NoneWriteAuthorName;
};

export const createWriteAuthorName = async (
  authorName: string | null,
  // 高階関数パターンで、より低レイヤの処理を隠蔽できるようにする
  getDefaultAuthorName: () => Promise<Result<string, Error>>
): Promise<Result<WriteAuthorName, ValidationError>> => {
  if (!authorName) {
    const nanashiName = await getDefaultAuthorName();
    if (nanashiName.isErr()) {
      return err(nanashiName.error);
    }
    return ok({
      _type: "WriteAuthorName",
      val: {
        _type: "none",
        authorName: nanashiName.value,
      },
    });
  }

  if (authorName.length > 100) {
    return err(new ValidationError("名前は100文字以内です"));
  }

  if (authorName.includes("#")) {
    const [name, tripKey] = authorName.split("#");
    const trip = createTrip(tripKey);
    return ok({
      _type: "WriteAuthorName",
      val: {
        _type: "some",
        authorName: name,
        trip: trip,
      },
    });
  }

  return ok({
    _type: "WriteAuthorName",
    val: {
      _type: "none",
      authorName,
    },
  });
};
</file>

<file path="src/conversation/domain/write/WriteMail.test.ts">
import { describe, it, expect } from "vitest";

import { createWriteMail, isSage } from "./WriteMail";

describe("WriteMail", () => {
  it("有効なメールアドレスで作成できること", () => {
    const result = createWriteMail("test@example.com");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMail");
      expect(result.value.val).toBe("test@example.com");
    }
  });

  it("nullの場合は空文字列として作成されること", () => {
    const result = createWriteMail(null);

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMail");
      expect(result.value.val).toBe("");
    }
  });

  it("空文字列は有効として扱われること", () => {
    const result = createWriteMail("");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMail");
      expect(result.value.val).toBe("");
    }
  });

  it('"sage"は有効として扱われること', () => {
    const result = createWriteMail("sage");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMail");
      expect(result.value.val).toBe("sage");
    }
  });

  it('"SAGE"（大文字）も有効として扱われること', () => {
    const result = createWriteMail("SAGE");

    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value._type).toBe("WriteMail");
      expect(result.value.val).toBe("SAGE");
    }
  });

  it("255文字を超えるメールアドレスはエラーになること", () => {
    // 長い名前部分 + @ + ドメイン部分 で255文字を超えるアドレスを作成
    const longName = "a".repeat(250);
    const longMail = `${longName}@example.com`; // 250 + 12 = 262文字

    const result = createWriteMail(longMail);

    expect(result.isErr()).toBe(true);
    if (result.isErr()) {
      expect(result.error.message).toBe("メールアドレスは255文字以内です");
    }
  });

  it("不正なメールアドレス形式はエラーになること", () => {
    const invalidMails = [
      "plaintext",
      "missing@",
      "@missing.com",
      "double@@example.com",
      "missing.domain@",
      "space in@example.com",
    ];

    invalidMails.forEach((mail) => {
      const result = createWriteMail(mail);
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe("不正なメールアドレス形式です");
      }
    });
  });

  it("sageの場合isSageがtrueを返すこと", () => {
    const mail = createWriteMail("sage");
    expect(mail.isOk()).toBe(true);
    if (mail.isOk()) {
      expect(isSage(mail.value)).toBe(true);
    }
  });
  it("SAGEの場合isSageがtrueを返すこと", () => {
    const mail = createWriteMail("SAGE");
    expect(mail.isOk()).toBe(true);
    if (mail.isOk()) {
      expect(isSage(mail.value)).toBe(true);
    }
  });

  it("空文字列の場合isSageがfalseを返すこと", () => {
    const mail = createWriteMail("");
    expect(mail.isOk()).toBe(true);
    if (mail.isOk()) {
      expect(isSage(mail.value)).toBe(false);
    }
  });

  it("通常のメールアドレスの場合isSageがfalseを返すこと", () => {
    const mail = createWriteMail("");
    expect(mail.isOk()).toBe(true);
    if (mail.isOk()) {
      expect(isSage(mail.value)).toBe(false);
    }
  });
});
</file>

<file path="src/conversation/domain/write/WriteThreadEpochId.test.ts">
import { describe, it, expect } from "vitest";

import {
  generateWriteThreadEpochId,
  createWriteThreadEpochId,
} from "./WriteThreadEpochId";

describe("WriteThreadEpochId", () => {
  describe("generateWriteThreadEpochId", () => {
    it("投稿日時から正しいエポックIDを生成すること", () => {
      // WritePostedAtのモック
      const mockPostedAt = {
        _type: "WritePostedAt" as const,
        val: new Date("2025-04-07T12:00:00Z"),
      };

      const result = generateWriteThreadEpochId(mockPostedAt);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteThreadEpochId");
        // 2025-04-07T12:00:00Z のエポックタイムスタンプ（秒）
        const expectedEpoch = Math.floor(mockPostedAt.val.getTime() / 1000);
        expect(result.value.val).toBe(expectedEpoch);
      }
    });
  });

  describe("createWriteThreadEpochId", () => {
    it("有効な数値文字列から作成できること", () => {
      const result = createWriteThreadEpochId("1712476800"); // 2025-04-07T12:00:00Z のエポックタイムスタンプ

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value._type).toBe("WriteThreadEpochId");
        expect(result.value.val).toBe(1712476800);
      }
    });

    it("数値に変換できない文字列の場合はエラーになること", () => {
      const invalidValues = ["abc", "123abc", "undefined", "null"];

      invalidValues.forEach((value) => {
        const result = createWriteThreadEpochId(value);
        expect(result.isErr()).toBe(true);
        if (result.isErr()) {
          expect(result.error.message).toBe(
            "ThreadEpochIdは数値である必要があります"
          );
        }
      });
    });

    it("空文字列の場合はエラーになること", () => {
      const result = createWriteThreadEpochId("");

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.message).toBe(
          "ThreadEpochIdは空文字列にできません"
        );
      }
    });
  });
});
</file>

<file path="src/conversation/domain/write/WriteThreadEpochId.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

// 書き込み時に生成するのでWritePostedAtを受け付けるはず
import type { WritePostedAt } from "./WritePostedAt";

// スレッドのepoch ID。datでアクセスするときにのみ利用する
export type WriteThreadEpochId = {
  readonly _type: "WriteThreadEpochId";
  readonly val: number;
};
//postedAtを元に、秒単位のepochとしてスレッドIDを生成
export const generateWriteThreadEpochId = (
  postedAt: WritePostedAt
): Result<WriteThreadEpochId, ValidationError> => {
  const value = Math.floor(postedAt.val.getTime() / 1000);

  return ok({ _type: "WriteThreadEpochId", val: value });
};

export const createWriteThreadEpochId = (
  value: string
): Result<WriteThreadEpochId, ValidationError> => {
  if (value === "") {
    return err(new ValidationError("ThreadEpochIdは空文字列にできません"));
  }
  // BIGINTを扱うため、数値に変換
  const epochId = Number(value);
  if (isNaN(epochId)) {
    return err(new ValidationError("ThreadEpochIdは数値である必要があります"));
  }
  return ok({ _type: "WriteThreadEpochId", val: epochId });
};
</file>

<file path="src/conversation/repositories/getLatestResponsesByThreadIdAndCountRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import {
  createReadThreadWithResponses,
  type ReadThreadWithResponses,
} from "../domain/read/ReadThreadWithResponses";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteResponseNumber } from "../domain/write/WriteResponseNumber";
import type { WriteThreadId } from "../domain/write/WriteThreadId";

// 指定されたスレッドの最新のレスポンスをcount個取得するリポジトリ
// 便宜上、スレッドタイトルも取得する
export const getLatestResponsesByThreadIdAndCountRepository = async (
  { sql, logger }: VakContext,
  { threadId, count }: { threadId: WriteThreadId; count: WriteResponseNumber }
): Promise<
  Result<
    ReadThreadWithResponses,
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getLatestResponseByThreadId",
    threadId: threadId.val,
    count: count.val,
    message: "Fetching latest responses for thread",
  });

  try {
    // unionなのでSafeQLの推論する型と異なる場合がある
    // やむを得ないがasで型を指定する
    const result = (await sql<
      {
        id: string | null;
        thread_id: string | null;
        response_number: number | null;
        author_name: string | null;
        mail: string | null;
        posted_at: Date | null;
        response_content: string | null;
        hash_id: string | null;
        trip: string | null;
        title: string | null;
      }[]
    >`
    (
        SELECT
            r.id, r.thread_id, r.response_number, r.author_name, r.mail,
            r.posted_at, r.response_content, r.hash_id, r.trip, t.title
        FROM
            responses as r
            JOIN threads as t ON r.thread_id = t.id
        WHERE
            r.thread_id = ${threadId.val}::uuid
        ORDER BY
            r.response_number DESC
        LIMIT ${count.val}
    )
    UNION
    (
        SELECT
            r.id, r.thread_id, r.response_number, r.author_name, r.mail,
            r.posted_at, r.response_content, r.hash_id, r.trip, t.title
        FROM
            responses as r
            JOIN threads as t ON r.thread_id = t.id
        WHERE
            r.thread_id = ${threadId.val}::uuid
            AND r.response_number = 1
    )
    ORDER BY
        response_number ASC -- または DESC
`) as {
      id: string;
      thread_id: string;
      response_number: number;
      author_name: string;
      mail: string;
      posted_at: Date;
      response_content: string;
      hash_id: string;
      trip: string | null;
      title: string;
    }[];

    if (!result || result.length === 0) {
      logger.info({
        operation: "getLatestResponseByThreadId",
        threadId: threadId.val,
        message: "No responses found for thread",
      });
      return err(new DataNotFoundError("レスポンスの取得に失敗しました"));
    }

    logger.debug({
      operation: "getLatestResponseByThreadId",
      threadId: threadId.val,
      responseCount: result.length,
      message: "Successfully retrieved latest responses from database",
    });

    // 詰め替え部分
    // すべての投稿でスレッドIDは共通なので、最初のレスポンスから取得
    const threadIdResult = createReadThreadId(result[0].thread_id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "getLatestResponseByThreadId",
        threadId: threadId.val,
        error: threadIdResult.error,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }

    // レスポンスを番号順（昇順）に並べ直す
    const sortedResponses = [...result].sort(
      (a, b) => a.response_number - b.response_number
    );

    const responses: ReadResponse[] = [];
    for (const response of sortedResponses) {
      const combinedResult = Result.combine([
        createReadResponseId(response.id),
        createReadResponseNumber(response.response_number),
        createReadAuthorName(response.author_name, response.trip),
        createReadMail(response.mail),
        createReadPostedAt(response.posted_at),
        createReadResponseContent(response.response_content),
        createReadHashId(response.hash_id),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getLatestResponseByThreadId",
          threadId: threadId.val,
          responseId: response.id,
          error: combinedResult.error,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }

      const [
        responseId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      ] = combinedResult.value;

      const responseResult = createReadResponse({
        responseId,
        threadId: threadIdResult.value,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      });

      if (responseResult.isErr()) {
        logger.error({
          operation: "getLatestResponseByThreadId",
          threadId: threadId.val,
          responseId: responseId.val,
          error: responseResult.error,
          message: "Failed to create ReadResponse object",
        });
        return err(responseResult.error);
      }

      responses.push(responseResult.value);
    }

    // スレッドタイトルの取得とバリデーション
    const firstResponse = result[0];
    const threadTitleResult = createReadThreadTitle(firstResponse.title);
    if (threadTitleResult.isErr()) {
      logger.error({
        operation: "getLatestResponseByThreadId",
        threadId: threadId.val,
        threadTitle: firstResponse.title,
        error: threadTitleResult.error,
        message: "Failed to create thread title from database result",
      });
      return err(threadTitleResult.error);
    }

    const threadWithResponsesResult = createReadThreadWithResponses(
      threadIdResult.value,
      threadTitleResult.value,
      responses
    );

    if (threadWithResponsesResult.isErr()) {
      logger.error({
        operation: "getLatestResponseByThreadId",
        threadId: threadId.val,
        error: threadWithResponsesResult.error,
        message: "Failed to create thread with responses object",
      });
      return err(threadWithResponsesResult.error);
    }

    logger.info({
      operation: "getLatestResponseByThreadId",
      threadId: threadId.val,
      threadTitle: threadTitleResult.value.val,
      responseCount: responses.length,
      message: "Successfully fetched and processed latest responses for thread",
    });

    return ok(threadWithResponsesResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getLatestResponseByThreadId",
      threadId: threadId.val,
      error,
      message: `Database error while fetching responses: ${message}`,
    });
    return err(
      new DatabaseError(
        `最新レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getResponseByThreadIdAndResNumRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import {
  createReadThreadWithResponses,
  type ReadThreadWithResponses,
} from "../domain/read/ReadThreadWithResponses";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteResponseNumber } from "../domain/write/WriteResponseNumber";
import type { WriteThreadId } from "../domain/write/WriteThreadId";

// 指定されたスレッドの特定のレスポンス番号に対応するレスポンスを取得するリポジトリ
// 便宜上、スレッドタイトルも取得する
export const getResponseByThreadIdAndResNumRepository = async (
  { sql, logger }: VakContext,
  {
    threadId,
    responseNumber,
  }: {
    threadId: WriteThreadId;
    responseNumber: WriteResponseNumber;
  }
): Promise<
  Result<
    ReadThreadWithResponses,
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getResponseByThreadIdAndResNum",
    threadId: threadId.val,
    responseNumber: responseNumber.val,
    message: "Fetching specific response for thread",
  });

  try {
    const result = await sql<
      {
        id: string;
        thread_id: string;
        response_number: number;
        author_name: string;
        mail: string;
        posted_at: Date;
        response_content: string;
        hash_id: string;
        trip: string | null;
        title: string;
      }[]
    >`
          SELECT
              r.id,
              r.thread_id,
              r.response_number,
              r.author_name,
              r.mail,
              r.posted_at,
              r.response_content,
              r.hash_id,
              r.trip,
              t.title
          FROM
              responses as r
              JOIN
                  threads as t
              ON  r.thread_id = t.id
          WHERE
              r.thread_id = ${threadId.val}::uuid
              AND r.response_number = ${responseNumber.val}
          LIMIT 1
      `;

    if (!result || result.length !== 1) {
      logger.info({
        operation: "getResponseByThreadIdAndResNum",
        threadId: threadId.val,
        responseNumber: responseNumber.val,
        message:
          "Response not found for the given thread ID and response number",
      });
      return err(
        new DataNotFoundError("指定されたレスポンスの取得に失敗しました")
      );
    }

    logger.debug({
      operation: "getResponseByThreadIdAndResNum",
      threadId: threadId.val,
      responseNumber: responseNumber.val,
      message: "Successfully retrieved response from database",
    });

    // 詰め替え部分
    const response = result[0];

    // レスポンスの各フィールドのバリデーションと作成
    const combinedResult = Result.combine([
      createReadThreadId(response.thread_id),
      createReadThreadTitle(response.title),
      createReadResponseId(response.id),
      createReadResponseNumber(response.response_number),
      createReadAuthorName(response.author_name, response.trip),
      createReadMail(response.mail),
      createReadPostedAt(response.posted_at),
      createReadResponseContent(response.response_content),
      createReadHashId(response.hash_id),
    ]);

    if (combinedResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNum",
        threadId: threadId.val,
        responseNumber: responseNumber.val,
        responseId: response.id,
        error: combinedResult.error,
        message: "Failed to create domain objects from database result",
      });
      return err(combinedResult.error);
    }

    const [
      readThreadId,
      threadTitle,
      responseId,
      readResponseNumber,
      authorName,
      mail,
      postedAt,
      responseContent,
      hashId,
    ] = combinedResult.value;

    const responseResult = createReadResponse({
      responseId,
      threadId: readThreadId,
      responseNumber: readResponseNumber,
      authorName,
      mail,
      postedAt,
      responseContent,
      hashId,
    });

    if (responseResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNum",
        threadId: threadId.val,
        responseNumber: responseNumber.val,
        responseId: response.id,
        error: responseResult.error,
        message: "Failed to create ReadResponse object",
      });
      return err(responseResult.error);
    }

    // 単一のレスポンスを配列として渡す
    const responses: ReadResponse[] = [responseResult.value];

    const threadWithResponsesResult = createReadThreadWithResponses(
      readThreadId,
      threadTitle,
      responses
    );

    if (threadWithResponsesResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNum",
        threadId: threadId.val,
        responseNumber: responseNumber.val,
        error: threadWithResponsesResult.error,
        message: "Failed to create thread with responses object",
      });
      return err(threadWithResponsesResult.error);
    }

    logger.info({
      operation: "getResponseByThreadIdAndResNum",
      threadId: threadId.val,
      responseNumber: responseNumber.val,
      threadTitle: threadTitle.val,
      message:
        "Successfully fetched and processed specific response for thread",
    });

    return ok(threadWithResponsesResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getResponseByThreadIdAndResNum",
      threadId: threadId.val,
      responseNumber: responseNumber.val,
      error,
      message: `Database error while fetching response: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="app/routes/senbura/head.txt.tsx">
import { createRoute } from "honox/factory";

import { getBoardConfigUsecase } from "../../../src/config/usecases/getBoardConfigUsecase";
import { convertShiftJis } from "../../utils/convertShiftJis";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return convertShiftJis("DBに接続できませんでした");
  }
  const config = await getBoardConfigUsecase({ sql, logger });
  if (config.isErr()) {
    return convertShiftJis(`エラーが発生しました: ${config.error.message}`);
  }
  return convertShiftJis(config.value.localRule.val);
});
</file>

<file path="app/routes/threads/index.tsx">
import { createRoute } from "honox/factory";

import { postThreadUsecase } from "../../../src/conversation/usecases/postThreadUsecase";
import { ErrorMessage } from "../../components/ErrorMessage";
import { getIpAddress } from "../../utils/getIpAddress";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "threads/POST",
    path: c.req.path,
    method: c.req.method,
    message: "Starting new thread creation request"
  });

  const body = await c.req.parseBody();
  const title = body.title;
  const name = typeof body.name === "string" ? body.name : null;
  const mail = typeof body.mail === "string" ? body.mail : null;
  const content = body.content;

  logger.debug({
    operation: "threads/POST",
    hasTitle: typeof title === "string",
    hasContent: typeof content === "string",
    hasName: name !== null,
    hasMail: mail !== null,
    message: "Request body parsed for thread creation"
  });

  if (typeof title !== "string" || typeof content !== "string") {
    logger.warn({
      operation: "threads/POST",
      validationError: "Missing required fields",
      hasTitle: typeof title === "string",
      hasContent: typeof content === "string",
      message: "Thread creation validation failed - missing required fields"
    });
    return c.render(
      <ErrorMessage error={new Error("タイトルと本文は必須です")} />
    );
  }

  const ipAddressRaw = getIpAddress(c);
  
  logger.debug({
    operation: "threads/POST",
    ipAddress: ipAddressRaw,
    message: "IP address extracted for thread creation"
  });

  const postThreadResult = await postThreadUsecase(
    { sql, logger },
    {
      threadTitleRaw: title,
      authorNameRaw: name,
      mailRaw: mail,
      responseContentRaw: content,
      ipAddressRaw,
    }
  );
  if (postThreadResult.isErr()) {
    logger.error({
      operation: "threads/POST",
      error: postThreadResult.error,
      message: "Thread creation failed in usecase layer"
    });
    return c.render(<ErrorMessage error={postThreadResult.error} />);
  }
  const threadId = postThreadResult.value.val;
  
  logger.info({
    operation: "threads/POST",
    threadId,
    message: "Thread created successfully, redirecting to thread page"
  });
  
  return c.redirect(`/threads/${threadId}`, 303);
});

export default createRoute((c) => {
  const { logger } = c.var;
  
  logger.debug({
    operation: "threads/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Thread index page requested, redirecting to home page"
  });
  
  return c.redirect("/", 302);
});
</file>

<file path="db/schema.sql">
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA auth;


--
-- Name: extensions; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA extensions;


--
-- Name: graphql; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA graphql;


--
-- Name: graphql_public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA graphql_public;


--
-- Name: pgbouncer; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA pgbouncer;


--
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA realtime;


--
-- Name: storage; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA storage;


--
-- Name: vault; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA vault;


--
-- Name: pg_graphql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_graphql WITH SCHEMA graphql;


--
-- Name: EXTENSION pg_graphql; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION pg_graphql IS 'pg_graphql: GraphQL support';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION pg_stat_statements IS 'track planning and execution statistics of all SQL statements executed';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: pgjwt; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgjwt WITH SCHEMA extensions;


--
-- Name: EXTENSION pgjwt; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION pgjwt IS 'JSON Web Token API for Postgresql';


--
-- Name: supabase_vault; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS supabase_vault WITH SCHEMA vault;


--
-- Name: EXTENSION supabase_vault; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION supabase_vault IS 'Supabase Vault Extension';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: aal_level; Type: TYPE; Schema: auth; Owner: -
--

CREATE TYPE auth.aal_level AS ENUM (
    'aal1',
    'aal2',
    'aal3'
);


--
-- Name: code_challenge_method; Type: TYPE; Schema: auth; Owner: -
--

CREATE TYPE auth.code_challenge_method AS ENUM (
    's256',
    'plain'
);


--
-- Name: factor_status; Type: TYPE; Schema: auth; Owner: -
--

CREATE TYPE auth.factor_status AS ENUM (
    'unverified',
    'verified'
);


--
-- Name: factor_type; Type: TYPE; Schema: auth; Owner: -
--

CREATE TYPE auth.factor_type AS ENUM (
    'totp',
    'webauthn',
    'phone'
);


--
-- Name: one_time_token_type; Type: TYPE; Schema: auth; Owner: -
--

CREATE TYPE auth.one_time_token_type AS ENUM (
    'confirmation_token',
    'reauthentication_token',
    'recovery_token',
    'email_change_token_new',
    'email_change_token_current',
    'phone_change_token'
);


--
-- Name: action; Type: TYPE; Schema: realtime; Owner: -
--

CREATE TYPE realtime.action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE',
    'ERROR'
);


--
-- Name: equality_op; Type: TYPE; Schema: realtime; Owner: -
--

CREATE TYPE realtime.equality_op AS ENUM (
    'eq',
    'neq',
    'lt',
    'lte',
    'gt',
    'gte',
    'in'
);


--
-- Name: user_defined_filter; Type: TYPE; Schema: realtime; Owner: -
--

CREATE TYPE realtime.user_defined_filter AS (
	column_name text,
	op realtime.equality_op,
	value text
);


--
-- Name: wal_column; Type: TYPE; Schema: realtime; Owner: -
--

CREATE TYPE realtime.wal_column AS (
	name text,
	type_name text,
	type_oid oid,
	value jsonb,
	is_pkey boolean,
	is_selectable boolean
);


--
-- Name: wal_rls; Type: TYPE; Schema: realtime; Owner: -
--

CREATE TYPE realtime.wal_rls AS (
	wal jsonb,
	is_rls_enabled boolean,
	subscription_ids uuid[],
	errors text[]
);


--
-- Name: email(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.email() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$$;


--
-- Name: FUNCTION email(); Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON FUNCTION auth.email() IS 'Deprecated. Use auth.jwt() -> ''email'' instead.';


--
-- Name: jwt(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  select
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$$;


--
-- Name: role(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$$;


--
-- Name: FUNCTION role(); Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON FUNCTION auth.role() IS 'Deprecated. Use auth.jwt() -> ''role'' instead.';


--
-- Name: uid(); Type: FUNCTION; Schema: auth; Owner: -
--

CREATE FUNCTION auth.uid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  select
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid
$$;


--
-- Name: FUNCTION uid(); Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON FUNCTION auth.uid() IS 'Deprecated. Use auth.jwt() -> ''sub'' instead.';


--
-- Name: grant_pg_cron_access(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$$;


--
-- Name: FUNCTION grant_pg_cron_access(); Type: COMMENT; Schema: extensions; Owner: -
--

COMMENT ON FUNCTION extensions.grant_pg_cron_access() IS 'Grants access to pg_cron';


--
-- Name: grant_pg_graphql_access(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.grant_pg_graphql_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$_$;


--
-- Name: FUNCTION grant_pg_graphql_access(); Type: COMMENT; Schema: extensions; Owner: -
--

COMMENT ON FUNCTION extensions.grant_pg_graphql_access() IS 'Grants access to pg_graphql';


--
-- Name: grant_pg_net_access(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.grant_pg_net_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$$;


--
-- Name: FUNCTION grant_pg_net_access(); Type: COMMENT; Schema: extensions; Owner: -
--

COMMENT ON FUNCTION extensions.grant_pg_net_access() IS 'Grants access to pg_net';


--
-- Name: pgrst_ddl_watch(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


--
-- Name: pgrst_drop_watch(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


--
-- Name: set_graphql_placeholder(); Type: FUNCTION; Schema: extensions; Owner: -
--

CREATE FUNCTION extensions.set_graphql_placeholder() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$_$;


--
-- Name: FUNCTION set_graphql_placeholder(); Type: COMMENT; Schema: extensions; Owner: -
--

COMMENT ON FUNCTION extensions.set_graphql_placeholder() IS 'Reintroduces placeholder function for graphql_public.graphql';


--
-- Name: get_auth(text); Type: FUNCTION; Schema: pgbouncer; Owner: -
--

CREATE FUNCTION pgbouncer.get_auth(p_usename text) RETURNS TABLE(username text, password text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RAISE WARNING 'PgBouncer auth request: %', p_usename;

    RETURN QUERY
    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow
    WHERE usename = p_usename;
END;
$$;


--
-- Name: apply_rls(jsonb, integer); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)) RETURNS SETOF realtime.wal_rls
    LANGUAGE plpgsql
    AS $$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_;

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$$;


--
-- Name: broadcast_changes(text, text, text, text, text, record, record, text); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$$;


--
-- Name: build_prepared_statement_sql(text, regclass, realtime.wal_column[]); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) RETURNS text
    LANGUAGE sql
    AS $$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $$;


--
-- Name: cast(text, regtype); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime."cast"(val text, type_ regtype) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $$;


--
-- Name: check_equality_op(realtime.equality_op, regtype, text, text); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $$;


--
-- Name: is_visible_through_filters(realtime.wal_column[], realtime.user_defined_filter[]); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $_$;


--
-- Name: list_changes(name, name, integer, integer); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) RETURNS SETOF realtime.wal_rls
    LANGUAGE sql
    SET log_min_messages TO 'fatal'
    AS $$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $$;


--
-- Name: quote_wal2json(regclass); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.quote_wal2json(entity regclass) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $$;


--
-- Name: send(jsonb, text, text, boolean); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  BEGIN
    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (payload, event, topic, private, extension)
    VALUES (payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      PERFORM pg_notify(
          'realtime:system',
          jsonb_build_object(
              'error', SQLERRM,
              'function', 'realtime.send',
              'event', event,
              'topic', topic,
              'private', private
          )::text
      );
  END;
END;
$$;


--
-- Name: subscription_check_filters(); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.subscription_check_filters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $$;


--
-- Name: to_regrole(text); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.to_regrole(role_name text) RETURNS regrole
    LANGUAGE sql IMMUTABLE
    AS $$ select role_name::regrole $$;


--
-- Name: topic(); Type: FUNCTION; Schema: realtime; Owner: -
--

CREATE FUNCTION realtime.topic() RETURNS text
    LANGUAGE sql STABLE
    AS $$
select nullif(current_setting('realtime.topic', true), '')::text;
$$;


--
-- Name: can_insert_object(text, text, uuid, jsonb); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$$;


--
-- Name: extension(text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.extension(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
_filename text;
BEGIN
	select string_to_array(name, '/') into _parts;
	select _parts[array_length(_parts,1)] into _filename;
	-- @todo return the last part instead of 2
	return reverse(split_part(reverse(_filename), '.', 1));
END
$$;


--
-- Name: filename(text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.filename(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$$;


--
-- Name: foldername(text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.foldername(name text) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[1:array_length(_parts,1)-1];
END
$$;


--
-- Name: get_size_by_bucket(); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.get_size_by_bucket() RETURNS TABLE(size bigint, bucket_id text)
    LANGUAGE plpgsql
    AS $$
BEGIN
    return query
        select sum((metadata->>'size')::int) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$$;


--
-- Name: list_multipart_uploads_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text) RETURNS TABLE(key text, id text, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$_$;


--
-- Name: list_objects_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text) RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$_$;


--
-- Name: operation(); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.operation() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$$;


--
-- Name: search(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
  v_order_by text;
  v_sort_order text;
begin
  case
    when sortcolumn = 'name' then
      v_order_by = 'name';
    when sortcolumn = 'updated_at' then
      v_order_by = 'updated_at';
    when sortcolumn = 'created_at' then
      v_order_by = 'created_at';
    when sortcolumn = 'last_accessed_at' then
      v_order_by = 'last_accessed_at';
    else
      v_order_by = 'name';
  end case;

  case
    when sortorder = 'asc' then
      v_sort_order = 'asc';
    when sortorder = 'desc' then
      v_sort_order = 'desc';
    else
      v_sort_order = 'asc';
  end case;

  v_order_by = v_order_by || ' ' || v_sort_order;

  return query execute
    'with folders as (
       select path_tokens[$1] as folder
       from storage.objects
         where objects.name ilike $2 || $3 || ''%''
           and bucket_id = $4
           and array_length(objects.path_tokens, 1) <> $1
       group by folder
       order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: storage; Owner: -
--

CREATE FUNCTION storage.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: audit_log_entries; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.audit_log_entries (
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) DEFAULT ''::character varying NOT NULL
);


--
-- Name: TABLE audit_log_entries; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.audit_log_entries IS 'Auth: Audit trail for user actions.';


--
-- Name: flow_state; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.flow_state (
    id uuid NOT NULL,
    user_id uuid,
    auth_code text NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text NOT NULL,
    provider_type text NOT NULL,
    provider_access_token text,
    provider_refresh_token text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text NOT NULL,
    auth_code_issued_at timestamp with time zone
);


--
-- Name: TABLE flow_state; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.flow_state IS 'stores metadata for pkce logins';


--
-- Name: identities; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.identities (
    provider_id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


--
-- Name: TABLE identities; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';


--
-- Name: COLUMN identities.email; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.identities.email IS 'Auth: Email is a generated column that references the optional email property in the identity_data';


--
-- Name: instances; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.instances (
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);


--
-- Name: TABLE instances; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.instances IS 'Auth: Manages users across multiple sites.';


--
-- Name: mfa_amr_claims; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.mfa_amr_claims (
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text NOT NULL,
    id uuid NOT NULL
);


--
-- Name: TABLE mfa_amr_claims; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.mfa_amr_claims IS 'auth: stores authenticator method reference claims for multi factor authentication';


--
-- Name: mfa_challenges; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.mfa_challenges (
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text,
    web_authn_session_data jsonb
);


--
-- Name: TABLE mfa_challenges; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.mfa_challenges IS 'auth: stores metadata about challenge requests made';


--
-- Name: mfa_factors; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.mfa_factors (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text,
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text,
    phone text,
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid
);


--
-- Name: TABLE mfa_factors; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.mfa_factors IS 'auth: stores metadata about factors';


--
-- Name: one_time_tokens; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.one_time_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text NOT NULL,
    relates_to text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT one_time_tokens_token_hash_check CHECK ((char_length(token_hash) > 0))
);


--
-- Name: refresh_tokens; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL,
    token character varying(255),
    user_id character varying(255),
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255),
    session_id uuid
);


--
-- Name: TABLE refresh_tokens; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.refresh_tokens IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE; Schema: auth; Owner: -
--

CREATE SEQUENCE auth.refresh_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: auth; Owner: -
--

ALTER SEQUENCE auth.refresh_tokens_id_seq OWNED BY auth.refresh_tokens.id;


--
-- Name: saml_providers; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.saml_providers (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text NOT NULL,
    metadata_xml text NOT NULL,
    metadata_url text,
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text,
    CONSTRAINT "entity_id not empty" CHECK ((char_length(entity_id) > 0)),
    CONSTRAINT "metadata_url not empty" CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0))),
    CONSTRAINT "metadata_xml not empty" CHECK ((char_length(metadata_xml) > 0))
);


--
-- Name: TABLE saml_providers; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.saml_providers IS 'Auth: Manages SAML Identity Provider connections.';


--
-- Name: saml_relay_states; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.saml_relay_states (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text NOT NULL,
    for_email text,
    redirect_to text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT "request_id not empty" CHECK ((char_length(request_id) > 0))
);


--
-- Name: TABLE saml_relay_states; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.saml_relay_states IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';


--
-- Name: schema_migrations; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.schema_migrations (
    version character varying(255) NOT NULL
);


--
-- Name: TABLE schema_migrations; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.schema_migrations IS 'Auth: Manages updates to the auth system.';


--
-- Name: sessions; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text,
    ip inet,
    tag text
);


--
-- Name: TABLE sessions; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.sessions IS 'Auth: Stores session data associated to a user.';


--
-- Name: COLUMN sessions.not_after; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.sessions.not_after IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';


--
-- Name: sso_domains; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.sso_domains (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "domain not empty" CHECK ((char_length(domain) > 0))
);


--
-- Name: TABLE sso_domains; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.sso_domains IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';


--
-- Name: sso_providers; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.sso_providers (
    id uuid NOT NULL,
    resource_id text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "resource_id not empty" CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))
);


--
-- Name: TABLE sso_providers; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.sso_providers IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';


--
-- Name: COLUMN sso_providers.resource_id; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.sso_providers.resource_id IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';


--
-- Name: users; Type: TABLE; Schema: auth; Owner: -
--

CREATE TABLE auth.users (
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255),
    role character varying(255),
    email character varying(255),
    encrypted_password character varying(255),
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255),
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255),
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255),
    email_change character varying(255),
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text DEFAULT ''::character varying,
    phone_change_token character varying(255) DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean DEFAULT false NOT NULL,
    deleted_at timestamp with time zone,
    is_anonymous boolean DEFAULT false NOT NULL,
    CONSTRAINT users_email_change_confirm_status_check CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))
);


--
-- Name: TABLE users; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON TABLE auth.users IS 'Auth: Stores user login data within a secure schema.';


--
-- Name: COLUMN users.is_sso_user; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON COLUMN auth.users.is_sso_user IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';


--
-- Name: config; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.config (
    board_name text NOT NULL,
    local_rule text NOT NULL,
    nanashi_name text NOT NULL,
    max_content_length integer NOT NULL,
    admin_password text NOT NULL
);


--
-- Name: responses; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.responses (
    id uuid NOT NULL,
    thread_id uuid NOT NULL,
    response_number integer NOT NULL,
    author_name text NOT NULL,
    mail text NOT NULL,
    posted_at timestamp with time zone NOT NULL,
    response_content text NOT NULL,
    hash_id text NOT NULL,
    trip text
);


--
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.schema_migrations (
    version character varying(128) NOT NULL
);


--
-- Name: threads; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.threads (
    id uuid NOT NULL,
    title text NOT NULL,
    posted_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    epoch_id bigint NOT NULL
);


--
-- Name: messages; Type: TABLE; Schema: realtime; Owner: -
--

CREATE TABLE realtime.messages (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
)
PARTITION BY RANGE (inserted_at);


--
-- Name: schema_migrations; Type: TABLE; Schema: realtime; Owner: -
--

CREATE TABLE realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


--
-- Name: subscription; Type: TABLE; Schema: realtime; Owner: -
--

CREATE TABLE realtime.subscription (
    id bigint NOT NULL,
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] DEFAULT '{}'::realtime.user_defined_filter[] NOT NULL,
    claims jsonb NOT NULL,
    claims_role regrole GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED NOT NULL,
    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: realtime; Owner: -
--

ALTER TABLE realtime.subscription ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME realtime.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: buckets; Type: TABLE; Schema: storage; Owner: -
--

CREATE TABLE storage.buckets (
    id text NOT NULL,
    name text NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[],
    owner_id text
);


--
-- Name: COLUMN buckets.owner; Type: COMMENT; Schema: storage; Owner: -
--

COMMENT ON COLUMN storage.buckets.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: migrations; Type: TABLE; Schema: storage; Owner: -
--

CREATE TABLE storage.migrations (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    hash character varying(40) NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


--
-- Name: objects; Type: TABLE; Schema: storage; Owner: -
--

CREATE TABLE storage.objects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket_id text,
    name text,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text,
    owner_id text,
    user_metadata jsonb
);


--
-- Name: COLUMN objects.owner; Type: COMMENT; Schema: storage; Owner: -
--

COMMENT ON COLUMN storage.objects.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: s3_multipart_uploads; Type: TABLE; Schema: storage; Owner: -
--

CREATE TABLE storage.s3_multipart_uploads (
    id text NOT NULL,
    in_progress_size bigint DEFAULT 0 NOT NULL,
    upload_signature text NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    version text NOT NULL,
    owner_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_metadata jsonb
);


--
-- Name: s3_multipart_uploads_parts; Type: TABLE; Schema: storage; Owner: -
--

CREATE TABLE storage.s3_multipart_uploads_parts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    upload_id text NOT NULL,
    size bigint DEFAULT 0 NOT NULL,
    part_number integer NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    etag text NOT NULL,
    owner_id text,
    version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


--
-- Name: refresh_tokens id; Type: DEFAULT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.refresh_tokens ALTER COLUMN id SET DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass);


--
-- Name: mfa_amr_claims amr_id_pk; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT amr_id_pk PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: flow_state flow_state_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.flow_state
    ADD CONSTRAINT flow_state_pkey PRIMARY KEY (id);


--
-- Name: identities identities_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_pkey PRIMARY KEY (id);


--
-- Name: identities identities_provider_id_provider_unique; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider);


--
-- Name: instances instances_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.instances
    ADD CONSTRAINT instances_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_authentication_method_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method);


--
-- Name: mfa_challenges mfa_challenges_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id);


--
-- Name: mfa_factors mfa_factors_last_challenged_at_key; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at);


--
-- Name: mfa_factors mfa_factors_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_pkey PRIMARY KEY (id);


--
-- Name: one_time_tokens one_time_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_token_unique; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_token_unique UNIQUE (token);


--
-- Name: saml_providers saml_providers_entity_id_key; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id);


--
-- Name: saml_providers saml_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_pkey PRIMARY KEY (id);


--
-- Name: saml_relay_states saml_relay_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sso_domains sso_domains_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_pkey PRIMARY KEY (id);


--
-- Name: sso_providers sso_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.sso_providers
    ADD CONSTRAINT sso_providers_pkey PRIMARY KEY (id);


--
-- Name: users users_phone_key; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_phone_key UNIQUE (phone);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: config config_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.config
    ADD CONSTRAINT config_pkey PRIMARY KEY (board_name);


--
-- Name: responses responses_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.responses
    ADD CONSTRAINT responses_pkey PRIMARY KEY (id);


--
-- Name: responses responses_thread_id_response_number_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.responses
    ADD CONSTRAINT responses_thread_id_response_number_key UNIQUE (thread_id, response_number);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: threads threads_epoch_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.threads
    ADD CONSTRAINT threads_epoch_id_key UNIQUE (epoch_id);


--
-- Name: threads threads_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.threads
    ADD CONSTRAINT threads_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: realtime; Owner: -
--

ALTER TABLE ONLY realtime.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: subscription pk_subscription; Type: CONSTRAINT; Schema: realtime; Owner: -
--

ALTER TABLE ONLY realtime.subscription
    ADD CONSTRAINT pk_subscription PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: realtime; Owner: -
--

ALTER TABLE ONLY realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: buckets buckets_pkey; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.buckets
    ADD CONSTRAINT buckets_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_name_key; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


--
-- Name: objects objects_pkey; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT objects_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_pkey; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_pkey; Type: CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id);


--
-- Name: audit_logs_instance_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);


--
-- Name: confirmation_token_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_current_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_new_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text);


--
-- Name: factor_id_created_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at);


--
-- Name: flow_state_created_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);


--
-- Name: identities_email_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops);


--
-- Name: INDEX identities_email_idx; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON INDEX auth.identities_email_idx IS 'Auth: Ensures indexed queries on the email column';


--
-- Name: identities_user_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id);


--
-- Name: idx_auth_code; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code);


--
-- Name: idx_user_id_auth_method; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method);


--
-- Name: mfa_challenge_created_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);


--
-- Name: mfa_factors_user_friendly_name_unique; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text);


--
-- Name: mfa_factors_user_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id);


--
-- Name: one_time_tokens_relates_to_hash_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to);


--
-- Name: one_time_tokens_token_hash_hash_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash);


--
-- Name: one_time_tokens_user_id_token_type_key; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);


--
-- Name: reauthentication_token_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: recovery_token_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: refresh_tokens_instance_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);


--
-- Name: refresh_tokens_instance_id_user_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);


--
-- Name: refresh_tokens_parent_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent);


--
-- Name: refresh_tokens_session_id_revoked_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked);


--
-- Name: refresh_tokens_updated_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);


--
-- Name: saml_providers_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);


--
-- Name: saml_relay_states_created_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);


--
-- Name: saml_relay_states_for_email_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email);


--
-- Name: saml_relay_states_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id);


--
-- Name: sessions_not_after_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC);


--
-- Name: sessions_user_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id);


--
-- Name: sso_domains_domain_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));


--
-- Name: sso_domains_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id);


--
-- Name: sso_providers_resource_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id));


--
-- Name: unique_phone_factor_per_user; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone);


--
-- Name: user_id_created_at_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at);


--
-- Name: users_email_partial_key; Type: INDEX; Schema: auth; Owner: -
--

CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false);


--
-- Name: INDEX users_email_partial_key; Type: COMMENT; Schema: auth; Owner: -
--

COMMENT ON INDEX auth.users_email_partial_key IS 'Auth: A partial unique index that applies only when is_sso_user is false';


--
-- Name: users_instance_id_email_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text));


--
-- Name: users_instance_id_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);


--
-- Name: users_is_anonymous_idx; Type: INDEX; Schema: auth; Owner: -
--

CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);


--
-- Name: idx_responses_thread_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_responses_thread_id ON public.responses USING btree (thread_id);


--
-- Name: idx_responses_thread_id_response_number; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_responses_thread_id_response_number ON public.responses USING btree (thread_id, response_number);


--
-- Name: idx_threads_epoch_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_threads_epoch_id ON public.threads USING btree (epoch_id);


--
-- Name: idx_threads_updated_at; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_threads_updated_at ON public.threads USING btree (updated_at DESC);


--
-- Name: ix_realtime_subscription_entity; Type: INDEX; Schema: realtime; Owner: -
--

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity);


--
-- Name: subscription_subscription_id_entity_filters_key; Type: INDEX; Schema: realtime; Owner: -
--

CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_key ON realtime.subscription USING btree (subscription_id, entity, filters);


--
-- Name: bname; Type: INDEX; Schema: storage; Owner: -
--

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);


--
-- Name: bucketid_objname; Type: INDEX; Schema: storage; Owner: -
--

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name);


--
-- Name: idx_multipart_uploads_list; Type: INDEX; Schema: storage; Owner: -
--

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);


--
-- Name: idx_objects_bucket_id_name; Type: INDEX; Schema: storage; Owner: -
--

CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C");


--
-- Name: name_prefix_search; Type: INDEX; Schema: storage; Owner: -
--

CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops);


--
-- Name: subscription tr_check_filters; Type: TRIGGER; Schema: realtime; Owner: -
--

CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();


--
-- Name: objects update_objects_updated_at; Type: TRIGGER; Schema: storage; Owner: -
--

CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


--
-- Name: identities identities_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: mfa_challenges mfa_challenges_auth_factor_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE;


--
-- Name: mfa_factors mfa_factors_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: one_time_tokens one_time_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: refresh_tokens refresh_tokens_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: saml_providers saml_providers_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_flow_state_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: sso_domains sso_domains_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: -
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: objects objects_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_upload_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: -
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE;


--
-- Name: audit_log_entries; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.audit_log_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: flow_state; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.flow_state ENABLE ROW LEVEL SECURITY;

--
-- Name: identities; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

--
-- Name: instances; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.instances ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_amr_claims; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_challenges; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.mfa_challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_factors; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.mfa_factors ENABLE ROW LEVEL SECURITY;

--
-- Name: one_time_tokens; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.one_time_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: refresh_tokens; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_providers; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.saml_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_relay_states; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.saml_relay_states ENABLE ROW LEVEL SECURITY;

--
-- Name: schema_migrations; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.schema_migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: sessions; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_domains; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.sso_domains ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_providers; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.sso_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: auth; Owner: -
--

ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

--
-- Name: messages; Type: ROW SECURITY; Schema: realtime; Owner: -
--

ALTER TABLE realtime.messages ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets; Type: ROW SECURITY; Schema: storage; Owner: -
--

ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;

--
-- Name: migrations; Type: ROW SECURITY; Schema: storage; Owner: -
--

ALTER TABLE storage.migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: objects; Type: ROW SECURITY; Schema: storage; Owner: -
--

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads; Type: ROW SECURITY; Schema: storage; Owner: -
--

ALTER TABLE storage.s3_multipart_uploads ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads_parts; Type: ROW SECURITY; Schema: storage; Owner: -
--

ALTER TABLE storage.s3_multipart_uploads_parts ENABLE ROW LEVEL SECURITY;

--
-- Name: supabase_realtime; Type: PUBLICATION; Schema: -; Owner: -
--

CREATE PUBLICATION supabase_realtime WITH (publish = 'insert, update, delete, truncate');


--
-- Name: issue_graphql_placeholder; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop
         WHEN TAG IN ('DROP EXTENSION')
   EXECUTE FUNCTION extensions.set_graphql_placeholder();


--
-- Name: issue_pg_cron_access; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_cron_access();


--
-- Name: issue_pg_graphql_access; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end
         WHEN TAG IN ('CREATE FUNCTION')
   EXECUTE FUNCTION extensions.grant_pg_graphql_access();


--
-- Name: issue_pg_net_access; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_net_access();


--
-- Name: pgrst_ddl_watch; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER pgrst_ddl_watch ON ddl_command_end
   EXECUTE FUNCTION extensions.pgrst_ddl_watch();


--
-- Name: pgrst_drop_watch; Type: EVENT TRIGGER; Schema: -; Owner: -
--

CREATE EVENT TRIGGER pgrst_drop_watch ON sql_drop
   EXECUTE FUNCTION extensions.pgrst_drop_watch();


--
-- PostgreSQL database dump complete
--


--
-- Dbmate schema migrations
--

INSERT INTO public.schema_migrations (version) VALUES
    ('20240629000000');
</file>

<file path="src/config/repositories/getBoardConfigRepository.ts">
import { err, ok } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import {
  createReadBoardConfig,
  type ReadBoardConfig,
} from "../domain/read/ReadBoardConfig";
import { createReadBoardName } from "../domain/read/ReadBoardName";
import { createReadLocalRule } from "../domain/read/ReadLocalRule";

import type { VakContext } from "../../shared/types/VakContext";
import type { Result } from "neverthrow";

export const getBoardConfigRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadBoardConfig, DatabaseError | DataNotFoundError>
> => {
  logger.debug({
    operation: "getBoardConfig",
    message: "Fetching board configuration from database",
  });

  try {
    const result = await sql<{ board_name: string; local_rule: string }[]>`
          SELECT board_name, local_rule FROM config LIMIT 1
        `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "getBoardConfig",
        message:
          "Failed to retrieve board configuration, invalid database response",
      });
      return err(new DataNotFoundError("設定の取得に失敗しました"));
    }

    logger.debug({
      operation: "getBoardConfig",
      boardName: result[0].board_name,
      message: "Board configuration retrieved successfully",
    });

    const boardNameResult = createReadBoardName(result[0].board_name);
    if (boardNameResult.isErr()) {
      logger.error({
        operation: "getBoardConfig",
        error: boardNameResult.error,
        message: "Invalid board name format",
      });
      return err(boardNameResult.error);
    }
    const localRuleResult = createReadLocalRule(result[0].local_rule);
    if (localRuleResult.isErr()) {
      logger.error({
        operation: "getBoardConfig",
        error: localRuleResult.error,
        message: "Invalid local rule format",
      });
      return err(localRuleResult.error);
    }

    // 適当に詰め替え・とりあえず適当に
    const config = createReadBoardConfig({
      boardName: boardNameResult.value,
      localRule: localRuleResult.value,
    });
    if (config.isErr()) {
      logger.error({
        operation: "getBoardConfig",
        error: config.error,
        message: "Failed to create board config object",
      });
      return err(config.error);
    }

    logger.info({
      operation: "getBoardConfig",
      boardName: boardNameResult.value.val,
      message: "Board configuration retrieved and validated successfully",
    });

    return ok(config.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getBoardConfig",
      error,
      message: `Database error while fetching board configuration: ${message}`,
    });
    return err(
      new DatabaseError(`設定取得中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/getDefaultAuthorNameRepository.ts">
import { err, ok } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import {
  createReadDefaultAuthorName,
  type ReadDefaultAuthorName,
} from "../domain/read/ReadDefaultAuthorName";

import type { VakContext } from "../../shared/types/VakContext";
import type { Result } from "neverthrow";

export const getDefaultAuthorNameRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadDefaultAuthorName, DatabaseError | DataNotFoundError>
> => {
  logger.debug({
    operation: "getDefaultAuthorName",
    message: "Fetching default author name from database",
  });

  try {
    const result = await sql<{ nanashi_name: string }[]>`
        SELECT nanashi_name FROM config LIMIT 1
      `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "getDefaultAuthorName",
        message:
          "Failed to retrieve default author name, invalid database response",
      });
      return err(new DataNotFoundError("設定の取得に失敗しました"));
    }

    logger.debug({
      operation: "getDefaultAuthorName",
      defaultAuthorName: result[0].nanashi_name,
      message: "Default author name retrieved from database",
    });

    const defaultAuthorNameResult = createReadDefaultAuthorName(
      result[0].nanashi_name
    );
    if (defaultAuthorNameResult.isErr()) {
      logger.error({
        operation: "getDefaultAuthorName",
        error: defaultAuthorNameResult.error,
        message: "Invalid default author name format",
      });
      return err(defaultAuthorNameResult.error);
    }

    logger.info({
      operation: "getDefaultAuthorName",
      defaultAuthorName: defaultAuthorNameResult.value.val,
      message: "Default author name retrieved and validated successfully",
    });

    return ok(defaultAuthorNameResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getDefaultAuthorName",
      error,
      message: `Database error while fetching default author name: ${message}`,
    });
    return err(
      new DatabaseError(`設定取得中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/getMaxContentLengthRepository.ts">
import { err, ok } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import {
  createReadMaxContentLength,
  type ReadMaxContentLength,
} from "../domain/read/ReadMaxContentLength";

import type { VakContext } from "../../shared/types/VakContext";
import type { Result } from "neverthrow";

export const getMaxContentLengthRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadMaxContentLength, DatabaseError | DataNotFoundError>
> => {
  logger.debug({
    operation: "getMaxContentLength",
    message: "Fetching maximum content length from database",
  });

  try {
    const result = await sql<{ max_content_length: number }[]>`
        SELECT max_content_length FROM config LIMIT 1
      `;
    if (!result || result.length !== 1) {
      logger.error({
        operation: "getMaxContentLength",
        message:
          "Failed to retrieve maximum content length, invalid database response",
      });
      return err(new DataNotFoundError("設定の取得に失敗しました"));
    }

    logger.debug({
      operation: "getMaxContentLength",
      maxContentLength: result[0].max_content_length,
      message: "Maximum content length retrieved from database",
    });

    const maxContentLengthResult = createReadMaxContentLength(
      result[0].max_content_length
    );
    if (maxContentLengthResult.isErr()) {
      logger.error({
        operation: "getMaxContentLength",
        error: maxContentLengthResult.error,
        message: "Invalid maximum content length format",
      });
      return err(maxContentLengthResult.error);
    }

    logger.info({
      operation: "getMaxContentLength",
      maxContentLength: maxContentLengthResult.value.val,
      message: "Maximum content length retrieved and validated successfully",
    });

    return ok(maxContentLengthResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getMaxContentLength",
      error,
      message: `Database error while fetching maximum content length: ${message}`,
    });
    return err(
      new DatabaseError(`設定取得中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/getNormalConfigRepository.ts">
import { err, ok } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";
import { createReadBoardName } from "../domain/read/ReadBoardName";
import { createReadDefaultAuthorName } from "../domain/read/ReadDefaultAuthorName";
import { createReadLocalRule } from "../domain/read/ReadLocalRule";
import { createReadMaxContentLength } from "../domain/read/ReadMaxContentLength";
import {
  createReadNormalConfig,
  type ReadNormalConfig,
} from "../domain/read/ReadNormalConfig";

import type { VakContext } from "../../shared/types/VakContext";

export const getNormalConfigRepository = async ({
  sql,
  logger,
}: VakContext): Promise<Result<ReadNormalConfig, DatabaseError>> => {
  logger.debug({
    operation: "getNormalConfig",
    message: "Fetching board configuration from database",
  });

  try {
    const result = await sql<
      {
        board_name: string;
        local_rule: string;
        nanashi_name: string;
        max_content_length: number;
      }[]
    >`
            SELECT
                board_name,
                local_rule,
                nanashi_name,
                max_content_length
            FROM
                config
        `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "getNormalConfig",
        message: "Failed to retrieve configuration, invalid database response",
      });
      return err(new DatabaseError("設定の取得に失敗しました"));
    }

    logger.debug({
      operation: "getNormalConfig",
      boardName: result[0].board_name,
      maxContentLength: result[0].max_content_length,
      message: "Configuration data retrieved from database",
    });

    const combinedResult = Result.combine([
      createReadBoardName(result[0].board_name),
      createReadLocalRule(result[0].local_rule),
      createReadDefaultAuthorName(result[0].nanashi_name),
      createReadMaxContentLength(result[0].max_content_length),
    ]);

    if (combinedResult.isErr()) {
      logger.error({
        operation: "getNormalConfig",
        error: combinedResult.error,
        message: "Failed to create domain objects from database result",
      });
      return err(combinedResult.error);
    }

    const [boardName, localRule, defaultAuthorName, maxContentLength] =
      combinedResult.value;

    const normalConfigResult = createReadNormalConfig({
      boardName,
      localRule,
      defaultAuthorName,
      maxContentLength,
    });

    if (normalConfigResult.isErr()) {
      logger.error({
        operation: "getNormalConfig",
        error: normalConfigResult.error,
        message: "Failed to create ReadNormalConfig object",
      });
      return err(normalConfigResult.error);
    }

    logger.info({
      operation: "getNormalConfig",
      boardName: boardName.val,
      message: "Configuration retrieved successfully",
    });

    return ok(normalConfigResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getNormalConfig",
      error,
      message: `Database error while retrieving configuration: ${message}`,
    });
    return err(
      new DatabaseError(`設定の取得中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/getPasswordHashRepository.ts">
import { err, ok } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import {
  createReadPasswordHash,
  type ReadPasswordHash,
} from "../domain/read/ReadPasswordHash";

import type { VakContext } from "../../shared/types/VakContext";
import type { Result } from "neverthrow";

export const getPasswordHashRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadPasswordHash, DatabaseError | DataNotFoundError>
> => {
  logger.debug({
    operation: "getPasswordHash",
    message: "Fetching admin password hash from database",
  });

  try {
    const result = await sql<{ admin_password: string }[]>`
        SELECT admin_password FROM config LIMIT 1
      `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "getPasswordHash",
        message:
          "Failed to retrieve admin password hash, invalid database response",
      });
      return err(new DataNotFoundError("設定の取得に失敗しました"));
    }

    logger.debug({
      operation: "getPasswordHash",
      message: "Admin password hash retrieved from database",
    });

    const adminPassword = result[0].admin_password;

    const passwordHashResult = createReadPasswordHash(adminPassword);
    if (passwordHashResult.isErr()) {
      logger.error({
        operation: "getPasswordHash",
        error: passwordHashResult.error,
        message: "Invalid password hash format",
      });
      return err(passwordHashResult.error);
    }

    logger.info({
      operation: "getPasswordHash",
      message: "Admin password hash retrieved and validated successfully",
    });

    return ok(passwordHashResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getPasswordHash",
      error,
      message: `Database error while fetching admin password hash: ${message}`,
    });
    return err(
      new DatabaseError(`設定取得中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/updateNormalConfigRepository.ts">
import { ok, err } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";

import type { VakContext } from "../../shared/types/VakContext";
import type { WriteNormalConfig } from "../domain/write/WriteNormalConfig";
import type { Result } from "neverthrow";

export const updateNormalConfigRepository = async (
  { sql, logger }: VakContext,
  config: WriteNormalConfig
): Promise<Result<undefined, Error>> => {
  const { boardName, localRule, defaultAuthorName, maxContentLength } = config;

  logger.debug({
    operation: "updateNormalConfig",
    boardName: boardName.val,
    defaultAuthorName: defaultAuthorName.val,
    maxContentLength: maxContentLength.val,
    message: "Updating configuration in database",
  });

  try {
    await sql`
            UPDATE
                config
            SET
                board_name = ${boardName.val},
                local_rule = ${localRule.val},
                nanashi_name = ${defaultAuthorName.val},
                max_content_length = ${maxContentLength.val}
        `;

    logger.info({
      operation: "updateNormalConfig",
      boardName: boardName.val,
      message: "Configuration updated successfully in database",
    });

    return ok(undefined);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "updateNormalConfig",
      error,
      message: `Database error while updating configuration: ${message}`,
    });
    return err(
      new DatabaseError(`設定の更新中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/config/repositories/updatePasswordHashRepository.ts">
import { ok, err } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";

import type { VakContext } from "../../shared/types/VakContext";
import type { WritePasswordHash } from "../domain/write/WritePasswordHash";
import type { Result } from "neverthrow";

export const updatePasswordHashRepository = async (
  { sql, logger }: VakContext,
  passwordHash: WritePasswordHash
): Promise<Result<undefined, Error>> => {
  logger.debug({
    operation: "updatePasswordHash",
    message: "Updating admin password hash in database",
  });

  try {
    await sql`
    UPDATE
        config
    SET
        admin_password = ${passwordHash.val}
    `;

    logger.info({
      operation: "updatePasswordHash",
      message: "Admin password hash updated successfully",
    });

    return ok(undefined);
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "updatePasswordHash",
      error,
      message: `Database error while updating password hash: ${message}`,
    });
    return err(
      new DatabaseError(
        `パスワード更新中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/domain/write/WriteMail.ts">
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../../shared/types/Error";

import type { ReadMail } from "../read/ReadMail";

// メールアドレス
export type WriteMail = {
  readonly _type: "WriteMail";
  readonly val: string;
};

// https://zenn.dev/igz0/articles/email-validation-regex-best-practices
const regexMail =
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

export const createWriteMail = (
  value: string | null
): Result<WriteMail, ValidationError> => {
  if (value === null) {
    return ok({ _type: "WriteMail", val: "" });
  }
  if (value.length > 255) {
    return err(new ValidationError("メールアドレスは255文字以内です"));
  }
  // 簡単なメールアドレス形式チェック (厳密なものではない)
  if (
    value !== "" &&
    value.toLowerCase() !== "sage" &&
    !regexMail.test(value)
  ) {
    return err(new ValidationError("不正なメールアドレス形式です"));
  }
  return ok({ _type: "WriteMail", val: value });
};

// メールアドレスの内容がsageかどうかを判定する関数
export const isSage = (mail: WriteMail | ReadMail): boolean => {
  return mail.val.toLowerCase() === "sage";
};
</file>

<file path="src/conversation/repositories/createThreadRepository.ts">
import { ok, err } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";
import {
  createReadThreadId,
  type ReadThreadId,
} from "../domain/read/ReadThreadId";

import type { VakContext } from "../../shared/types/VakContext";
import type { WriteThread } from "../domain/write/WriteThread";
import type { Result } from "neverthrow";

// スレッドを作成するリポジトリ
export const createThreadRepository = async (
  { sql, logger }: VakContext,
  thread: WriteThread
): Promise<Result<ReadThreadId, DatabaseError>> => {
  logger.debug({
    operation: "createThread",
    threadId: thread.id.val,
    threadTitle: thread.title.val,
    message: "Creating new thread in database",
  });

  try {
    const result = await sql<{ id: string }[]>`
          INSERT INTO threads(
              id,
              title,
              posted_at,
              updated_at,
              epoch_id
          )
          VALUES(
              ${thread.id.val}::uuid,
              ${thread.title.val},
              ${thread.postedAt.val},
              ${thread.updatedAt.val},
              ${thread.epochId.val}
          ) RETURNING id
      `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "createThread",
        threadId: thread.id.val,
        message: "Failed to create thread, invalid database response",
      });
      return err(new DatabaseError("スレッドの作成に失敗しました"));
    }

    const threadIdResult = createReadThreadId(result[0].id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "createThread",
        error: threadIdResult.error,
        threadId: thread.id.val,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }

    logger.info({
      operation: "createThread",
      threadId: thread.id.val,
      threadTitle: thread.title.val,
      message: "Thread created successfully",
    });

    return ok(threadIdResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "createThread",
      error,
      threadId: thread.id.val,
      message: `Database error while creating thread: ${message}`,
    });
    return err(
      new DatabaseError(`データベースエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/conversation/repositories/getResponseByThreadIdAndResNumRangeRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import {
  createReadThreadWithResponses,
  type ReadThreadWithResponses,
} from "../domain/read/ReadThreadWithResponses";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteResponseNumber } from "../domain/write/WriteResponseNumber";
import type { WriteThreadId } from "../domain/write/WriteThreadId";

// 指定されたスレッドの指定された範囲のレスポンスを取得するリポジトリ
// 便宜上、スレッドタイトルも取得する
export const getResponseByThreadIdAndResNumRangeRepository = async (
  { sql, logger }: VakContext,
  {
    threadId,
    startResponseNumber,
    endResponseNumber,
  }: {
    threadId: WriteThreadId;
    startResponseNumber: WriteResponseNumber | null;
    endResponseNumber: WriteResponseNumber | null;
  }
): Promise<
  Result<
    ReadThreadWithResponses,
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getResponseByThreadIdAndResNumRange",
    threadId: threadId.val,
    startResponseNumber: startResponseNumber?.val ?? "NULL",
    endResponseNumber: endResponseNumber?.val ?? "NULL",
    message: "Fetching responses in range for thread",
  });

  // とりあえずnullならダミー
  const startNumRaw = startResponseNumber?.val ?? 0;
  const endNumRaw = endResponseNumber?.val ?? 10000000;
  const isStartNumNull = startResponseNumber === null;
  const isEndNumNull = endResponseNumber === null;

  try {
    const result = await sql<
      {
        id: string;
        thread_id: string;
        response_number: number;
        author_name: string;
        mail: string;
        posted_at: Date;
        response_content: string;
        hash_id: string;
        trip: string | null;
        title: string;
      }[]
    >`
          SELECT
              r.id,
              r.thread_id,
              r.response_number,
              r.author_name,
              r.mail,
              r.posted_at,
              r.response_content,
              r.hash_id,
              r.trip,
              t.title
          FROM
              responses as r
              JOIN
                  threads as t
              ON  r.thread_id = t.id
          WHERE
            r.thread_id = ${threadId.val}::uuid
            AND (
                -- 範囲指定された場合
                (
                    (${isStartNumNull} OR r.response_number >= ${startNumRaw})
                    AND
                    (${isEndNumNull} OR r.response_number <= ${endNumRaw})
                )
                -- または、レス番号1のレスポンスを取得する条件
                OR r.response_number = 1
            )
          ORDER BY
              r.response_number
      `;

    if (!result || result.length === 0) {
      logger.info({
        operation: "getResponseByThreadIdAndResNumRange",
        threadId: threadId.val,
        startResponseNumber: startResponseNumber?.val ?? "NULL",
        endResponseNumber: endResponseNumber?.val ?? "NULL",
        message: "No responses found for thread within specified range",
      });
      return err(
        new DataNotFoundError("指定された範囲のレスポンスの取得に失敗しました")
      );
    }

    logger.debug({
      operation: "getResponseByThreadIdAndResNumRange",
      threadId: threadId.val,
      responseCount: result.length,
      message: "Successfully retrieved responses from database",
    });

    // 詰め替え部分
    // すべての投稿でスレッドIDは共通なので、最初のレスポンスから取得
    const threadIdResult = createReadThreadId(result[0].thread_id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNumRange",
        threadId: threadId.val,
        error: threadIdResult.error,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }

    const responses: ReadResponse[] = [];
    for (const response of result) {
      const combinedResult = Result.combine([
        createReadResponseId(response.id),
        createReadResponseNumber(response.response_number),
        createReadAuthorName(response.author_name, response.trip),
        createReadMail(response.mail),
        createReadPostedAt(response.posted_at),
        createReadResponseContent(response.response_content),
        createReadHashId(response.hash_id),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getResponseByThreadIdAndResNumRange",
          threadId: threadId.val,
          responseId: response.id,
          error: combinedResult.error,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }

      const [
        responseId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      ] = combinedResult.value;

      const responseResult = createReadResponse({
        responseId,
        threadId: threadIdResult.value,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      });

      if (responseResult.isErr()) {
        logger.error({
          operation: "getResponseByThreadIdAndResNumRange",
          threadId: threadId.val,
          responseId: responseId.val,
          error: responseResult.error,
          message: "Failed to create ReadResponse object",
        });
        return err(responseResult.error);
      }

      responses.push(responseResult.value);
    }

    // スレッドタイトルの取得とバリデーション
    const firstResponse = result[0];
    const threadTitleResult = createReadThreadTitle(firstResponse.title);
    if (threadTitleResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNumRange",
        threadId: threadId.val,
        threadTitle: firstResponse.title,
        error: threadTitleResult.error,
        message: "Failed to create thread title from database result",
      });
      return err(threadTitleResult.error);
    }

    const threadWithResponsesResult = createReadThreadWithResponses(
      threadIdResult.value,
      threadTitleResult.value,
      responses
    );

    if (threadWithResponsesResult.isErr()) {
      logger.error({
        operation: "getResponseByThreadIdAndResNumRange",
        threadId: threadId.val,
        error: threadWithResponsesResult.error,
        message: "Failed to create thread with responses object",
      });
      return err(threadWithResponsesResult.error);
    }

    logger.info({
      operation: "getResponseByThreadIdAndResNumRange",
      threadId: threadId.val,
      threadTitle: threadTitleResult.value.val,
      responseCount: responses.length,
      startResponseNumber: startResponseNumber?.val ?? "NULL",
      endResponseNumber: endResponseNumber?.val ?? "NULL",
      message:
        "Successfully fetched and processed responses in range for thread",
    });

    return ok(threadWithResponsesResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getResponseByThreadIdAndResNumRange",
      threadId: threadId.val,
      startResponseNumber: startResponseNumber?.val ?? "NULL",
      endResponseNumber: endResponseNumber?.val ?? "NULL",
      error,
      message: `Database error while fetching responses: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="app/components/ResponseContent.tsx">
import type { ReadResponseContent } from "../../src/conversation/domain/read/ReadResponseContent";
import type { ReadThreadId } from "../../src/conversation/domain/read/ReadThreadId";
import type { FC } from "hono/jsx";
import type { JSX } from "hono/jsx/jsx-runtime"; // JSX要素の型定義のために追加

// --- Helper Functions ---

// エスケープ文字と対応するプレースホルダーのマッピング
// Note: プレースホルダーは実際のテキストと衝突しにくいユニークなものにする
const escapeMap: Readonly<Record<string, string>> = {
  "\\```": "__ESC_BACKTICK__", // Note: コードブロックの開始/終了自体をエスケープする場合
  "\\***": "__ESC_BOLD__",
  "\\~~~": "__ESC_STRIKE__",
  "\\>>": "__ESC_ANCHOR_PREFIX__", // >>自体をエスケープする場合
  "\\http://": "__ESC_HTTP__", // URLのエスケープ
  "\\https://": "__ESC_HTTPS__", // URLのエスケープ
};
// Note: キーの長さが違うため、長いものからマッチさせる必要がある正規表現
// 引用処理を削除したため、 \> のエスケープは不要になった
const escapeRegex = /(\\```|\\\*\*\*|\\~~~|\\>>|\\https?:\/\/)/g;

// プレースホルダーから元の文字（エスケープ文字なし）に戻すマッピング
const unescapeMap = Object.fromEntries(
  Object.entries(escapeMap).map(([key, value]) => [value, key.substring(1)]) // 先頭の \ を削除
);
const unescapeRegex = new RegExp(Object.keys(unescapeMap).join("|"), "g");

// Markdownのエスケープ文字をプレースホルダーに置換する関数
const escapeMarkdown = (text: string): string => {
  // \\ のエスケープを最初に行う（他のエスケープ処理で \ が消費されないように）
  let escapedText = text.replace(/\\\\/g, "__ESC_BACKSLASH__");
  // 他のエスケープ対象を置換
  escapedText = escapedText.replace(
    escapeRegex,
    (match) => escapeMap[match] || match
  );
  return escapedText;
};

// プレースホルダーを元の文字に戻す関数 (JSX要素はそのまま返す)
const unescapeResult = (part: string | JSX.Element): string | JSX.Element => {
  if (typeof part === "string") {
    let unescapedText = part.replace(
      unescapeRegex,
      (match) => unescapeMap[match] || match
    );
    // 最後にバックスラッシュを戻す
    unescapedText = unescapedText.replace(/__ESC_BACKSLASH__/g, "\\");
    return unescapedText;
  }
  return part;
};

// --- Inline Decoration Processing ---

// 太字 (***) と 取り消し線 (~~~) を処理する関数
const processInlineDecorations = (text: string): (string | JSX.Element)[] => {
  const parts: (string | JSX.Element)[] = [];
  let lastIndex = 0;
  // 正規表現: ***...*** または ~~~...~~~ (non-greedy)
  // Note: エスケープされたものはプレースホルダーになっている想定
  const inlineRegex = /(\*\*\*(.*?)\*\*\*)|(~~~(.*?)~~~)/g;
  let match;

  while ((match = inlineRegex.exec(text)) !== null) {
    // マッチ前のテキストを追加
    if (match.index > lastIndex) {
      parts.push(text.substring(lastIndex, match.index));
    }

    // マッチ内容に応じてJSX要素を追加
    if (match[1]) {
      // ***...*** (太字)
      // 中身はプレーンテキストとして扱う (再帰パースしない)
      parts.push(
        <strong key={`strong-${match.index}`} className="font-black">
          {match[2]}
        </strong>
      );
    } else if (match[3]) {
      // ~~~...~~~ (取り消し線)
      parts.push(<s key={`s-${match.index}`}>{match[4]}</s>);
    }
    lastIndex = inlineRegex.lastIndex; // lastIndex を更新
  }

  // 最後のマッチ以降のテキストを追加
  if (lastIndex < text.length) {
    parts.push(text.substring(lastIndex));
  }

  // 何もマッチしなかった場合は元のテキストを配列で返す
  return parts.length === 0 && lastIndex === 0 ? [text] : parts;
};

// --- ResponseLineComponent ---

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ResponseLineComponent: FC<{
  line: string;
  threadId: ReadThreadId;
}> = ({ line, threadId }) => {
  // 1. エスケープ処理 (\記号をプレースホルダーに)
  const escapedLine = escapeMarkdown(line);

  // 2. 引用処理 (>記号) は削除。contentLineはエスケープ後の行をそのまま使用。
  const contentLine = escapedLine;

  // 3. レスアンカー (>>数字) と URL の処理
  //    正規表現: >>数字 または URL (エスケープされていないもの)
  //    エスケープ処理済みなので、プレースホルダーはマッチしない
  const linkRegex = />>(\d+)|(https?:\/\/[^\s<>"']+)/g;
  const linkParts: (string | JSX.Element)[] = [];
  let lastIndex = 0;
  let match;

  while ((match = linkRegex.exec(contentLine)) !== null) {
    // マッチ前のテキストを追加
    if (match.index > lastIndex) {
      linkParts.push(contentLine.substring(lastIndex, match.index));
    }

    // マッチ内容に応じてリンクを生成
    if (match[1]) {
      // >>数字 (レスアンカー)
      linkParts.push(
        <a
          key={`anchor-${match.index}`}
          className="text-blue-500 hover:underline"
          href={`#${threadId.val}-${match[1]}`}
        >
          {`>>${match[1]}`}
        </a>
      );
    } else if (match[2]) {
      // URL
      const url = match[2];
      linkParts.push(
        <a
          key={`url-${match.index}`}
          className="text-blue-500 hover:underline"
          href={url}
          target="_blank"
          rel="noopener noreferrer"
        >
          {url}
        </a>
      );
    }
    lastIndex = linkRegex.lastIndex; // lastIndex を更新
  }

  // 最後のマッチ以降のテキストを追加
  if (lastIndex < contentLine.length) {
    linkParts.push(contentLine.substring(lastIndex));
  }

  // 4. 行内装飾 (太字、取り消し線) の処理
  const decoratedParts = linkParts.flatMap(
    (part) =>
      typeof part === "string" ? processInlineDecorations(part) : [part] // 文字列なら装飾処理、JSXならそのまま
  );

  // 5. エスケープ文字の復元 (プレースホルダーを元の文字に)
  const finalParts = decoratedParts.map(unescapeResult);

  // 6. 最終的なJSXを返す (引用装飾は削除)
  //    行ごとのラッパーdivは ResponseContentComponent 側で追加するため、Fragment で返す
  return <>{finalParts}</>;
};

// --- ResponseContentComponent ---

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ResponseContentComponent: FC<{
  threadId: ReadThreadId;
  responseContent: ReadResponseContent;
}> = ({ threadId, responseContent }) => {
  const lines = responseContent.val.split("\n");
  const resultComponents: JSX.Element[] = [];
  let inCodeBlock = false;
  let codeBlockLines: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    // エスケープされた ``` は無視する
    const trimmedLine = line.trim();
    const isCodeBlockFence =
      trimmedLine === "```" && !line.trimStart().startsWith("\\```");

    if (isCodeBlockFence) {
      if (inCodeBlock) {
        // コードブロック終了
        // 空のコードブロックは無視しない（ ``` ``` の場合）
        resultComponents.push(
          <pre
            key={`code-${i}`}
            className="bg-gray-200 p-2 rounded overflow-x-auto"
          >
            <code className="text-sm">{codeBlockLines.join("\n")}</code>
          </pre>
        );
        codeBlockLines = []; // クリア
        inCodeBlock = false;
      } else {
        // コードブロック開始
        inCodeBlock = true;
      }
    } else {
      if (inCodeBlock) {
        // コードブロック内の行を追加
        // Note: コードブロック内はエスケープも Markdown パースもせず、生の line を使うのが正しい。
        codeBlockLines.push(line);
      } else {
        // 通常の行 -> ResponseLineComponent で処理
        resultComponents.push(
          // 各行を div でラップして、改行を表現しつつ block 要素とする
          <div key={i}>
            <ResponseLineComponent line={line} threadId={threadId} />
          </div>
        );
      }
    }
  }

  // ループ終了時にコードブロックが閉じられていない場合
  if (inCodeBlock) {
    resultComponents.push(
      <pre
        key={`code-final`}
        className="bg-gray-200 p-2 rounded overflow-x-auto"
      >
        <code className="text-sm">{codeBlockLines.join("\n")}</code>
      </pre>
    );
  }

  return <div>{resultComponents}</div>;
};
</file>

<file path="app/routes/login/admin.tsx">
import { env } from "hono/adapter";
import { setCookie } from "hono/cookie";
import { sign } from "hono/jwt";
import { createRoute } from "honox/factory";

import { verifyAdminPasswordUsecase } from "../../../src/config/usecases/verifyAdminPasswordUsecase";
import { ValidationError } from "../../../src/shared/types/Error";
import { ErrorMessage } from "../../components/ErrorMessage";

// GET: Render the admin login fors
export default createRoute(async (c) => {
  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6">
        <h1 className="text-2xl font-bold text-gray-800 mb-6">
          パスワード確認
        </h1>
        <h2 className="text-xl font-semibold text-gray-700 mb-4">
          パスワードを確認します。
        </h2>
        <form method="post" action="" className="w-full">
          <div className="flex flex-col gap-4">
            <div className="flex flex-col">
              <label
                htmlFor="adminPassword"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                パスワード
              </label>
              <input
                type="password"
                id="adminPassword"
                name="adminPassword"
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
          </div>
          <div className="mt-6">
            <button
              type="submit"
              className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            >
              送信
            </button>
          </div>
        </form>
      </section>
    </main>
  );
});

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }

  // Get secret key for JWT creation from environment
  const secret =
    env<{ JWT_SECRET_KEY?: string }>(c).JWT_SECRET_KEY ||
    import.meta.env.VITE_JWT_SECRET_KEY;
  if (!secret) {
    return c.render(
      <ErrorMessage error={new Error("JWT_SECRET_KEYが設定されていません。")} />
    );
  }

  const body = await c.req.parseBody();
  const inputPassword = body.adminPassword;
  if (typeof inputPassword !== "string") {
    return c.render(
      <ErrorMessage error={new ValidationError("パスワードがありません")} />
    );
  }

  const result = await verifyAdminPasswordUsecase(
    { sql, logger },
    inputPassword
  );
  if (result.isErr()) {
    return c.render(<ErrorMessage error={result.error} />);
  }

  const exp = Math.floor(Date.now() / 1000) + 60 * 60;
  const jwtPayload = { exp };
  const token = await sign(jwtPayload, secret);

  // Set token as an HTTP-only cookie
  setCookie(c, "jwt", token, {
    httpOnly: true,
    maxAge: 60 * 60,
    path: "/admin",
  });
  return c.redirect("/admin", 303);
});
</file>

<file path="README.md">
<div align="center">
  <img src="./public/favicon.svg" width="100" height="80" />
  <h1>VakKarma</h1>
  <img src="./readme/screenshot1.png" />
  <p>2ちゃんねる風のスレッドフロート型BBS</p>
</div>

## 概要

VakKarma は、2 ちゃんねる風のスレッドフロート型 BBS です。  
ゼロちゃんねるプラスを参考に開発されました。

### 主な特徴

- [ゼロちゃんねるプラス](https://ja.osdn.net/projects/zerochplus/)に似た UI
- スレッドフロート型
- クライアントサイドで JavaScript を使用しない動作
- レスポンシブデザインへの対応(Tailwind CSS を採用)
- 1 コマンドでデプロイ(docker compose を採用)
- [ChMate](https://play.google.com/store/apps/details?id=jp.co.airfront.android.a2chMate&hl=ja)への対応
- モダンで開発体験の良い技術スタック
- DDD に基づいた設計とレイヤー分割

## インストール

### 本番環境 (Cloudflare Workers)

当システムは Cloudflare Workers にデプロイすることができます。

まず依存関係をインストールします。

```bash
pnpm install
```

必要となるデータベースを用意します。ここでは Neon を利用しますが、PostgreSQL 互換のデータベースであれば何でも構いません。
[この](https://neon.tech/docs/get-started-with-neon/signing-up)ガイドに従って、Neon のアカウントを作成し、データベースを作成してください。その際、データベースへの接続情報を取得する必要があります。

```bash
postgrest://username:password@hostname:port/database
```

次に、dbmate を用いてデータベースのマイグレーションを行います。dbmate は、データベースのスキーマを管理するためのツールです。

```bash
pnpm dbmate up --url (取得した接続情報)
```

Cloudflare Workers のアカウントを作成してください。[こちら](https://dash.cloudflare.com/sign-up)からアカウントを作成できます。すでに存在する場合は、ログインしてください。

デプロイを行ないます。内部で wrangler を使用しています。

```bash
pnpm run deploy:workers
```

デプロイが完了すると、デプロイされた URL が表示されます。

最後に、データベース接続情報・JWT のシークレットを環境変数として設定します。

```bash
pnpm wrangler secret put DATABASE_URL
pnpm wrangler secret put JWT_SECRET_KEY
```

それぞれの内容を受け付けるプロンプトが表示されるので、入力してください。正常に設定されると、再度デプロイされます。

完了後、デプロイされた URL にアクセスできるようになります。

### 本番環境 (ローカル環境・Docker)

Docker における本番環境では、以下のコンテナが起動します。

| サービス   | 概要                              |
| ---------- | --------------------------------- |
| Traefik    | リバースプロキシ                  |
| PostgreSQL | データベース                      |
| Bun        | アプリケーションサーバ (VakKarma) |
| DBMate     | マイグレーションツール            |

`.env`ファイルを編集してください。

```bash
# 本番用の環境変数
TRUSTED_PROXY_ID=proxy1
POSTGRES_USER=myuser
POSTGRES_PASSWORD=mypassword
POSTGRES_DB=myapp
JWT_SECRET_KEY=secret
```

- `TRUSTED_PROXY_ID`: リバースプロキシの識別子。ユーザに推測されないように設定してください。
- `POSTGRES_USER`: データベースのユーザ名
- `POSTGRES_PASSWORD`: データベースのパスワード
- `POSTGRES_DB`: データベース名
- `JWT_SECRET_KEY`: JWT の秘密鍵。ユーザに推測されないように設定してください。

次に、Docker の有効な環境で以下のコマンドを実行してください。

```bash
docker compose -f docker-compose.prod.yml up -d
```

アプリケーションは 80 ポートで起動します。
データベースへのマイグレーションは自動で行われます。

### 開発環境

開発環境では、データベースのみを Docker で起動します。
アプリケーション自体は Vite で起動します。

`.env`ファイルを編集してください。

```bash
# 開発環境用の環境変数
VITE_POSTGRES_USER=postgres
VITE_POSTGRES_PASSWORD=postgres
VITE_POSTGRES_DB=vakkarma-1
VITE_JWT_SECRET_KEY=secret
```

- `VITE_POSTGRES_USER`: データベースのユーザ名
- `VITE_POSTGRES_PASSWORD`: データベースのパスワード
- `VITE_POSTGRES_DB`: データベース名
- `VITE_JWT_SECRET_KEY`: JWT の秘密鍵。ユーザに推測されないように設定してください。

次に、以下のコマンドを実行してください。

```bash
docker compose -f docker-compose.dev.yml up -d
```

アプリケーションを起動するには、以下のコマンドを実行してください。

```bash
pnpm install # 依存関係のインストール
sudo pnpm run dev # 開発サーバーの起動
```

Vite が 80 ポートで起動します。
管理者権限が必要な場合は、`sudo`を付けてください。

なお、他のポートで動作させる場合や一般公開が必要ない場合は、`vite.config.ts`を編集してください。

## 使い方

VakKarma では、すべての画面がレスポンシブデザインに対応しています。

### トップ画面

![トップ画面](./readme/screenshot3.png)
![トップ画面](./readme/screenshot4.png)

上位のスレッド 30 件の一覧と、先頭スレッド 1 件&上位スレッド 10 件のレスを表示します。
レスポンスの返信フォームやスレッドの新規作成フォームも表示されます。
UI はゼロちゃんねるプラスのものに準拠しています。

### スレッド画面

![スレッド画面](./readme/screenshot5.png)

すべてのスレッドのレスを表示します。また、レスの返信フォームも表示されます。

### 管理者画面

![ログイン画面](./readme/screenshot6.png)

`/admin`にアクセスすると、管理者画面にアクセスできます。
ログイン していない状態では、`/login/admin`にリダイレクトされます。ここでパスワードを入力すると、管理者画面にアクセスできます。
パスワードはデフォルトで`password`です。

掲示板の名称やローカルルール、名無しの名前を変更できます。

![管理者画面](./readme/screenshot7.png)

また、パスワードの変更も可能です。

![パスワード変更画面](./readme/screenshot8.png)

デフォルトのパスワードから変更することを強く推奨します。

## その他関連情報

### スレッド作成・レス作成のルール

スレッド作成・レス作成時はどちらもコンテンツの入力が必須です。
ユーザ名は任意ですが、名無しの場合は管理者画面で設定した名前が表示されます。
ユーザ名に`#`を含めることで、`#`以降の文字列がトリップとして表示されます。

### 専ブラ(ChMate)での登録方法

`https://(ホスト)/senbura/`を URL に登録してください。

正常に読み込まれると、以下のように表示されます。

![専ブラ](./readme/senbura1.png)
![専ブラ](./readme/senbura2.png)

## 利用技術

| パッケージ名               | バージョン | 説明                                                                                                                  |
| :------------------------- | :--------- | :-------------------------------------------------------------------------------------------------------------------- |
| `hono`                     | `^4.7.0`   | 軽量ウェブフレームワークで、Express や Koa に似ており、HTTP リクエストとレスポンスを処理。                            |
| `honox`                    | `^0.1.34`  | Hono に基づくメタフレームワークで、Hono と Vite を使用したアプリケーション開発を簡素化。                              |
| `postgres`                 | `^3.4.5`   | Node.js で PostgreSQL データベースとインタラクション。クエリやデータ操作に使用。                                      |
| `neverthrow`               | `^8.1.1`   | Result 型を提供し、エラーを機能的に安全に処理。コードの信頼性と可読性を向上。                                         |
| `uuidv7`                   | `^1.0.2`   | 時間ベースのバージョン 7 UUID を生成。アプリケーション内で一意の識別子を生成。                                        |
| `bcrypt-ts`                | `^6.0.0`   | BCrypt アルゴリズムを使用したパスワードハッシュ化を TypeScript でサポート。パスワードの安全なハッシュ化と検証に使用。 |
| `iconv-lite`               | `^0.6.3`   | 幅広い文字エンコーディングの変換をサポート。テキストデータのエンコーディング変換に使用。                              |
| `encoding-japanese`        | `^2.2.0`   | 日本語文字エンコーディングの変換（例：Shift-JIS と UTF-8）を処理。テキストデータの多言語対応に役立つ。                |
| `tailwindcss`              | `^4.0.5`   | ユーティリティファーストの CSS フレームワーク。迅速かつ一貫したスタイリングに使用。                                   |
| `vite`                     | `^6.1.0`   | モダンウェブアプリケーションのビルドツール。ホットモジュールリプレイスメントと最適化を提供。                          |
| `@tailwindcss/vite`        | `^4.0.5`   | Vite との Tailwind CSS 統合。迅速なスタイリングのためのユーティリティクラスを使用可能。                               |
| `@ts-safeql/eslint-plugin` | `^3.6.6`   | PostgreSQL の生 SQL クエリから TypeScript 型を検証・自動生成する ESLint プラグイン。SQL クエリの型安全性を確保。      |

## ロードマップ

- [x] コンテンツの最大長制限への対応 (medium)
  - `createResponseContent`の非同期関数化  
    高階関数パターンの導入
- [x] パスワード更新機能の実装 (medium)
- [x] レスの範囲を指定するページの追加
- [ ] Config/Env をセットアップするシェルスクリプトの実装
- [ ] 信頼できる IP アドレスを外部から設定できるようにする
- [ ] https に対応するスクリプトの追加
- [ ] NG ワード機能の実装
- [ ] レス検索機能の実装
- [ ] Cloudflare Captcha(turnstile)への対応
- [ ] ログの出力
  - [ ] 適切な粒度がわからないので見直しが必要
- [ ] エラーハンドリングの見直し
  - [ ] エラーと例外の分離
- [ ] テストの記述
  - [x] ドメイン層のテスト
  - [ ] ユースケース層のテスト
  - [ ] リポジトリ層のテスト
- [ ] 複数板を扱う機能の実装(very hard)
- [ ] ログイン機能の実装(very hard)

## License

MIT

## 開発者

- [calloc134](https://github.com/calloc134)
</file>

<file path="src/config/usecases/getBoardConfigUsecase.ts">
import { err, ok } from "neverthrow";

import { getBoardConfigRepository } from "../repositories/getBoardConfigRepository";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadBoardConfig } from "../domain/read/ReadBoardConfig";
import type { Result } from "neverthrow";

export const getBoardConfigUsecase = async (
  vakContext: VakContext
): Promise<Result<ReadBoardConfig, Error>> => {
  const { logger } = vakContext;

  logger.debug({
    operation: "getBoardConfigUsecase",
    message: "Starting to fetch board configuration",
  });

  const config = await getBoardConfigRepository(vakContext);

  if (config.isErr()) {
    logger.error({
      operation: "getBoardConfigUsecase",
      error: config.error,
      message: "Failed to fetch board configuration",
    });
    return err(config.error);
  }

  logger.info({
    operation: "getBoardConfigUsecase",
    boardName: config.value.boardName.val,
    message: "Successfully retrieved board configuration",
  });

  return ok(config.value);
};
</file>

<file path="src/config/usecases/updatePasswordUsecase.ts">
import { compare } from "bcrypt-ts";
import { ok, err, type Result } from "neverthrow";

import { ValidationError } from "../../shared/types/Error";
import { createWritePassword } from "../domain/write/WritePassword";
import { generateWritePasswordHash } from "../domain/write/WritePasswordHash";
import { getPasswordHashRepository } from "../repositories/getPasswordHashRepository";
import { updatePasswordHashRepository } from "../repositories/updatePasswordHashRepository";

import type { VakContext } from "../../shared/types/VakContext";

export const updatePasswordUsecase = async (
  vakContext: VakContext,
  {
    oldPassword,
    newPassword,
    confirmNewPassword,
  }: { oldPassword: string; newPassword: string; confirmNewPassword: string }
): Promise<Result<undefined, Error>> => {
  const { logger } = vakContext;

  logger.info({
    operation: "updatePassword",
    message: "Starting password update process",
  });

  if (newPassword !== confirmNewPassword) {
    logger.warn({
      operation: "updatePassword",
      message:
        "Password update failed: new password and confirmation do not match",
    });
    return err(
      new ValidationError("新しいパスワードと確認パスワードが一致しません")
    );
  }

  logger.debug({
    operation: "updatePassword",
    message: "Fetching stored password hash",
  });

  const storedHashResult = await getPasswordHashRepository(vakContext);
  if (storedHashResult.isErr()) {
    logger.error({
      operation: "updatePassword",
      error: storedHashResult.error,
      message: "Failed to fetch stored password hash",
    });
    return err(storedHashResult.error);
  }
  const storedHash = storedHashResult.value;

  logger.debug({
    operation: "updatePassword",
    message: "Verifying current password",
  });

  const passwordMatch = await compare(oldPassword, storedHash.val);
  if (!passwordMatch) {
    logger.warn({
      operation: "updatePassword",
      message: "Password update failed: current password is incorrect",
    });
    return err(new ValidationError("現在のパスワードが正しくありません"));
  }

  logger.debug({
    operation: "updatePassword",
    message: "Validating new password format",
  });

  const newPasswordResult = await createWritePassword(newPassword);
  if (newPasswordResult.isErr()) {
    logger.error({
      operation: "updatePassword",
      error: newPasswordResult.error,
      message: "Failed to validate new password format",
    });
    return err(newPasswordResult.error);
  }

  logger.debug({
    operation: "updatePassword",
    message: "Generating hash for new password",
  });

  const newHashResult = await generateWritePasswordHash(
    newPasswordResult.value
  );
  if (newHashResult.isErr()) {
    logger.error({
      operation: "updatePassword",
      error: newHashResult.error,
      message: "Failed to generate hash for new password",
    });
    return err(newHashResult.error);
  }

  logger.debug({
    operation: "updatePassword",
    message: "Updating password hash in database",
  });

  const updateResult = await updatePasswordHashRepository(
    vakContext,
    newHashResult.value
  );
  if (updateResult.isErr()) {
    logger.error({
      operation: "updatePassword",
      error: updateResult.error,
      message: "Failed to update password hash in database",
    });
    return err(updateResult.error);
  }

  logger.info({
    operation: "updatePassword",
    message: "Password updated successfully",
  });

  return ok(undefined);
};
</file>

<file path="src/config/usecases/verifyAdminPasswordUsecase.ts">
import { compare } from "bcrypt-ts";
import { ok, err } from "neverthrow";

import { getPasswordHashRepository } from "../repositories/getPasswordHashRepository";

import type { VakContext } from "../../shared/types/VakContext";

export const verifyAdminPasswordUsecase = async (
  vakContext: VakContext,
  inputPassword: string
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "verifyAdminPassword",
    message: "Starting admin password verification",
  });

  logger.debug({
    operation: "verifyAdminPassword",
    message: "Fetching stored password hash",
  });

  const configResult = await getPasswordHashRepository(vakContext);
  if (configResult.isErr()) {
    logger.error({
      operation: "verifyAdminPassword",
      error: configResult.error,
      message: "Failed to fetch password hash from database",
    });
    return configResult;
  }

  const storedPassword = configResult.value;

  logger.debug({
    operation: "verifyAdminPassword",
    message: "Comparing input password with stored hash",
  });

  if (!(await compare(inputPassword, storedPassword.val))) {
    logger.warn({
      operation: "verifyAdminPassword",
      message: "Invalid password attempt",
    });
    return err(new Error("パスワードが間違っています"));
  }

  logger.info({
    operation: "verifyAdminPassword",
    message: "Admin password verified successfully",
  });

  return ok(undefined);
};
</file>

<file path="src/conversation/repositories/createResponseByThreadIdRepository.ts">
import { ok, err } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadResponseNumber } from "../domain/read/ReadResponseNumber";
import type { ReadThreadId } from "../domain/read/ReadThreadId";
import type { WriteResponse } from "../domain/write/WriteResponse";
import type { Result } from "neverthrow";

// レスポンスを作成するリポジトリ
export const createResponseByThreadIdRepository = async (
  { sql, logger }: VakContext,
  response: WriteResponse
): Promise<
  Result<
    {
      threadId: ReadThreadId;
      responseNumber: ReadResponseNumber;
    },
    DatabaseError
  >
> => {
  const trip =
    response.authorName.val._type === "some"
      ? response.authorName.val.trip
      : null;

  logger.debug({
    operation: "createResponseByThreadId",
    responseId: response.id.val,
    threadId: response.threadId.val,
    message: "Creating new response in database",
  });

  try {
    const result = await sql<
      { id: string; response_number: number; thread_id: string }[]
    >`
        INSERT INTO responses(
            id,
            thread_id,
            response_number,
            author_name,
            mail,
            posted_at,
            response_content,
            hash_id,
            trip
        )
        VALUES(
            ${response.id.val}::uuid,
            ${response.threadId.val}::uuid,
            -- レスポンス番号はスレッド内での最大値 + 1
            (
                SELECT COALESCE(MAX(response_number), 0) + 1
                FROM responses
                WHERE thread_id = ${response.threadId.val}::uuid
            ),
            ${response.authorName.val.authorName},
            ${response.mail.val},
            ${response.postedAt.val},
            ${response.responseContent.val},
            ${response.hashId.val},
            ${trip}
        ) RETURNING id, response_number, thread_id
      `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "createResponseByThreadId",
        responseId: response.id.val,
        threadId: response.threadId.val,
        message: "Failed to create response, invalid database response",
      });
      return err(new DatabaseError("レスポンスの作成に失敗しました"));
    }

    logger.info({
      operation: "createResponseByThreadId",
      responseId: response.id.val,
      threadId: response.threadId.val,
      message: "Response created successfully",
    });

    const threadIdResult = createReadThreadId(result[0].thread_id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "createResponseByThreadId",
        error: threadIdResult.error,
        responseId: response.id.val,
        threadId: response.threadId.val,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }
    const responseNumber = createReadResponseNumber(result[0].response_number);

    if (responseNumber.isErr()) {
      logger.error({
        operation: "createResponseByThreadId",
        error: responseNumber.error,
        responseId: response.id.val,
        threadId: response.threadId.val,
        message: "Failed to create response number from database result",
      });
      return err(responseNumber.error);
    }

    return ok({
      threadId: threadIdResult.value,
      responseNumber: responseNumber.value,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "createResponseByThreadId",
      responseId: response.id.val,
      threadId: response.threadId.val,
      error,
      message: `Database error while creating response: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス作成中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getAllResponsesByThreadEpochIdRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import {
  createReadThreadWithResponses,
  type ReadThreadWithResponses,
} from "../domain/read/ReadThreadWithResponses";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteThreadEpochId } from "../domain/write/WriteThreadEpochId";

// 指定されたスレッドのすべてのレスポンスを取得するだけのリポジトリ
// 便宜上、スレッドタイトルも取得する
export const getAllResponsesByThreadEpochIdRepository = async (
  { sql, logger }: VakContext,
  { threadEpochId }: { threadEpochId: WriteThreadEpochId }
): Promise<
  Result<
    ReadThreadWithResponses,
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getAllResponsesByThreadEpochId",
    threadEpochId: threadEpochId.val,
    message: "Fetching all responses for thread by epoch ID",
  });

  try {
    const result = await sql<
      {
        id: string;
        thread_id: string;
        response_number: number;
        author_name: string;
        mail: string;
        posted_at: Date;
        response_content: string;
        hash_id: string;
        trip: string | null;
        title: string;
      }[]
    >`
          SELECT
              r.id,
              r.thread_id,
              r.response_number,
              r.author_name,
              r.mail,
              r.posted_at,
              r.response_content,
              r.hash_id,
              r.trip,
              t.title
          FROM
              responses as r
              JOIN
                  threads as t
              ON  r.thread_id = t.id
          WHERE
            t.epoch_id = ${threadEpochId.val}
          ORDER BY
              r.response_number
      `;

    if (!result || result.length === 0) {
      logger.info({
        operation: "getAllResponsesByThreadEpochId",
        threadEpochId: threadEpochId.val,
        message: "No responses found for thread",
      });
      return err(new DataNotFoundError("レスポンスの取得に失敗しました"));
    }

    logger.debug({
      operation: "getAllResponsesByThreadEpochId",
      threadEpochId: threadEpochId.val,
      responseCount: result.length,
      message: "Successfully retrieved responses from database",
    });

    // 詰め替え部分
    const threadIdResult = createReadThreadId(result[0].thread_id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadEpochId",
        threadEpochId: threadEpochId.val,
        error: threadIdResult.error,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }

    const threadId = threadIdResult.value;
    const responses: ReadResponse[] = [];
    for (const response of result) {
      const combinedResult = Result.combine([
        createReadResponseId(response.id),
        createReadResponseNumber(response.response_number),
        createReadAuthorName(response.author_name, response.trip),
        createReadMail(response.mail),
        createReadPostedAt(response.posted_at),
        createReadResponseContent(response.response_content),
        createReadHashId(response.hash_id),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getAllResponsesByThreadEpochId",
          threadEpochId: threadEpochId.val,
          threadId: threadId.val,
          responseId: response.id,
          error: combinedResult.error,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }

      const [
        responseId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      ] = combinedResult.value;

      const responseResult = createReadResponse({
        responseId,
        threadId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      });

      if (responseResult.isErr()) {
        logger.error({
          operation: "getAllResponsesByThreadEpochId",
          threadEpochId: threadEpochId.val,
          threadId: threadId.val,
          responseId: responseId.val,
          error: responseResult.error,
          message: "Failed to create ReadResponse object",
        });
        return err(responseResult.error);
      }

      responses.push(responseResult.value);
    }

    // スレッドタイトルの取得とバリデーション
    const firstResponse = result[0];
    const threadTitleResult = createReadThreadTitle(firstResponse.title);
    if (threadTitleResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadEpochId",
        threadEpochId: threadEpochId.val,
        threadId: threadId.val,
        error: threadTitleResult.error,
        message: "Failed to create thread title from database result",
      });
      return err(threadTitleResult.error);
    }

    const threadWithResponsesResult = createReadThreadWithResponses(
      threadId,
      threadTitleResult.value,
      responses
    );

    if (threadWithResponsesResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadEpochId",
        threadEpochId: threadEpochId.val,
        threadId: threadId.val,
        error: threadWithResponsesResult.error,
        message: "Failed to create thread with responses object",
      });
      return err(threadWithResponsesResult.error);
    }

    logger.info({
      operation: "getAllResponsesByThreadEpochId",
      threadEpochId: threadEpochId.val,
      threadId: threadId.val,
      threadTitle: threadTitleResult.value.val,
      responseCount: responses.length,
      message: "Successfully fetched and processed all responses for thread",
    });

    return ok(threadWithResponsesResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getAllResponsesByThreadEpochId",
      threadEpochId: threadEpochId.val,
      error,
      message: `Database error while fetching responses: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getAllThreadsRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import { createReadThread, type ReadThread } from "../domain/read/ReadThread";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";

// すべてのスレッドを取得するだけのリポジトリ
export const getAllThreadsRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadThread[], DatabaseError | DataNotFoundError | ValidationError>
> => {
  logger.debug({
    operation: "getAllThreads",
    message: "Fetching all threads from database",
  });

  try {
    const result = await sql<
      {
        id: string;
        title: string;
        posted_at: Date;
        updated_at: Date;
        response_count: number;
      }[]
    >`
          SELECT
              t.id,
              t.title,
              t.posted_at,
              t.updated_at,
              COUNT(r.id)::int as response_count
          FROM
              threads as t
              LEFT JOIN
                  responses as r
              ON  t.id = r.thread_id
          GROUP BY
              t.id,
              t.title
          ORDER BY
              t.updated_at DESC
      `;

    if (!result || result.length === 0) {
      logger.error({
        operation: "getAllThreads",
        message: "No threads found in database",
      });
      return err(new DataNotFoundError("スレッドの取得に失敗しました"));
    }

    logger.debug({
      operation: "getAllThreads",
      threadCount: result.length,
      message: "Retrieved threads from database, processing domain objects",
    });

    // 詰め替え部分
    const threads: ReadThread[] = [];
    for (const thread of result) {
      const combinedResult = Result.combine([
        createReadThreadId(thread.id),
        createReadThreadTitle(thread.title),
        createReadPostedAt(thread.posted_at),
        createReadPostedAt(thread.updated_at),
      ]);
      if (combinedResult.isErr()) {
        logger.error({
          operation: "getAllThreads",
          error: combinedResult.error,
          threadId: thread.id,
          message: "Failed to create domain objects from thread data",
        });
        return err(combinedResult.error);
      }
      const [threadId, title, postedAt, updatedAt] = combinedResult.value;

      const threadResult = createReadThread({
        id: threadId,
        title,
        postedAt,
        updatedAt,
        countResponse: thread.response_count,
      });
      if (threadResult.isErr()) {
        logger.error({
          operation: "getAllThreads",
          error: threadResult.error,
          threadId: threadId.val,
          message: "Failed to create thread domain object",
        });
        return err(threadResult.error);
      }

      threads.push(threadResult.value);
    }

    logger.info({
      operation: "getAllThreads",
      threadCount: threads.length,
      message: "Successfully retrieved and processed all threads",
    });

    return ok(threads);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getAllThreads",
      error,
      message: `Database error while fetching threads: ${message}`,
    });
    return err(
      new DatabaseError(
        `スレッド取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getAllThreadsWithEpochIdRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import { createReadThreadEpochId } from "../domain/read/ReadThreadEpochId";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import { createReadThreadWithEpochId } from "../domain/read/ReadThreadWithEpochId";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { ReadThreadWithEpochId } from "../domain/read/ReadThreadWithEpochId";

// すべてのスレッドを取得するだけのリポジトリ
export const getAllThreadsWithEpochIdRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<
    ReadThreadWithEpochId[],
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getAllThreadsWithEpochId",
    message: "Fetching all threads with epoch IDs",
  });

  try {
    const result = await sql<
      {
        id: string;
        title: string;
        posted_at: Date;
        updated_at: Date;
        epoch_id: string;
        response_count: number;
      }[]
    >`
          SELECT
              t.id,
              t.title,
              t.posted_at,
              t.updated_at,
              t.epoch_id,
              COUNT(r.id)::int as response_count
          FROM
              threads as t
              LEFT JOIN
                  responses as r
              ON  t.id = r.thread_id
          GROUP BY
              t.id,
              t.title
          ORDER BY
              t.updated_at DESC
      `;

    if (!result || result.length === 0) {
      logger.info({
        operation: "getAllThreadsWithEpochId",
        message: "No threads found in database",
      });
      return err(new DataNotFoundError("スレッドの取得に失敗しました"));
    }

    logger.debug({
      operation: "getAllThreadsWithEpochId",
      count: result.length,
      message: "Successfully retrieved threads from database",
    });

    // 詰め替え部分
    const threads: ReadThreadWithEpochId[] = [];
    for (const thread of result) {
      const combinedResult = Result.combine([
        createReadThreadId(thread.id),
        createReadThreadTitle(thread.title),
        createReadPostedAt(thread.posted_at),
        createReadPostedAt(thread.updated_at),
        createReadThreadEpochId(thread.epoch_id),
      ]);
      if (combinedResult.isErr()) {
        logger.error({
          operation: "getAllThreadsWithEpochId",
          error: combinedResult.error,
          threadId: thread.id,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }
      const [threadId, title, postedAt, updatedAt, threadEpochId] =
        combinedResult.value;

      const threadWithEpochIdResult = createReadThreadWithEpochId({
        id: threadId,
        title,
        postedAt,
        updatedAt,
        countResponse: thread.response_count,
        threadEpochId,
      });
      if (threadWithEpochIdResult.isErr()) {
        logger.error({
          operation: "getAllThreadsWithEpochId",
          error: threadWithEpochIdResult.error,
          threadId: threadId.val,
          message: "Failed to create ReadThreadWithEpochId object",
        });
        return err(threadWithEpochIdResult.error);
      }
      threads.push(threadWithEpochIdResult.value);
    }

    logger.info({
      operation: "getAllThreadsWithEpochId",
      threadCount: threads.length,
      message: "Successfully fetched and processed all threads with epoch IDs",
    });

    return ok(threads);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getAllThreadsWithEpochId",
      error,
      message: `Database error while fetching threads: ${message}`,
    });
    return err(
      new DatabaseError(
        `スレッド取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getLatest30ThreadsRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import { createReadThread, type ReadThread } from "../domain/read/ReadThread";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";

// updated_atが新しい順に30個のスレッドを取得
// かつ、新しい先頭の10個は、レスポンスの内容も含めて取得
// レスポンスの内容は、先頭のレスポンス一つと、posted_atが新しい順に10個
export const getLatest30ThreadsRepository = async ({
  sql,
  logger,
}: VakContext): Promise<
  Result<ReadThread[], DatabaseError | DataNotFoundError | ValidationError>
> => {
  logger.debug({
    operation: "getLatest30Threads",
    message: "Fetching latest 30 threads ordered by updated_at",
  });

  try {
    const result = await sql<
      {
        id: string;
        title: string;
        posted_at: Date;
        updated_at: Date;
        response_count: number;
      }[]
    >`
        SELECT
            t.id,
            t.title,
            t.posted_at,
            t.updated_at,
            COUNT(r.id)::int as response_count
        FROM
            threads as t
            LEFT JOIN
                responses as r
            ON  t.id = r.thread_id
        GROUP BY
            t.id,
            t.title
        ORDER BY
            t.updated_at DESC
        LIMIT 30
    `;

    if (!result || result.length === 0) {
      logger.info({
        operation: "getLatest30Threads",
        message: "No threads found in database",
      });
      return err(new DataNotFoundError("スレッドの取得に失敗しました"));
    }

    logger.debug({
      operation: "getLatest30Threads",
      count: result.length,
      message: "Successfully retrieved threads from database",
    });

    // 詰め替え部分
    const threads: ReadThread[] = [];
    for (const thread of result) {
      const combinedResult = Result.combine([
        createReadThreadId(thread.id),
        createReadThreadTitle(thread.title),
        createReadPostedAt(thread.posted_at),
        createReadPostedAt(thread.updated_at),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getLatest30Threads",
          error: combinedResult.error,
          threadId: thread.id,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }
      const [threadId, title, postedAt, updatedAt] = combinedResult.value;

      const threadResult = createReadThread({
        id: threadId,
        title,
        postedAt,
        updatedAt,
        countResponse: thread.response_count,
      });

      if (threadResult.isErr()) {
        logger.error({
          operation: "getLatest30Threads",
          error: threadResult.error,
          threadId: thread.id,
          message: "Failed to create ReadThread object",
        });
        return err(threadResult.error);
      }

      threads.push(threadResult.value);
    }

    logger.info({
      operation: "getLatest30Threads",
      threadCount: threads.length,
      message: "Successfully fetched and processed latest threads",
    });

    return ok(threads);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getLatest30Threads",
      error,
      message: `Database error while fetching threads: ${message}`,
    });
    return err(
      new DatabaseError(
        `スレッド取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getThreadIdByThreadEpochIdRepository.ts">
import { err, ok } from "neverthrow";

import { createReadThreadId } from "../domain/read/ReadThreadId";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadThreadId } from "../domain/read/ReadThreadId";
import type { WriteThreadEpochId } from "../domain/write/WriteThreadEpochId";
import type { Result } from "neverthrow";

export const getThreadIdByThreadEpochIdRepository = async (
  { sql, logger }: VakContext,
  { threadEpochId }: { threadEpochId: WriteThreadEpochId }
): Promise<Result<ReadThreadId, Error>> => {
  logger.debug({
    operation: "getThreadIdByThreadEpochId",
    threadEpochId: threadEpochId.val,
    message: "Fetching thread ID by epoch ID",
  });

  const result = await sql<{ id: string }[]>`
        SELECT
            id
        FROM
            threads
        WHERE
            epoch_id = ${threadEpochId.val}
    `;
  if (!result || result.length !== 1) {
    logger.error({
      operation: "getThreadIdByThreadEpochId",
      threadEpochId: threadEpochId.val,
      message: "Failed to retrieve thread ID, invalid database response",
    });
    return err(new Error("スレッドIDの取得に失敗しました"));
  }

  logger.debug({
    operation: "getThreadIdByThreadEpochId",
    threadEpochId: threadEpochId.val,
    threadId: result[0].id,
    message: "Thread ID retrieved from database",
  });

  const threadIdResult = createReadThreadId(result[0].id);
  if (threadIdResult.isErr()) {
    logger.error({
      operation: "getThreadIdByThreadEpochId",
      threadEpochId: threadEpochId.val,
      error: threadIdResult.error,
      message: "Failed to create thread ID domain object",
    });
    return err(threadIdResult.error);
  }

  logger.info({
    operation: "getThreadIdByThreadEpochId",
    threadEpochId: threadEpochId.val,
    threadId: threadIdResult.value.val,
    message: "Successfully retrieved thread ID by epoch ID",
  });

  return ok(threadIdResult.value);
};
</file>

<file path="src/conversation/usecases/getAllThreadsPageUsecase.ts">
import { err, ok } from "neverthrow";

import { getAllThreadsRepository } from "../repositories/getAllThreadsRepository";

import type { VakContext } from "../../shared/types/VakContext";

// すべてのスレッドを取得するユースケース
export const getAllThreadsPageUsecase = async (vakContext: VakContext) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getAllThreadsPage",
    message: "Starting all threads retrieval",
  });

  logger.debug({
    operation: "getAllThreadsPage",
    message: "Fetching all threads from repository",
  });

  const threadsResult = await getAllThreadsRepository(vakContext);
  if (threadsResult.isErr()) {
    logger.error({
      operation: "getAllThreadsPage",
      error: threadsResult.error,
      message: "Failed to fetch all threads",
    });
    return err(threadsResult.error);
  }

  logger.info({
    operation: "getAllThreadsPage",
    threadCount: threadsResult.value.length,
    message: "Successfully retrieved all threads",
  });

  return ok(threadsResult.value);
};
</file>

<file path="src/conversation/usecases/getAllThreadsWithEpochIdUsecase.ts">
import { err, ok } from "neverthrow";

import { getAllThreadsWithEpochIdRepository } from "../repositories/getAllThreadsWithEpochIdRepository";

import type { VakContext } from "../../shared/types/VakContext";

export const getAllThreadsWithEpochIdUsecase = async (
  vakContext: VakContext
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getAllThreadsWithEpochId",
    message: "Starting all threads with epoch ID retrieval",
  });

  logger.debug({
    operation: "getAllThreadsWithEpochId",
    message: "Fetching threads with epoch IDs from repository",
  });

  const threads = await getAllThreadsWithEpochIdRepository(vakContext);
  if (threads.isErr()) {
    logger.error({
      operation: "getAllThreadsWithEpochId",
      error: threads.error,
      message: "Failed to fetch threads with epoch IDs",
    });
    return err(threads.error);
  }

  logger.info({
    operation: "getAllThreadsWithEpochId",
    threadCount: threads.value.length,
    message: "Successfully retrieved all threads with epoch IDs",
  });

  return ok(threads.value);
};
</file>

<file path="app/routes/senbura/dat/[iddat].tsx">
import { createRoute } from "honox/factory";

import { formatReadAuthorName } from "../../../../src/conversation/domain/read/ReadAuthorName";
import { getAllResponsesByThreadEpochIdUsecase } from "../../../../src/conversation/usecases/getAllResponsesByThreadEpochIdUsecase";
import { formatDate } from "../../../../src/shared/utils/formatDate";
import { convertShiftJis } from "../../../utils/convertShiftJis";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;
  if (!sql) {
    return convertShiftJis("DBに接続できませんでした");
  }

  // [id].dat という形で渡される
  const idAat = c.req.param("iddat");

  // 分割する
  const id = idAat.split(".")[0];
  if (!id) {
    return convertShiftJis("スレッドIDが指定されていません");
  }

  const responsesResult = await getAllResponsesByThreadEpochIdUsecase(
    { sql, logger },
    { threadEpochIdRaw: id }
  );
  if (responsesResult.isErr()) {
    return convertShiftJis(
      `エラーが発生しました: ${responsesResult.error.message}`
    );
  }

  const title = responsesResult.value.thread.threadTitle.val;
  let text = "";
  for (const resp of responsesResult.value.responses) {
    const formattedDate = formatDate(resp.postedAt.val);
    const formattedUserName = formatReadAuthorName(resp.authorName);

    text += `${formattedUserName}<>${resp.mail.val}<>${formattedDate} ID:${
      resp.hashId.val
    }<>${resp.responseContent.val.replace(/\n/g, "<br>")}<>${title}\r\n`;
  }
  return convertShiftJis(text);
});
</file>

<file path="app/routes/threads/[id]/responses.tsx">
import { createRoute } from "honox/factory";

import { postResponseByThreadIdUsecase } from "../../../../src/conversation/usecases/postResponseByThreadIdUsecase";
import { ErrorMessage } from "../../../components/ErrorMessage";
import { getIpAddress } from "../../../utils/getIpAddress";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;
  const id = c.req.param("id");

  logger.info({
    operation: "threads/[id]/responses/POST",
    path: c.req.path,
    method: c.req.method,
    threadId: id,
    message: "Response creation request received",
  });

  if (!id) {
    logger.warn({
      operation: "threads/[id]/responses/POST",
      message: "Thread ID not specified in request",
    });
    return c.render(
      <ErrorMessage error={new Error("スレッドIDが指定されていません")} />
    );
  }

  const body = await c.req.parseBody();
  const name = typeof body.name === "string" ? body.name : null;
  const mail = typeof body.mail === "string" ? body.mail : null;
  const content = body.content;

  logger.debug({
    operation: "threads/[id]/responses/POST",
    threadId: id,
    hasName: name !== null,
    hasMail: mail !== null,
    hasContent: typeof content === "string",
    message: "Request body parsed for response creation",
  });

  // もし文字列じゃなかったらエラーを返す
  if (typeof content !== "string") {
    logger.warn({
      operation: "threads/[id]/responses/POST",
      threadId: id,
      contentType: typeof content,
      message: "Response content is missing or invalid",
    });
    return c.render(<ErrorMessage error={new Error("本文は必須です")} />);
  }

  const ipAddressRaw = getIpAddress(c);

  logger.debug({
    operation: "threads/[id]/responses/POST",
    threadId: id,
    ipAddress: ipAddressRaw,
    message: "IP address extracted for response creation",
  });

  // レス番号(responseNumber)は自動で振られるので、渡す必要はない
  // 整合性とレイヤ分離のトレードオフだが、ロジックとして重要な部分なので整合性を優先した
  logger.debug({
    operation: "threads/[id]/responses/POST",
    threadId: id,
    message: "Calling postResponseByThreadIdUsecase",
  });

  const responseResult = await postResponseByThreadIdUsecase(
    { sql, logger },
    {
      threadIdRaw: id,
      authorNameRaw: name,
      mailRaw: mail,
      responseContentRaw: content,
      ipAddressRaw,
    }
  );
  if (responseResult.isErr()) {
    logger.error({
      operation: "threads/[id]/responses/POST",
      threadId: id,
      error: responseResult.error,
      message: "Failed to create response",
    });
    return c.render(<ErrorMessage error={responseResult.error} />);
  }

  logger.info({
    operation: "threads/[id]/responses/POST",
    threadId: id,
    message: "Response created successfully, redirecting to thread page",
  });

  const { threadId } = responseResult.value;

  return c.redirect(`/threads/${threadId.val}/l10`, 303);
});

export default createRoute((c) => {
  const { logger } = c.var;

  logger.warn({
    operation: "threads/[id]/responses/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Invalid method for response endpoint, GET method not supported",
  });

  return c.render(
    <ErrorMessage error={new Error("POSTメソッドでアクセスしてください")} />
  );
});
</file>

<file path="package.json">
{
  "name": "basic",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build:workers": "vite build --mode client && vite build --mode workers",
    "build:bun": "vite build --mode client && vite build --mode bun",
    "preview": "wrangler dev",
    "deploy:workers": "pnpm run build:workers && wrangler deploy",
    "typecheck": "tsc --noEmit",
    "lint": "DISABLE_SAFEQL=true eslint .",
    "migrateup": "dbmate up",
    "migratedown": "dbmate down"
  },
  "private": true,
  "dependencies": {
    "bcrypt-ts": "^6.0.0",
    "encoding-japanese": "^2.2.0",
    "hono": "^4.7.4",
    "hono-pino": "^0.8.0",
    "honox": "^0.1.38",
    "iconv-lite": "^0.6.3",
    "neverthrow": "^8.2.0",
    "pino": "^9.6.0",
    "postgres": "^3.4.5",
    "uuidv7": "^1.0.2"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20250313.0",
    "@hono/node-server": "^1.13.8",
    "@hono/vite-build": "^1.3.0",
    "@hono/vite-dev-server": "^0.18.3",
    "@tailwindcss/vite": "^4.0.14",
    "@ts-safeql/eslint-plugin": "^3.6.10",
    "@types/encoding-japanese": "^2.2.1",
    "@types/node": "^22.13.10",
    "dbmate": "^2.26.0",
    "dotenv": "^16.4.7",
    "eslint-import-resolver-typescript": "^3.9.1",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-import-x": "^4.8.0",
    "eslint-plugin-unused-imports": "^4.1.4",
    "libpg-query": "^16.3.0",
    "tailwindcss": "^4.0.14",
    "typescript": "^5.8.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^6.2.2",
    "vitest": "^3.1.1",
    "wrangler": "^4.0.0"
  },
  "packageManager": "pnpm@10.7.1"
}
</file>

<file path="src/conversation/repositories/getAllResponsesByThreadIdRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { createReadThreadTitle } from "../domain/read/ReadThreadTitle";
import {
  createReadThreadWithResponses,
  type ReadThreadWithResponses,
} from "../domain/read/ReadThreadWithResponses";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteThreadId } from "../domain/write/WriteThreadId";

// 指定されたスレッドのすべてのレスポンスを取得するだけのリポジトリ
// 便宜上、スレッドタイトルも取得する
export const getAllResponsesByThreadIdRepository = async (
  { sql, logger }: VakContext,
  { threadId }: { threadId: WriteThreadId }
): Promise<
  Result<
    ReadThreadWithResponses,
    DatabaseError | DataNotFoundError | ValidationError
  >
> => {
  logger.debug({
    operation: "getAllResponsesByThreadId",
    threadId: threadId.val,
    message: "Fetching all responses for thread",
  });

  try {
    const result = await sql<
      {
        id: string;
        thread_id: string;
        response_number: number;
        author_name: string;
        mail: string;
        posted_at: Date;
        response_content: string;
        hash_id: string;
        trip: string | null;
        title: string;
      }[]
    >`
          SELECT
              r.id,
              r.thread_id,
              r.response_number,
              r.author_name,
              r.mail,
              r.posted_at,
              r.response_content,
              r.hash_id,
              r.trip,
              t.title
          FROM
              responses as r
              JOIN
                  threads as t
              ON  r.thread_id = t.id
          WHERE
              r.thread_id = ${threadId.val}::uuid
          ORDER BY
              r.response_number
      `;

    if (!result || result.length === 0) {
      logger.info({
        operation: "getAllResponsesByThreadId",
        threadId: threadId.val,
        message: "No responses found for thread",
      });
      return err(new DataNotFoundError("レスポンスの取得に失敗しました"));
    }

    logger.debug({
      operation: "getAllResponsesByThreadId",
      threadId: threadId.val,
      responseCount: result.length,
      message: "Successfully retrieved responses from database",
    });

    // 詰め替え部分
    // すべての投稿でスレッドIDは共通なので、最初のレスポンスから取得
    const threadIdResult = createReadThreadId(result[0].thread_id);
    if (threadIdResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadId",
        threadId: threadId.val,
        error: threadIdResult.error,
        message: "Failed to create thread ID from database result",
      });
      return err(threadIdResult.error);
    }

    const responses: ReadResponse[] = [];
    for (const response of result) {
      const combinedResult = Result.combine([
        createReadResponseId(response.id),
        createReadResponseNumber(response.response_number),
        createReadAuthorName(response.author_name, response.trip),
        createReadMail(response.mail),
        createReadPostedAt(response.posted_at),
        createReadResponseContent(response.response_content),
        createReadHashId(response.hash_id),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getAllResponsesByThreadId",
          threadId: threadId.val,
          responseId: response.id,
          error: combinedResult.error,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }

      const [
        responseId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      ] = combinedResult.value;

      const responseResult = createReadResponse({
        responseId,
        threadId: threadIdResult.value,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      });

      if (responseResult.isErr()) {
        logger.error({
          operation: "getAllResponsesByThreadId",
          threadId: threadId.val,
          responseId: responseId.val,
          error: responseResult.error,
          message: "Failed to create ReadResponse object",
        });
        return err(responseResult.error);
      }

      responses.push(responseResult.value);
    }

    // スレッドタイトルの取得とバリデーション
    const firstResponse = result[0];
    const threadTitleResult = createReadThreadTitle(firstResponse.title);
    if (threadTitleResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadId",
        threadId: threadId.val,
        threadTitle: firstResponse.title,
        error: threadTitleResult.error,
        message: "Failed to create thread title from database result",
      });
      return err(threadTitleResult.error);
    }

    const threadWithResponsesResult = createReadThreadWithResponses(
      threadIdResult.value,
      threadTitleResult.value,
      responses
    );

    if (threadWithResponsesResult.isErr()) {
      logger.error({
        operation: "getAllResponsesByThreadId",
        threadId: threadId.val,
        error: threadWithResponsesResult.error,
        message: "Failed to create thread with responses object",
      });
      return err(threadWithResponsesResult.error);
    }

    logger.info({
      operation: "getAllResponsesByThreadId",
      threadId: threadId.val,
      threadTitle: threadTitleResult.value.val,
      responseCount: responses.length,
      message: "Successfully fetched and processed all responses for thread",
    });

    return ok(threadWithResponsesResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getAllResponsesByThreadId",
      threadId: threadId.val,
      error,
      message: `Database error while fetching responses: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/getLatest10ThreadsWithResposesRepository.ts">
import { ok, err } from "neverthrow";
import { Result } from "neverthrow";

import { DatabaseError, DataNotFoundError } from "../../shared/types/Error";
import { createReadAuthorName } from "../domain/read/ReadAuthorName";
import { createReadHashId } from "../domain/read/ReadHashId";
import { createReadMail } from "../domain/read/ReadMail";
import { createReadPostedAt } from "../domain/read/ReadPostedAt";
import {
  createReadResponse,
  type ReadResponse,
} from "../domain/read/ReadResponse";
import { createReadResponseContent } from "../domain/read/ReadResponseContent";
import { createReadResponseId } from "../domain/read/ReadResponseId";
import { createReadResponseNumber } from "../domain/read/ReadResponseNumber";
import { createReadThreadId } from "../domain/read/ReadThreadId";

import type { ValidationError } from "../../shared/types/Error";
import type { VakContext } from "../../shared/types/VakContext";
import type { WriteThreadId } from "../domain/write/WriteThreadId";

// スレッドIDを元に、最新のレスポンスを10個取得し、その内容を返す
export const getLatest10ThreadsWithResponsesRepository = async (
  { sql, logger }: VakContext,
  { threadIds }: { threadIds: WriteThreadId[] }
): Promise<
  Result<ReadResponse[], DatabaseError | DataNotFoundError | ValidationError>
> => {
  // そのままでは扱えないのでstringを取り出し
  const threadIdRaw = threadIds.map((id) => id.val);

  logger.debug({
    operation: "getLatest10ThreadsWithResponses",
    threadIds: threadIdRaw,
    message: "Fetching latest responses for threads",
  });

  try {
    // 複雑なクエリ内容なので、流石にsafeqlの補完が効かないと思ったら、効いた・・・？
    const result = (await sql<
      {
        id: string | null;
        thread_id: string | null;
        response_number: number | null;
        author_name: string | null;
        mail: string | null;
        posted_at: Date | null;
        response_content: string | null;
        hash_id: string | null;
        trip: string | null;
      }[]
    >`
        WITH thread_max_response AS(
            -- 各スレッドの最大レスポンス番号を計算（連番なので実質レスポンス数と同じ）
            SELECT
                thread_id,
                MAX(response_number) AS max_response_number
            FROM
                responses
            WHERE
                thread_id = ANY(
                    ${threadIdRaw}::uuid[]
                )
            GROUP BY
                thread_id
        ),
        latest_responses AS(
            -- 各スレッドの最新10件のレスポンスを取得（max_response_numberが12以上の場合）
            SELECT
                r.*
            FROM
                responses r
                JOIN
                    thread_max_response tmr
                ON  r.thread_id = tmr.thread_id
            WHERE
                tmr.max_response_number >= 12
            AND r.response_number > (tmr.max_response_number - 10)
        ),
        first_responses AS(
            -- 各スレッドの最初のレスポンスを取得（max_response_numberが12以上の場合）
            SELECT
                r.*
            FROM
                responses r
                JOIN
                    thread_max_response tmr
                ON  r.thread_id = tmr.thread_id
            WHERE
                tmr.max_response_number >= 12
            AND r.response_number = 1
        ),
        small_threads_responses AS(
            -- 11件以下のスレッドのすべてのレスポンスを取得
            SELECT
                r.*
            FROM
                responses r
                JOIN
                    thread_max_response tmr
                ON  r.thread_id = tmr.thread_id
            WHERE
                tmr.max_response_number <= 11
        )
        -- 結果を結合
        SELECT
            *
        FROM
            (
                SELECT
                    *
                FROM
                    latest_responses
                UNION ALL
                SELECT
                    *
                FROM
                    first_responses
                UNION ALL
                SELECT
                    *
                FROM
                    small_threads_responses
            ) AS combined_results
      `) as {
      id: string;
      thread_id: string;
      response_number: number;
      author_name: string;
      mail: string;
      posted_at: Date;
      response_content: string;
      hash_id: string;
      trip: string | null;
    }[];

    if (!result || result.length === 0) {
      logger.info({
        operation: "getLatest10ThreadsWithResponses",
        threadIds: threadIdRaw,
        message: "No responses found for the specified threads",
      });
      return err(new DataNotFoundError("レスポンスの取得に失敗しました"));
    }

    logger.debug({
      operation: "getLatest10ThreadsWithResponses",
      count: result.length,
      message: "Response data retrieved successfully",
    });

    // 詰め替え部分
    const responses: ReadResponse[] = [];
    for (const response of result) {
      const combinedResult = Result.combine([
        createReadResponseId(response.id),
        createReadThreadId(response.thread_id),
        createReadResponseNumber(response.response_number),
        createReadAuthorName(response.author_name, response.trip),
        createReadMail(response.mail),
        createReadPostedAt(response.posted_at),
        createReadResponseContent(response.response_content),
        createReadHashId(response.hash_id),
      ]);

      if (combinedResult.isErr()) {
        logger.error({
          operation: "getLatest10ThreadsWithResponses",
          error: combinedResult.error,
          message: "Failed to create domain objects from database result",
        });
        return err(combinedResult.error);
      }
      const [
        responseId,
        threadId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      ] = combinedResult.value;

      const responseResult = createReadResponse({
        responseId,
        threadId,
        responseNumber,
        authorName,
        mail,
        postedAt,
        responseContent,
        hashId,
      });

      if (responseResult.isErr()) {
        logger.error({
          operation: "getLatest10ThreadsWithResponses",
          error: responseResult.error,
          message: "Failed to create ReadResponse object",
        });
        return err(responseResult.error);
      }

      responses.push(responseResult.value);
    }

    logger.info({
      operation: "getLatest10ThreadsWithResponses",
      threadIds: threadIdRaw,
      responseCount: responses.length,
      message: "Successfully fetched and processed responses",
    });

    return ok(responses);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "getLatest10ThreadsWithResponses",
      error,
      threadIds: threadIdRaw,
      message: `Database error while fetching responses: ${message}`,
    });
    return err(
      new DatabaseError(
        `レスポンス取得中にエラーが発生しました: ${message}`,
        error
      )
    );
  }
};
</file>

<file path="src/conversation/repositories/updateThreadUpdatedAtRepository.ts">
import { ok, err } from "neverthrow";

import { DatabaseError } from "../../shared/types/Error";
import { createReadThreadId } from "../domain/read/ReadThreadId";
import { type WriteThreadId } from "../domain/write/WriteThreadId";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadThreadId } from "../domain/read/ReadThreadId";
import type { WritePostedAt } from "../domain/write/WritePostedAt";
import type { Result } from "neverthrow";

// スレッドのupdated_atを更新するリポジトリ
// ThreadId・updatedAtを受け取る。
// ThreadIdのみ受け取って操作するのは例外的
export const updateThreadUpdatedAtRepository = async (
  { sql, logger }: VakContext,
  { threadId, updatedAt }: { threadId: WriteThreadId; updatedAt: WritePostedAt }
): Promise<Result<ReadThreadId, DatabaseError>> => {
  logger.debug({
    operation: "updateThreadUpdatedAt",
    threadId: threadId.val,
    updatedAt: updatedAt.val,
    message: "Updating thread timestamp",
  });

  try {
    const result = await sql<{ id: string }[]>`
        UPDATE
            threads
        SET
            updated_at = ${updatedAt.val}
        WHERE
            id = ${threadId.val}::uuid RETURNING id
      `;

    if (!result || result.length !== 1) {
      logger.error({
        operation: "updateThreadUpdatedAt",
        threadId: threadId.val,
        message: "Failed to update thread timestamp, invalid database response",
      });
      return err(new DatabaseError("スレッドの更新に失敗しました"));
    }

    logger.info({
      operation: "updateThreadUpdatedAt",
      threadId: threadId.val,
      updatedAt: updatedAt.val,
      message: "Thread timestamp updated successfully",
    });

    const readThreadIdResult = createReadThreadId(result[0].id);
    if (readThreadIdResult.isErr()) {
      logger.error({
        operation: "updateThreadUpdatedAt",
        threadId: threadId.val,
        message: "Failed to create WriteThreadId from database response",
      });
      return err(readThreadIdResult.error);
    }

    return ok(readThreadIdResult.value);
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    logger.error({
      operation: "updateThreadUpdatedAt",
      threadId: threadId.val,
      error,
      message: `Database error while updating thread timestamp: ${message}`,
    });
    return err(
      new DatabaseError(`更新処理中にエラーが発生しました: ${message}`, error)
    );
  }
};
</file>

<file path="src/conversation/usecases/getAllResponsesByThreadIdUsecase.ts">
import { err, ok } from "neverthrow";

import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { getAllResponsesByThreadIdRepository } from "../repositories/getAllResponsesByThreadIdRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドについているレスをすべて確認するユースケース
export const getAllResponsesByThreadIdUsecase = async (
  vakContext: VakContext,
  { threadIdRaw }: { threadIdRaw: string }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getAllResponsesByThreadId",
    threadId: threadIdRaw,
    message: "Starting thread responses retrieval",
  });

  // ThreadIdを生成
  logger.debug({
    operation: "getAllResponsesByThreadId",
    threadId: threadIdRaw,
    message: "Validating thread ID",
  });

  const threadIdResult = createWriteThreadId(threadIdRaw);
  if (threadIdResult.isErr()) {
    logger.error({
      operation: "getAllResponsesByThreadId",
      error: threadIdResult.error,
      threadId: threadIdRaw,
      message: "Invalid thread ID format",
    });
    return err(threadIdResult.error);
  }

  // スレッド詳細を取得
  logger.debug({
    operation: "getAllResponsesByThreadId",
    threadId: threadIdRaw,
    message: "Fetching thread responses from repository",
  });

  const responsesWithThreadResult = await getAllResponsesByThreadIdRepository(
    vakContext,
    {
      threadId: threadIdResult.value,
    }
  );
  if (responsesWithThreadResult.isErr()) {
    logger.error({
      operation: "getAllResponsesByThreadId",
      error: responsesWithThreadResult.error,
      threadId: threadIdRaw,
      message: "Failed to fetch thread responses",
    });
    return err(responsesWithThreadResult.error);
  }

  logger.info({
    operation: "getAllResponsesByThreadId",
    threadId: threadIdRaw,
    threadTitle: responsesWithThreadResult.value.thread.threadTitle.val,
    responseCount: responsesWithThreadResult.value.responses.length,
    message: "Successfully retrieved thread responses",
  });

  return ok(responsesWithThreadResult.value);
};
</file>

<file path="src/conversation/usecases/getTopPageUsecase.ts">
// トップページのユースケース

import { ok, err } from "neverthrow";

import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { getLatest10ThreadsWithResponsesRepository } from "../repositories/getLatest10ThreadsWithResposesRepository";
import { getLatest30ThreadsRepository } from "../repositories/getLatest30ThreadsRepository";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadResponse } from "../domain/read/ReadResponse";
import type { ReadThread } from "../domain/read/ReadThread";

export const getTopPageUsecase = async (vakContext: VakContext) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getTopPageUsecase",
    message: "Starting top page data retrieval",
  });

  // まずスレッド上位30件を取得
  logger.debug({
    operation: "getTopPageUsecase",
    message: "Fetching top 30 threads",
  });

  const threadsTop30Result = await getLatest30ThreadsRepository(vakContext);
  if (threadsTop30Result.isErr()) {
    logger.error({
      operation: "getTopPageUsecase",
      error: threadsTop30Result.error,
      message: "Failed to fetch top 30 threads",
    });
    return err(threadsTop30Result.error);
  }
  // これがナビゲーションエリアに表示される

  logger.debug({
    operation: "getTopPageUsecase",
    threadCount: threadsTop30Result.value.length,
    message: "Successfully fetched top 30 threads",
  });

  // 次に、スレッド上位30件から上位10件を取得
  const top10ThreadIdsResult = threadsTop30Result.value
    .slice(0, 10)
    .map((thread) => {
      return thread.id;
    });

  // writeThreadIdの配列に変換
  const top10ThreadIds = top10ThreadIdsResult
    .map((threadId) => {
      return createWriteThreadId(threadId.val);
    })
    .filter((threadId) => {
      return threadId.isOk();
    })
    .map((threadId) => {
      return threadId.value;
    });

  logger.debug({
    operation: "getTopPageUsecase",
    top10ThreadIdsCount: top10ThreadIds.length,
    message: "Extracted top 10 thread IDs for detailed response fetching",
  });

  // スレッド上位10件の詳細を取得
  logger.debug({
    operation: "getTopPageUsecase",
    message: "Fetching responses for top 10 threads",
  });

  const responsesTop10 = await getLatest10ThreadsWithResponsesRepository(
    vakContext,
    { threadIds: top10ThreadIds }
  );
  if (responsesTop10.isErr()) {
    logger.error({
      operation: "getTopPageUsecase",
      error: responsesTop10.error,
      message: "Failed to fetch responses for top 10 threads",
    });
    return err(responsesTop10.error);
  }

  logger.debug({
    operation: "getTopPageUsecase",
    responseCount: responsesTop10.value.length,
    message: "Successfully fetched responses for top 10 threads",
  });

  // 上位10件のスレッドのレスについて、先程のふたつを結合して完全版の構造体を作成
  // それぞれのスレッドに対してレスとして表現する構造体を作成
  // まずそれぞれのスレッドについて連想配列を作成
  const threadResponseMap: Map<
    string,
    {
      thread: ReadThread;
      responses: ReadResponse[];
    }
  > = new Map();
  for (const thread of threadsTop30Result.value) {
    threadResponseMap.set(thread.id.val, {
      thread,
      responses: [],
    });
  }

  // 連想配列にレスを追加
  for (const response of responsesTop10.value) {
    const responses = threadResponseMap.get(response.threadId.val);
    if (responses) {
      responses.responses.push(response);
    }
  }

  // 先程の連想配列のすべてのレスを、レス番号で小さい順に並び替える
  for (const [, threadResponse] of threadResponseMap) {
    threadResponse.responses.sort((a, b) => {
      return a.responseNumber.val - b.responseNumber.val;
    });
  }

  // 連想配列を配列にもどす
  const threadResponseArray = Array.from(threadResponseMap.values());

  // 連想配列をupdated_atで降順に並び替える
  threadResponseArray.sort((a, b) => {
    return (
      new Date(b.thread.updatedAt.val).getTime() -
      new Date(a.thread.updatedAt.val).getTime()
    );
  });

  logger.debug({
    operation: "getTopPageUsecase",
    processedThreadCount: threadResponseArray.length,
    message: "Data processing completed for top page display",
  });

  // スレッド上位30件と、
  // スレッド上位10件についてはレスを含めた構造体を返す
  logger.info({
    operation: "getTopPageUsecase",
    threadCount: threadsTop30Result.value.length,
    detailedThreadCount: threadResponseArray.length,
    message: "Successfully retrieved and processed top page data",
  });

  return ok({
    threadTop30: threadsTop30Result.value,
    responsesTop10: threadResponseArray,
  });
};
</file>

<file path="src/conversation/usecases/postThreadUsecase.ts">
import { err, ok } from "neverthrow";

import { getDefaultAuthorNameRepository } from "../../config/repositories/getDefaultAuthorNameRepository";
import { getMaxContentLengthRepository } from "../../config/repositories/getMaxContentLengthRepository";
import { createWriteAuthorName } from "../domain/write/WriteAuthorName";
import { generateWriteHashId } from "../domain/write/WriteHashId";
import { createWriteMail } from "../domain/write/WriteMail";
import { generateCurrentPostedAt } from "../domain/write/WritePostedAt";
import { createWriteResponse } from "../domain/write/WriteResponse";
import { createWriteResponseContent } from "../domain/write/WriteResponseContent";
import { createWriteThread } from "../domain/write/WriteThread";
import { createWriteThreadTitle } from "../domain/write/WriteThreadTitle";
import { createResponseByThreadIdRepository } from "../repositories/createResponseByThreadIdRepository";
import { createThreadRepository } from "../repositories/createThreadRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドを投稿する際のユースケース
export const postThreadUsecase = async (
  vakContext: VakContext,
  {
    // レスポンス番号は必ず1になるので必要ない
    threadTitleRaw,
    authorNameRaw,
    mailRaw,
    responseContentRaw,
    ipAddressRaw,
  }: {
    threadTitleRaw: string;
    authorNameRaw: string | null;
    mailRaw: string | null;
    responseContentRaw: string;
    ipAddressRaw: string;
  }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "postThread",
    threadTitle: threadTitleRaw,
    message: "Starting thread creation process",
  });

  // スレタイを生成
  logger.debug({
    operation: "postThread",
    threadTitle: threadTitleRaw,
    message: "Validating thread title",
  });

  const threadTitleResult = createWriteThreadTitle(threadTitleRaw);
  if (threadTitleResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: threadTitleResult.error,
      threadTitle: threadTitleRaw,
      message: "Invalid thread title format",
    });
    return err(threadTitleResult.error);
  }

  // ユーザ名を生成
  logger.debug({
    operation: "postThread",
    authorName: authorNameRaw,
    message: "Processing author name",
  });

  const authorNameResult = await createWriteAuthorName(
    authorNameRaw,
    async () => {
      logger.debug({
        operation: "postThread",
        message: "Fetching default author name from config",
      });

      const nanashiNameResult = await getDefaultAuthorNameRepository(
        vakContext
      );
      if (nanashiNameResult.isErr()) {
        logger.error({
          operation: "postThread",
          error: nanashiNameResult.error,
          message: "Failed to fetch default author name",
        });
        return err(nanashiNameResult.error);
      }
      return ok(nanashiNameResult.value.val);
    }
  );
  if (authorNameResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: authorNameResult.error,
      authorName: authorNameRaw,
      message: "Invalid author name format",
    });
    return err(authorNameResult.error);
  }

  // メール生成
  logger.debug({
    operation: "postThread",
    mail: mailRaw,
    message: "Validating mail address",
  });

  const mailResult = createWriteMail(mailRaw);
  if (mailResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: mailResult.error,
      mail: mailRaw,
      message: "Invalid mail format",
    });
    return err(mailResult.error);
  }

  // レス内容生成
  logger.debug({
    operation: "postThread",
    contentLength: responseContentRaw.length,
    message: "Validating response content",
  });

  const responseContentResult = await createWriteResponseContent(
    responseContentRaw,
    async () => {
      logger.debug({
        operation: "postThread",
        message: "Fetching max content length from config",
      });

      const result = await getMaxContentLengthRepository(vakContext);
      if (result.isErr()) {
        logger.error({
          operation: "postThread",
          error: result.error,
          message: "Failed to fetch max content length",
        });
        return err(result.error);
      }
      return ok(result.value.val);
    }
  );
  if (responseContentResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: responseContentResult.error,
      contentLength: responseContentRaw.length,
      message: "Invalid response content",
    });
    return err(responseContentResult.error);
  }

  // 現在時刻を生成
  const postedAt = generateCurrentPostedAt();

  // ハッシュ値作成
  logger.debug({
    operation: "postThread",
    message: "Generating hash ID",
  });

  const hashId = generateWriteHashId(ipAddressRaw, postedAt.val);
  if (hashId.isErr()) {
    logger.error({
      operation: "postThread",
      error: hashId.error,
      message: "Failed to generate hash ID",
    });
    return err(hashId.error);
  }

  // まずスレッド作成
  logger.debug({
    operation: "postThread",
    threadTitle: threadTitleRaw,
    message: "Creating thread object",
  });

  const thread = createWriteThread({
    title: threadTitleResult.value,
    postedAt,
  });
  if (thread.isErr()) {
    logger.error({
      operation: "postThread",
      error: thread.error,
      threadTitle: threadTitleRaw,
      message: "Failed to create thread object",
    });
    return err(thread.error);
  }

  // 一番目のレスも作成
  logger.debug({
    operation: "postThread",
    threadId: thread.value.id.val,
    message: "Creating first response object for thread",
  });

  const response = await createWriteResponse({
    getThreadId: async () => {
      return ok(thread.value.id.val);
    },
    authorName: authorNameResult.value,
    mail: mailResult.value,
    responseContent: responseContentResult.value,
    hashId: hashId.value,
    postedAt,
  });
  if (response.isErr()) {
    logger.error({
      operation: "postThread",
      error: response.error,
      threadId: thread.value.id.val,
      message: "Failed to create response object",
    });
    return err(response.error);
  }

  // 最後に永続化
  // 先にレスを作成したほうが安全側に倒せそう
  logger.debug({
    operation: "postThread",
    threadId: thread.value.id.val,
    message: "Persisting response to database",
  });

  const responseResult = await createResponseByThreadIdRepository(
    vakContext,
    response.value
  );
  if (responseResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: responseResult.error,
      threadId: thread.value.id.val,
      message: "Failed to persist response to database",
    });
    return err(responseResult.error);
  }

  logger.debug({
    operation: "postThread",
    threadId: thread.value.id.val,
    threadTitle: threadTitleRaw,
    message: "Persisting thread to database",
  });

  const threadResult = await createThreadRepository(vakContext, thread.value);
  if (threadResult.isErr()) {
    logger.error({
      operation: "postThread",
      error: threadResult.error,
      threadId: thread.value.id.val,
      message: "Failed to persist thread to database",
    });
    return err(threadResult.error);
  }

  logger.info({
    operation: "postThread",
    threadId: thread.value.id.val,
    threadTitle: threadTitleRaw,
    responseId: response.value.id.val,
    message: "Successfully created thread with first response",
  });

  return ok(threadResult.value);
};
</file>

<file path="src/conversation/usecases/getAllResponsesByThreadEpochIdUsecase.ts">
import { err, ok } from "neverthrow";

import { createWriteThreadEpochId } from "../domain/write/WriteThreadEpochId";
import { getAllResponsesByThreadEpochIdRepository } from "../repositories/getAllResponsesByThreadEpochIdRepository";

import type { VakContext } from "../../shared/types/VakContext";

// スレッドについているレスをすべて確認するユースケース
export const getAllResponsesByThreadEpochIdUsecase = async (
  vakContext: VakContext,
  { threadEpochIdRaw }: { threadEpochIdRaw: string }
) => {
  const { logger } = vakContext;

  logger.info({
    operation: "getAllResponsesByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    message: "Starting thread responses retrieval by epoch ID",
  });

  // ThreadEpochIdを生成
  logger.debug({
    operation: "getAllResponsesByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    message: "Validating thread epoch ID",
  });

  const threadEpochId = createWriteThreadEpochId(threadEpochIdRaw);
  if (threadEpochId.isErr()) {
    logger.error({
      operation: "getAllResponsesByThreadEpochId",
      error: threadEpochId.error,
      threadEpochId: threadEpochIdRaw,
      message: "Invalid thread epoch ID format",
    });
    return err(threadEpochId.error);
  }

  // スレッド詳細を取得
  logger.debug({
    operation: "getAllResponsesByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    message: "Fetching thread responses from repository by epoch ID",
  });

  const responsesWithThreadResult =
    await getAllResponsesByThreadEpochIdRepository(vakContext, {
      threadEpochId: threadEpochId.value,
    });
  if (responsesWithThreadResult.isErr()) {
    logger.error({
      operation: "getAllResponsesByThreadEpochId",
      error: responsesWithThreadResult.error,
      threadEpochId: threadEpochIdRaw,
      message: "Failed to fetch thread responses by epoch ID",
    });
    return err(responsesWithThreadResult.error);
  }

  logger.info({
    operation: "getAllResponsesByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    threadTitle: responsesWithThreadResult.value.thread.threadTitle.val,
    responseCount: responsesWithThreadResult.value.responses.length,
    message: "Successfully retrieved thread responses by epoch ID",
  });

  return ok(responsesWithThreadResult.value);
};
</file>

<file path="app/routes/_middleware.tsx">
import { logger } from "hono/logger";
import { pinoLogger, type PinoLogger } from "hono-pino";
import { createRoute } from "honox/factory";

import { csrf } from "../middlewares/csrfMiddleware";
import {
  dbClientMiddlewareConditional,
  type DbClient,
} from "../middlewares/dbInitializeMiddleware";

export default createRoute(
  pinoLogger({
    pino: {
      level: "warn",
    },
  }),
  logger(),
  csrf(),
  dbClientMiddlewareConditional({
    envKey: "DATABASE_URL",
    contextKey: "sql",
  })
);

declare module "hono" {
  interface ContextVariableMap {
    logger: PinoLogger;
    sql: DbClient;
  }
}
</file>

<file path="app/routes/_renderer.tsx">
import { jsxRenderer, useRequestContext } from "hono/jsx-renderer";
import { Link } from "honox/server";

import { getBoardConfigUsecase } from "../../src/config/usecases/getBoardConfigUsecase";
import { ErrorMessage } from "../components/ErrorMessage";

export default jsxRenderer(async ({ children }) => {
  const c = useRequestContext();

  const { sql, logger } = c.var;
  const configResult = await getBoardConfigUsecase({
    sql,
    logger,
  });

  if (configResult.isErr()) {
    console.error(configResult.error.message);
    return <ErrorMessage error={configResult.error} />;
  }

  return (
    <html lang="ja">
      <head>
        <meta charSet="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{configResult.value.boardName.val}</title>
        <Link href="/app/style.css" rel="stylesheet" />
        <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
      </head>
      <body>
        <div className="flex flex-col min-h-screen bg-gray-100 font-aahub-light4">
          <header className="bg-gradient-to-r from-purple-500 to-orange-200 text-white w-full py-4 px-6">
            <div className="container mx-auto">
              <a className="text-3xl font-bold" href="/">
                {configResult.value.boardName.val}
              </a>
              <p className="text-sm">{configResult.value.localRule.val}</p>
            </div>
          </header>

          {children}
        </div>
      </body>
    </html>
  );
});
</file>

<file path="app/routes/admin/index.tsx">
import { createRoute } from "honox/factory";

import { getNormalConfigUsecase } from "../../../src/config/usecases/getNormalConfigUsecase";
import { updateNormalConfigUsecase } from "../../../src/config/usecases/updateNormalConfigUsecase";
import { ErrorMessage } from "../../components/ErrorMessage";

// eslint-disable-next-line @typescript-eslint/naming-convention
export const POST = createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "admin/POST",
    path: c.req.path,
    method: c.req.method,
    message: "Starting board configuration update",
  });

  if (!sql) {
    logger.error({
      operation: "admin/POST",
      message: "Database connection not available",
    });
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }

  const body = await c.req.parseBody();
  const boardName = body.boardName;
  const localRule = body.localRule;
  const nanashiName = body.nanashiName;
  const maxContentLength = body.maxResponseLength;

  logger.debug({
    operation: "admin/POST",
    hasBoardName: typeof boardName === "string",
    hasLocalRule: typeof localRule === "string",
    hasNanashiName: typeof nanashiName === "string",
    hasMaxContentLength: typeof maxContentLength === "string",
    message: "Request body parsed for configuration update",
  });

  if (
    typeof boardName !== "string" ||
    typeof localRule !== "string" ||
    typeof nanashiName !== "string" ||
    typeof maxContentLength !== "string"
  ) {
    logger.warn({
      operation: "admin/POST",
      validationError: "Missing required fields",
      hasBoardName: typeof boardName === "string",
      hasLocalRule: typeof localRule === "string",
      hasNanashiName: typeof nanashiName === "string",
      hasMaxContentLength: typeof maxContentLength === "string",
      message:
        "Configuration update validation failed - missing required fields",
    });
    return c.render(
      <ErrorMessage error={new Error("すべての項目を入力してください")} />
    );
  }

  logger.debug({
    operation: "admin/POST",
    boardName,
    localRule,
    nanashiName,
    maxContentLength,
    message: "Calling updateConfigUsecase",
  });

  const updateConfigResult = await updateNormalConfigUsecase(
    { sql, logger },
    {
      boardNameRaw: boardName,
      localRuleRaw: localRule,
      defaultAuthorNameRaw: nanashiName,
      maxContentLengthRaw: Number(maxContentLength),
    }
  );
  if (updateConfigResult.isErr()) {
    logger.error({
      operation: "admin/POST",
      error: updateConfigResult.error,
      message: "Configuration update failed",
    });
    return c.render(<ErrorMessage error={updateConfigResult.error} />);
  }

  logger.info({
    operation: "admin/POST",
    boardName,
    nanashiName,
    maxContentLength,
    message: "Configuration updated successfully, redirecting to admin page",
  });

  return c.redirect("/admin", 303);
});

export default createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "admin/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Admin configuration page requested",
  });

  // 管理者画面 config関連
  if (!sql) {
    logger.error({
      operation: "admin/GET",
      message: "Database connection not available",
    });
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }

  logger.debug({
    operation: "admin/GET",
    message: "Fetching configuration data",
  });

  const configResult = await getNormalConfigUsecase({ sql, logger });
  if (configResult.isErr()) {
    logger.error({
      operation: "admin/GET",
      error: configResult.error,
      message: "Failed to retrieve configuration data",
    });
    return c.render(<ErrorMessage error={configResult.error} />);
  }

  logger.debug({
    operation: "admin/GET",
    boardName: configResult.value.boardName.val,
    message: "Configuration data retrieved successfully, rendering admin page",
  });

  // フォームの形にする
  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-10">
        <h1 className="text-2xl font-bold text-gray-800 mb-6">管理者画面</h1>
        <h2 className="text-xl font-semibold text-gray-700 mb-4">設定</h2>
        <form method="post" action="/admin" className="w-full">
          <div className="flex flex-col gap-4">
            <div className="flex flex-col">
              <label
                htmlFor="boardName"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                掲示板名
              </label>
              <input
                type="text"
                id="boardName"
                name="boardName"
                value={configResult.value.boardName.val}
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
            <div className="flex flex-col">
              <label
                htmlFor="localRule"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                ルール
              </label>
              <input
                type="text"
                id="localRule"
                name="localRule"
                value={configResult.value.localRule.val}
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
            <div className="flex flex-col">
              <label
                htmlFor="nanashiName"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                デフォルト名
              </label>
              <input
                type="text"
                id="nanashiName"
                name="nanashiName"
                value={configResult.value.defaultAuthorName.val}
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
            <div className="flex flex-col">
              <label
                htmlFor="maxResponseLength"
                className="text-gray-700 text-sm font-bold mb-1"
              >
                最大文字数
              </label>
              <input
                type="number"
                id="maxResponseLength"
                name="maxResponseLength"
                value={configResult.value.maxContentLength.val}
                className="border border-gray-400 rounded py-2 px-3 focus:outline-none focus:shadow-outline"
              />
            </div>
          </div>
          <div className="mt-6 flex justify-end">
            <button
              type="submit"
              className="w-60 bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            >
              更新
            </button>
          </div>
          <div className="mt-4 flex justify-end">
            <a href="/admin/password" className="text-blue-500 underline">
              パスワード変更
            </a>
          </div>
        </form>
      </section>
    </main>
  );
});
</file>

<file path="src/conversation/usecases/postResponseByThreadEpochIdUsecase.ts">
import { err, ok } from "neverthrow";

import { getDefaultAuthorNameRepository } from "../../config/repositories/getDefaultAuthorNameRepository";
import { getMaxContentLengthRepository } from "../../config/repositories/getMaxContentLengthRepository";
import { createWriteAuthorName } from "../domain/write/WriteAuthorName";
import { generateWriteHashId } from "../domain/write/WriteHashId";
import { createWriteMail, isSage } from "../domain/write/WriteMail";
import { generateCurrentPostedAt } from "../domain/write/WritePostedAt";
import { createWriteResponse } from "../domain/write/WriteResponse";
import { createWriteResponseContent } from "../domain/write/WriteResponseContent";
import { createWriteThreadEpochId } from "../domain/write/WriteThreadEpochId";
import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { createResponseByThreadIdRepository } from "../repositories/createResponseByThreadIdRepository";
import { getThreadIdByThreadEpochIdRepository } from "../repositories/getThreadIdByThreadEpochIdRepository";
import { updateThreadUpdatedAtRepository } from "../repositories/updateThreadUpdatedAtRepository";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadThreadId } from "../domain/read/ReadThreadId";
import type { Result } from "neverthrow";

// レスを投稿する際のユースケース
export const postResponseByThreadEpochIdUsecase = async (
  vakContext: VakContext,
  {
    threadEpochIdRaw,
    authorNameRaw,
    mailRaw,
    responseContentRaw,
    ipAddressRaw,
  }: {
    threadEpochIdRaw: string;
    authorNameRaw: string | null;
    mailRaw: string | null;
    responseContentRaw: string;
    ipAddressRaw: string;
  }
): Promise<Result<ReadThreadId, Error>> => {
  const { logger } = vakContext;

  logger.info({
    operation: "postResponseByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    hasAuthorName: authorNameRaw !== null,
    hasMail: mailRaw !== null,
    contentLength: responseContentRaw.length,
    message: "Starting response creation by thread epoch ID",
  });

  // ThreadEpochIdを生成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    message: "Validating thread epoch ID",
  });

  const threadEpochIdResult = createWriteThreadEpochId(threadEpochIdRaw);
  if (threadEpochIdResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: threadEpochIdResult.error,
      threadEpochId: threadEpochIdRaw,
      message: "Invalid thread epoch ID format",
    });
    return err(threadEpochIdResult.error);
  }

  // ThreadIdを取得 read
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    message: "Fetching thread ID from epoch ID",
  });

  const readThreadIdResult = await getThreadIdByThreadEpochIdRepository(
    vakContext,
    {
      threadEpochId: threadEpochIdResult.value,
    }
  );
  if (readThreadIdResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: readThreadIdResult.error,
      threadEpochId: threadEpochIdRaw,
      message: "Failed to retrieve thread ID from epoch ID",
    });
    return err(readThreadIdResult.error);
  }

  // writeにする
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadId: readThreadIdResult.value.val,
    message: "Converting thread ID to write format",
  });

  const writeThreadIdResult = createWriteThreadId(readThreadIdResult.value.val);
  if (writeThreadIdResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: writeThreadIdResult.error,
      threadId: readThreadIdResult.value.val,
      message: "Failed to convert thread ID to write format",
    });
    return err(writeThreadIdResult.error);
  }

  // ユーザ名を生成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadEpochId: threadEpochIdRaw,
    hasAuthorName: authorNameRaw !== null,
    message: "Creating author name",
  });

  const authorNameResult = await createWriteAuthorName(
    authorNameRaw,
    async () => {
      const nanashiNameResult = await getDefaultAuthorNameRepository(
        vakContext
      );
      if (nanashiNameResult.isErr()) {
        return err(nanashiNameResult.error);
      }
      return ok(nanashiNameResult.value.val);
    }
  );
  if (authorNameResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: authorNameResult.error,
      threadEpochId: threadEpochIdRaw,
      authorName: authorNameRaw,
      message: "Failed to create author name",
    });
    return err(authorNameResult.error);
  }

  // メール生成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    hasMail: mailRaw !== null,
    message: "Creating mail",
  });

  const mailResult = createWriteMail(mailRaw);
  if (mailResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: mailResult.error,
      mail: mailRaw,
      message: "Failed to create mail",
    });
    return err(mailResult.error);
  }

  // レス内容生成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    contentLength: responseContentRaw.length,
    message: "Creating response content",
  });

  const responseContentResult = await createWriteResponseContent(
    responseContentRaw,
    async () => {
      const result = await getMaxContentLengthRepository(vakContext);
      if (result.isErr()) {
        return err(result.error);
      }
      return ok(result.value.val);
    }
  );
  if (responseContentResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: responseContentResult.error,
      contentLength: responseContentRaw.length,
      message: "Failed to create response content",
    });
    return err(responseContentResult.error);
  }

  // 現在時刻を生成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    message: "Generating current timestamp",
  });

  const postedAt = generateCurrentPostedAt();

  // ハッシュ値作成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    message: "Generating hash ID",
  });

  const hashId = generateWriteHashId(ipAddressRaw, postedAt.val);
  if (hashId.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: hashId.error,
      message: "Failed to generate hash ID",
    });
    return err(hashId.error);
  }

  // レスを作成
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadId: writeThreadIdResult.value.val,
    message: "Creating response object",
  });

  const response = await createWriteResponse({
    // 高階関数パターン必要なかったかも
    getThreadId: async () => {
      return ok(writeThreadIdResult.value.val);
    },
    authorName: authorNameResult.value,
    mail: mailResult.value,
    responseContent: responseContentResult.value,
    hashId: hashId.value,
    postedAt,
  });
  if (response.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: response.error,
      threadId: writeThreadIdResult.value.val,
      message: "Failed to create response object",
    });
    return err(response.error);
  }

  // 最後に永続化
  logger.debug({
    operation: "postResponseByThreadEpochId",
    threadId: writeThreadIdResult.value.val,
    message: "Persisting response to database",
  });

  const responseResult = await createResponseByThreadIdRepository(
    vakContext,
    response.value
  );
  if (responseResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadEpochId",
      error: responseResult.error,
      threadId: writeThreadIdResult.value.val,
      message: "Failed to persist response to database",
    });
    return err(responseResult.error);
  }

  // また、スレッドのupdated_atも更新する必要がある
  // メールが'sage'でない場合のみ
  if (isSage(mailResult.value)) {
    logger.debug({
      operation: "postResponseByThreadEpochId",
      threadId: writeThreadIdResult.value.val,
      message: "Updating thread updated_at timestamp",
    });

    const threadResult = await updateThreadUpdatedAtRepository(vakContext, {
      threadId: writeThreadIdResult.value,
      updatedAt: postedAt,
    });
    if (threadResult.isErr()) {
      logger.error({
        operation: "postResponseByThreadEpochId",
        error: threadResult.error,
        threadId: writeThreadIdResult.value.val,
        message: "Failed to update thread timestamp",
      });
      return err(threadResult.error);
    }

    logger.debug({
      operation: "postResponseByThreadEpochId",
      threadId: writeThreadIdResult.value.val,
      message: "Successfully updated thread timestamp",
    });
  }

  logger.info({
    operation: "postResponseByThreadEpochId",
    threadId: writeThreadIdResult.value.val,
    threadEpochId: threadEpochIdRaw,
    postedAt: postedAt.val,
    message: "Successfully created response",
  });

  return ok(readThreadIdResult.value);
};
</file>

<file path="src/conversation/usecases/postResponseByThreadIdUsecase.ts">
import { err, ok } from "neverthrow";

import { getDefaultAuthorNameRepository } from "../../config/repositories/getDefaultAuthorNameRepository";
import { getMaxContentLengthRepository } from "../../config/repositories/getMaxContentLengthRepository";
import { type ReadThreadId } from "../domain/read/ReadThreadId";
import { createWriteAuthorName } from "../domain/write/WriteAuthorName";
import { generateWriteHashId } from "../domain/write/WriteHashId";
import { createWriteMail, isSage } from "../domain/write/WriteMail";
import { generateCurrentPostedAt } from "../domain/write/WritePostedAt";
import { createWriteResponse } from "../domain/write/WriteResponse";
import { createWriteResponseContent } from "../domain/write/WriteResponseContent";
import { createWriteThreadId } from "../domain/write/WriteThreadId";
import { createResponseByThreadIdRepository } from "../repositories/createResponseByThreadIdRepository";
import { updateThreadUpdatedAtRepository } from "../repositories/updateThreadUpdatedAtRepository";

import type { VakContext } from "../../shared/types/VakContext";
import type { ReadResponseNumber } from "../domain/read/ReadResponseNumber";
import type { Result } from "neverthrow";

// レスを投稿する際のユースケース
export const postResponseByThreadIdUsecase = async (
  vakContext: VakContext,
  {
    threadIdRaw,
    authorNameRaw,
    mailRaw,
    responseContentRaw,
    ipAddressRaw,
  }: {
    threadIdRaw: string;
    authorNameRaw: string | null;
    mailRaw: string | null;
    responseContentRaw: string;
    ipAddressRaw: string;
  }
): Promise<
  Result<
    {
      threadId: ReadThreadId;
      responseNumber: ReadResponseNumber;
    },
    Error
  >
> => {
  const { logger } = vakContext;

  logger.info({
    operation: "postResponseByThreadId",
    threadId: threadIdRaw,
    message: "Starting response creation process",
  });

  // ThreadIdを生成
  logger.debug({
    operation: "postResponseByThreadId",
    threadId: threadIdRaw,
    message: "Validating thread ID",
  });

  const writeThreadIdResult = createWriteThreadId(threadIdRaw);
  if (writeThreadIdResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: writeThreadIdResult.error,
      threadId: threadIdRaw,
      message: "Invalid thread ID format",
    });
    return err(writeThreadIdResult.error);
  }

  // ユーザ名を生成
  logger.debug({
    operation: "postResponseByThreadId",
    authorName: authorNameRaw,
    message: "Processing author name",
  });

  const authorNameResult = await createWriteAuthorName(
    authorNameRaw,
    async () => {
      logger.debug({
        operation: "postResponseByThreadId",
        message: "Fetching default author name from config",
      });

      const nanashiNameResult = await getDefaultAuthorNameRepository(
        vakContext
      );
      if (nanashiNameResult.isErr()) {
        logger.error({
          operation: "postResponseByThreadId",
          error: nanashiNameResult.error,
          message: "Failed to fetch default author name",
        });
        return err(nanashiNameResult.error);
      }
      return ok(nanashiNameResult.value.val);
    }
  );
  if (authorNameResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: authorNameResult.error,
      authorName: authorNameRaw,
      message: "Invalid author name format",
    });
    return err(authorNameResult.error);
  }

  // メール生成
  logger.debug({
    operation: "postResponseByThreadId",
    mail: mailRaw,
    message: "Validating mail address",
  });

  const mailResult = createWriteMail(mailRaw);
  if (mailResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: mailResult.error,
      mail: mailRaw,
      message: "Invalid mail format",
    });
    return err(mailResult.error);
  }

  // レス内容生成
  logger.debug({
    operation: "postResponseByThreadId",
    contentLength: responseContentRaw.length,
    message: "Validating response content",
  });

  const responseContentResult = await createWriteResponseContent(
    responseContentRaw,
    async () => {
      logger.debug({
        operation: "postResponseByThreadId",
        message: "Fetching max content length from config",
      });

      const result = await getMaxContentLengthRepository(vakContext);
      if (result.isErr()) {
        logger.error({
          operation: "postResponseByThreadId",
          error: result.error,
          message: "Failed to fetch max content length",
        });
        return err(result.error);
      }
      return ok(result.value.val);
    }
  );
  if (responseContentResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: responseContentResult.error,
      contentLength: responseContentRaw.length,
      message: "Invalid response content",
    });
    return err(responseContentResult.error);
  }

  // 現在時刻を生成
  const postedAt = generateCurrentPostedAt();

  // ハッシュ値作成
  logger.debug({
    operation: "postResponseByThreadId",
    message: "Generating hash ID",
  });

  const hashId = generateWriteHashId(ipAddressRaw, postedAt.val);
  if (hashId.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: hashId.error,
      message: "Failed to generate hash ID",
    });
    return err(hashId.error);
  }

  // レスを作成
  logger.debug({
    operation: "postResponseByThreadId",
    message: "Creating response object",
  });

  const response = await createWriteResponse({
    getThreadId: async () => {
      return ok(writeThreadIdResult.value.val);
    },
    authorName: authorNameResult.value,
    mail: mailResult.value,
    responseContent: responseContentResult.value,
    hashId: hashId.value,
    postedAt,
  });
  if (response.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: response.error,
      message: "Failed to create response object",
    });
    return err(response.error);
  }

  // 最後に永続化
  logger.debug({
    operation: "postResponseByThreadId",
    threadId: threadIdRaw,
    message: "Persisting response to database",
  });

  const responseResult = await createResponseByThreadIdRepository(
    vakContext,
    response.value
  );
  if (responseResult.isErr()) {
    logger.error({
      operation: "postResponseByThreadId",
      error: responseResult.error,
      threadId: threadIdRaw,
      message: "Failed to persist response to database",
    });
    return err(responseResult.error);
  }

  const { threadId, responseNumber } = responseResult.value;

  // また、スレッドのupdated_atも更新する必要がある
  // メールが'sage'でない場合のみ
  if (!isSage(mailResult.value)) {
    logger.debug({
      operation: "postResponseByThreadId",
      threadId: threadIdRaw,
      message: "Updating thread updated_at timestamp",
    });

    const threadResult = await updateThreadUpdatedAtRepository(vakContext, {
      threadId: writeThreadIdResult.value,
      updatedAt: postedAt,
    });
    if (threadResult.isErr()) {
      logger.error({
        operation: "postResponseByThreadId",
        error: threadResult.error,
        threadId: threadIdRaw,
        message: "Failed to update thread timestamp",
      });
      return err(threadResult.error);
    }

    logger.debug({
      operation: "postResponseByThreadId",
      threadId: threadIdRaw,
      message: "Successfully updated thread timestamp",
    });
  }

  logger.info({
    operation: "postResponseByThreadId",
    threadId: threadIdRaw,
    responseId: response.value.id.val,
    message: "Successfully created response",
  });

  return ok({
    threadId,
    responseNumber,
  });
};
</file>

<file path="app/routes/threads/[id]/index.tsx">
import { createRoute } from "honox/factory";

import { formatReadAuthorName } from "../../../../src/conversation/domain/read/ReadAuthorName";
import { isSage } from "../../../../src/conversation/domain/write/WriteMail";
import { getAllResponsesByThreadIdUsecase } from "../../../../src/conversation/usecases/getAllResponsesByThreadIdUsecase";
import { formatDate } from "../../../../src/shared/utils/formatDate";
import { ErrorMessage } from "../../../components/ErrorMessage";
import { ResponseContentComponent } from "../../../components/ResponseContent";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "threads/[id]/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Thread detail page requested",
  });

  if (!sql) {
    logger.error({
      operation: "threads/[id]/GET",
      message: "Database connection not available",
    });
    c.status(500);
    return c.render(
      <ErrorMessage error={new Error("DBに接続できませんでした")} />
    );
  }

  const id = c.req.param("id");

  logger.debug({
    operation: "threads/[id]/GET",
    threadId: id,
    message: "Fetching thread responses",
  });

  const allResponsesResult = await getAllResponsesByThreadIdUsecase(
    { sql, logger },
    { threadIdRaw: id }
  );
  if (allResponsesResult.isErr()) {
    logger.error({
      operation: "threads/[id]/GET",
      error: allResponsesResult.error,
      threadId: id,
      message: "Failed to fetch thread responses",
    });
    c.status(404);
    return c.render(<ErrorMessage error={allResponsesResult.error} />);
  }

  // 最新のレス番号を取得
  const latestResponseNumber =
    allResponsesResult.value.responses[
      allResponsesResult.value.responses.length - 1
    ].responseNumber.val;

  logger.debug({
    operation: "threads/[id]/GET",
    threadId: id,
    threadTitle: allResponsesResult.value.thread.threadTitle.val,
    responseCount: allResponsesResult.value.responses.length,
    message: "Successfully fetched thread responses, rendering page",
  });

  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6 mb-8">
        <div>
          <h3 className="text-purple-600 font-bold text-xl mb-4">
            {allResponsesResult.value.thread.threadTitle.val} (
            {allResponsesResult.value.responses.length})
          </h3>
          {allResponsesResult.value.responses.map((resp) => {
            return (
              <div
                key={resp.responseNumber.val}
                // スレッドIDとレス番号を組み合わせてアンカーとなるIDを生成
                id={`${resp.threadId.val}-${resp.responseNumber.val}`}
                className="bg-gray-50 p-4 rounded-md"
              >
                <div className="flex flex-wrap items-center gap-2 mb-2">
                  <span className="font-bold">{resp.responseNumber.val}</span>
                  <span
                    className={`text-gray-700 ${
                      isSage(resp.mail) ? "text-violet-600" : ""
                    }`}
                  >
                    {formatReadAuthorName(resp.authorName)}
                  </span>
                  <span className="text-gray-500 text-sm">
                    {formatDate(resp.postedAt.val)}
                  </span>
                  <span className="text-gray-500 text-sm">
                    ID: {resp.hashId.val}
                  </span>
                </div>
                <div className="text-gray-800 max-h-80 overflow-y-auto whitespace-pre-wrap">
                  <ResponseContentComponent
                    threadId={resp.threadId}
                    responseContent={resp.responseContent}
                  />
                </div>
              </div>
            );
          })}
        </div>
        <div className="flex gap-4 mt-2">
          <a
            href={`/threads/${allResponsesResult.value.thread.threadId.val}`}
            className="text-blue-600 hover:underline"
          >
            全部読む
          </a>
          <a
            href={`/threads/${allResponsesResult.value.thread.threadId.val}/l50`}
            className="text-blue-600 hover:underline"
          >
            最新50件
          </a>
          <a
            href={`/threads/${allResponsesResult.value.thread.threadId.val}/1-100`}
            className="text-blue-600 hover:underline"
          >
            1-100
          </a>
          <a
            href={`/threads/${allResponsesResult.value.thread.threadId.val}/${latestResponseNumber}-`}
            className="text-blue-600 hover:underline"
          >
            新着レスの表示
          </a>
        </div>
      </section>
      <section className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-2xl font-semibold mb-4">返信する</h2>
        <form
          method="post"
          action={`/threads/${id}/responses`}
          className="flex flex-col gap-4"
        >
          <div className="flex flex-col md:flex-row gap-4">
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              名前:
              <input
                type="text"
                name="name"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              メールアドレス:
              <input
                name="mail"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
          </div>
          <div>
            <label className="block text-gray-700 text-sm font-bold mb-2">
              本文:
              <textarea
                name="content"
                required
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline h-32"
              ></textarea>
            </label>
          </div>
          <button
            type="submit"
            className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
          >
            書き込む
          </button>
        </form>
      </section>
    </main>
  );
});
</file>

<file path="app/routes/index.tsx">
import { createRoute } from "honox/factory";

import { formatReadAuthorName } from "../../src/conversation/domain/read/ReadAuthorName";
import { isSage } from "../../src/conversation/domain/write/WriteMail";
import { getTopPageUsecase } from "../../src/conversation/usecases/getTopPageUsecase";
import { formatDate } from "../../src/shared/utils/formatDate";
import { ErrorMessage } from "../components/ErrorMessage";
import { ResponseContentComponent } from "../components/ResponseContent";

export default createRoute(async (c) => {
  const { sql, logger } = c.var;

  logger.info({
    operation: "index/GET",
    path: c.req.path,
    method: c.req.method,
    message: "Rendering top page",
  });

  logger.debug({
    operation: "index/GET",
    message: "Calling getTopPageUsecase to retrieve data",
  });

  const usecaseResult = await getTopPageUsecase({
    sql,
    logger,
  });

  if (usecaseResult.isErr()) {
    logger.error({
      operation: "index/GET",
      error: usecaseResult.error,
      message: "Failed to retrieve top page data",
    });
    return c.render(<ErrorMessage error={usecaseResult.error} />);
  }

  const { threadTop30, responsesTop10 } = usecaseResult.value;

  logger.debug({
    operation: "index/GET",
    threadCount: threadTop30.length,
    topThreadCount: responsesTop10.length,
    message: "Successfully retrieved top page data, rendering page",
  });

  return c.render(
    <main className="container mx-auto flex-grow py-8 px-4">
      <section className="bg-white rounded-lg shadow-md p-6 mb-8">
        <div className="mb-4">
          <h2 className="text-xl font-semibold">人気スレッド</h2>
        </div>
        <ul className="flex flex-wrap gap-4">
          {threadTop30.map((thread, index) => (
            <li key={thread.id.val} className="flex-none">
              <a
                className="text-purple-600 underline"
                href={`/threads/${thread.id.val}/l50`}
              >
                {index + 1}: {thread.title.val} ({thread.countResponse})
              </a>
            </li>
          ))}
        </ul>
        <div className="mt-4">
          <a href="/subback.html" className="text-blue-600 hover:underline">
            全スレッド一覧
          </a>
        </div>
      </section>

      <section className="mb-8">
        <ul className="flex flex-col gap-4">
          {responsesTop10.map((threadResp, threadIndex) => (
            <li
              key={threadResp.thread.id.val}
              className="bg-white rounded-lg shadow-md p-6 pb-4"
            >
              <h3 className="text-purple-600 font-bold text-xl">
                【{threadIndex + 1}:{threadResp.thread.countResponse}】{" "}
                {threadResp.thread.title.val}
              </h3>
              <ul className="flex flex-col gap-2 mt-2">
                {threadResp.responses.map((resp) => (
                  <li
                    key={resp.responseId.val}
                    id={`${resp.threadId.val}-${resp.responseNumber.val}`}
                    className="bg-gray-50 p-4 rounded-md"
                  >
                    <div className="flex flex-wrap items-center gap-2 mb-2">
                      <span className="font-bold">
                        {resp.responseNumber.val}
                      </span>
                      <span
                        className={`text-gray-700 ${
                          isSage(resp.mail) ? "text-violet-600" : ""
                        }`}
                      >
                        名前: {formatReadAuthorName(resp.authorName)}
                      </span>
                      <span className="text-gray-500 text-sm">
                        {formatDate(resp.postedAt.val)}
                      </span>
                      <span className="text-gray-500 text-sm">
                        ID: {resp.hashId.val}
                      </span>
                    </div>
                    <div className="text-gray-800 max-h-80 overflow-y-auto whitespace-pre-wrap">
                      <ResponseContentComponent
                        threadId={resp.threadId}
                        responseContent={resp.responseContent}
                      />
                    </div>
                  </li>
                ))}
              </ul>
              <div className="m-4 p-2 rounded-md">
                <h3 className="text-xl font-semibold mb-4">返信する</h3>
                <form
                  method="post"
                  action={`/threads/${threadResp.thread.id.val}/responses`}
                  className="flex flex-col gap-4"
                >
                  <div className="flex flex-col md:flex-row gap-4">
                    <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
                      名前:
                      <input
                        type="text"
                        name="name"
                        className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
                      />
                    </label>
                    <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
                      メールアドレス:
                      <input
                        name="mail"
                        className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
                      />
                    </label>
                  </div>
                  <div>
                    <label className="block text-gray-700 text-sm font-bold mb-2">
                      本文:
                      <textarea
                        name="content"
                        required
                        className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline h-32"
                      ></textarea>
                    </label>
                  </div>
                  <button
                    type="submit"
                    className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
                  >
                    書き込む
                  </button>
                </form>
                <div className="flex gap-4 mt-2">
                  <a
                    href={`/threads/${threadResp.thread.id.val}`}
                    className="text-blue-600 hover:underline"
                  >
                    全部読む
                  </a>
                  <a
                    href={`/threads/${threadResp.thread.id.val}/l50`}
                    className="text-blue-600 hover:underline"
                  >
                    最新50件
                  </a>
                  <a
                    href={`/threads/${threadResp.thread.id.val}/1-100`}
                    className="text-blue-600 hover:underline"
                  >
                    1-100
                  </a>
                </div>
              </div>
            </li>
          ))}
        </ul>
      </section>

      <section className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-2xl font-semibold mb-4">新規スレッド作成</h2>
        <form method="post" action="/threads" className="flex flex-col gap-2">
          <div>
            <label className="block text-gray-700 text-sm font-bold mb-2">
              スレッドタイトル:
              <input
                type="text"
                name="title"
                required
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
          </div>
          <div className="flex flex-col md:flex-row gap-4">
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              名前:
              <input
                type="text"
                name="name"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
            <label className="block text-gray-700 text-sm font-bold mb-2 md:w-1/2">
              メールアドレス:
              <input
                name="mail"
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline"
              />
            </label>
          </div>
          <div>
            <label className="block text-gray-700 text-sm font-bold mb-2">
              本文:
              <textarea
                name="content"
                required
                className="border border-gray-400 rounded w-full py-2 px-3 text-gray-700 focus:outline-none focus:shadow-outline h-32"
              ></textarea>
            </label>
          </div>
          <button
            type="submit"
            className="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
          >
            新規スレッド作成
          </button>
        </form>
      </section>
    </main>
  );
});
</file>

</files>
